//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!

#include "Core/PlayFabProgressionDataModels.h"
#include "Core/PlayFabJsonHelpers.h"

using namespace PlayFab;
using namespace PlayFab::ProgressionModels;

PlayFab::ProgressionModels::FLinkedStatisticColumn::~FLinkedStatisticColumn()
{

}

void PlayFab::ProgressionModels::FLinkedStatisticColumn::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!LinkedStatisticColumnName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: LinkedStatisticColumn::LinkedStatisticColumnName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LinkedStatisticColumnName"));
        writer->WriteValue(LinkedStatisticColumnName);
    }

    if (!LinkedStatisticName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: LinkedStatisticColumn::LinkedStatisticName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LinkedStatisticName"));
        writer->WriteValue(LinkedStatisticName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FLinkedStatisticColumn::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> LinkedStatisticColumnNameValue = obj->TryGetField(TEXT("LinkedStatisticColumnName"));
    if (LinkedStatisticColumnNameValue.IsValid() && !LinkedStatisticColumnNameValue->IsNull())
    {
        FString TmpValue;
        if (LinkedStatisticColumnNameValue->TryGetString(TmpValue)) { LinkedStatisticColumnName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LinkedStatisticNameValue = obj->TryGetField(TEXT("LinkedStatisticName"));
    if (LinkedStatisticNameValue.IsValid() && !LinkedStatisticNameValue->IsNull())
    {
        FString TmpValue;
        if (LinkedStatisticNameValue->TryGetString(TmpValue)) { LinkedStatisticName = TmpValue; }
    }

    return HasSucceeded;
}

void PlayFab::ProgressionModels::writeLeaderboardSortDirectionEnumJSON(LeaderboardSortDirection enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case LeaderboardSortDirectionDescending: writer->WriteValue(TEXT("Descending")); break;
    case LeaderboardSortDirectionAscending: writer->WriteValue(TEXT("Ascending")); break;
    }
}

ProgressionModels::LeaderboardSortDirection PlayFab::ProgressionModels::readLeaderboardSortDirectionFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readLeaderboardSortDirectionFromValue(value.IsValid() ? value->AsString() : "");
}

ProgressionModels::LeaderboardSortDirection PlayFab::ProgressionModels::readLeaderboardSortDirectionFromValue(const FString& value)
{
    static TMap<FString, LeaderboardSortDirection> _LeaderboardSortDirectionMap;
    if (_LeaderboardSortDirectionMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _LeaderboardSortDirectionMap.Add(TEXT("Descending"), LeaderboardSortDirectionDescending);
        _LeaderboardSortDirectionMap.Add(TEXT("Ascending"), LeaderboardSortDirectionAscending);

    }

    if (!value.IsEmpty())
    {
        auto output = _LeaderboardSortDirectionMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return LeaderboardSortDirectionDescending; // Basically critical fail
}

PlayFab::ProgressionModels::FLeaderboardColumn::~FLeaderboardColumn()
{
    //if (LinkedStatisticColumn != nullptr) delete LinkedStatisticColumn;

}

void PlayFab::ProgressionModels::FLeaderboardColumn::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (pfLinkedStatisticColumn.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("LinkedStatisticColumn"));
        pfLinkedStatisticColumn->writeJSON(writer);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: LeaderboardColumn::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("SortDirection"));
    writeLeaderboardSortDirectionEnumJSON(SortDirection, writer);

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FLeaderboardColumn::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> LinkedStatisticColumnValue = obj->TryGetField(TEXT("LinkedStatisticColumn"));
    if (LinkedStatisticColumnValue.IsValid() && !LinkedStatisticColumnValue->IsNull())
    {
        pfLinkedStatisticColumn = MakeShareable(new FLinkedStatisticColumn(LinkedStatisticColumnValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    SortDirection = readLeaderboardSortDirectionFromValue(obj->TryGetField(TEXT("SortDirection")));

    return HasSucceeded;
}

void PlayFab::ProgressionModels::writeResetIntervalEnumJSON(ResetInterval enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ResetIntervalManual: writer->WriteValue(TEXT("Manual")); break;
    case ResetIntervalHour: writer->WriteValue(TEXT("Hour")); break;
    case ResetIntervalDay: writer->WriteValue(TEXT("Day")); break;
    case ResetIntervalWeek: writer->WriteValue(TEXT("Week")); break;
    case ResetIntervalMonth: writer->WriteValue(TEXT("Month")); break;
    }
}

ProgressionModels::ResetInterval PlayFab::ProgressionModels::readResetIntervalFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readResetIntervalFromValue(value.IsValid() ? value->AsString() : "");
}

ProgressionModels::ResetInterval PlayFab::ProgressionModels::readResetIntervalFromValue(const FString& value)
{
    static TMap<FString, ResetInterval> _ResetIntervalMap;
    if (_ResetIntervalMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ResetIntervalMap.Add(TEXT("Manual"), ResetIntervalManual);
        _ResetIntervalMap.Add(TEXT("Hour"), ResetIntervalHour);
        _ResetIntervalMap.Add(TEXT("Day"), ResetIntervalDay);
        _ResetIntervalMap.Add(TEXT("Week"), ResetIntervalWeek);
        _ResetIntervalMap.Add(TEXT("Month"), ResetIntervalMonth);

    }

    if (!value.IsEmpty())
    {
        auto output = _ResetIntervalMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ResetIntervalManual; // Basically critical fail
}

PlayFab::ProgressionModels::FVersionConfiguration::~FVersionConfiguration()
{

}

void PlayFab::ProgressionModels::FVersionConfiguration::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("MaxQueryableVersions"));
    writer->WriteValue(MaxQueryableVersions);

    writer->WriteIdentifierPrefix(TEXT("ResetInterval"));
    writeResetIntervalEnumJSON(pfResetInterval, writer);

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FVersionConfiguration::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MaxQueryableVersionsValue = obj->TryGetField(TEXT("MaxQueryableVersions"));
    if (MaxQueryableVersionsValue.IsValid() && !MaxQueryableVersionsValue->IsNull())
    {
        int32 TmpValue;
        if (MaxQueryableVersionsValue->TryGetNumber(TmpValue)) { MaxQueryableVersions = TmpValue; }
    }

    pfResetInterval = readResetIntervalFromValue(obj->TryGetField(TEXT("ResetInterval")));

    return HasSucceeded;
}

PlayFab::ProgressionModels::FCreateLeaderboardDefinitionRequest::~FCreateLeaderboardDefinitionRequest()
{

}

void PlayFab::ProgressionModels::FCreateLeaderboardDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteArrayStart(TEXT("Columns"));
    for (const FLeaderboardColumn& item : Columns)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!EntityType.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateLeaderboardDefinitionRequest::EntityType, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("EntityType"));
        writer->WriteValue(EntityType);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateLeaderboardDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("SizeLimit"));
    writer->WriteValue(SizeLimit);

    writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
    pfVersionConfiguration.writeJSON(writer);

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FCreateLeaderboardDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FLeaderboardColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityTypeValue = obj->TryGetField(TEXT("EntityType"));
    if (EntityTypeValue.IsValid() && !EntityTypeValue->IsNull())
    {
        FString TmpValue;
        if (EntityTypeValue->TryGetString(TmpValue)) { EntityType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SizeLimitValue = obj->TryGetField(TEXT("SizeLimit"));
    if (SizeLimitValue.IsValid() && !SizeLimitValue->IsNull())
    {
        int32 TmpValue;
        if (SizeLimitValue->TryGetNumber(TmpValue)) { SizeLimit = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = FVersionConfiguration(VersionConfigurationValue->AsObject());
    }

    return HasSucceeded;
}

void PlayFab::ProgressionModels::writeStatisticAggregationMethodEnumJSON(StatisticAggregationMethod enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case StatisticAggregationMethodLast: writer->WriteValue(TEXT("Last")); break;
    case StatisticAggregationMethodMin: writer->WriteValue(TEXT("Min")); break;
    case StatisticAggregationMethodMax: writer->WriteValue(TEXT("Max")); break;
    case StatisticAggregationMethodSum: writer->WriteValue(TEXT("Sum")); break;
    }
}

ProgressionModels::StatisticAggregationMethod PlayFab::ProgressionModels::readStatisticAggregationMethodFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readStatisticAggregationMethodFromValue(value.IsValid() ? value->AsString() : "");
}

ProgressionModels::StatisticAggregationMethod PlayFab::ProgressionModels::readStatisticAggregationMethodFromValue(const FString& value)
{
    static TMap<FString, StatisticAggregationMethod> _StatisticAggregationMethodMap;
    if (_StatisticAggregationMethodMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _StatisticAggregationMethodMap.Add(TEXT("Last"), StatisticAggregationMethodLast);
        _StatisticAggregationMethodMap.Add(TEXT("Min"), StatisticAggregationMethodMin);
        _StatisticAggregationMethodMap.Add(TEXT("Max"), StatisticAggregationMethodMax);
        _StatisticAggregationMethodMap.Add(TEXT("Sum"), StatisticAggregationMethodSum);

    }

    if (!value.IsEmpty())
    {
        auto output = _StatisticAggregationMethodMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return StatisticAggregationMethodLast; // Basically critical fail
}

PlayFab::ProgressionModels::FStatisticColumn::~FStatisticColumn()
{

}

void PlayFab::ProgressionModels::FStatisticColumn::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("AggregationMethod"));
    writeStatisticAggregationMethodEnumJSON(AggregationMethod, writer);

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: StatisticColumn::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FStatisticColumn::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    AggregationMethod = readStatisticAggregationMethodFromValue(obj->TryGetField(TEXT("AggregationMethod")));

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FCreateStatisticDefinitionRequest::~FCreateStatisticDefinitionRequest()
{
    //if (VersionConfiguration != nullptr) delete VersionConfiguration;

}

void PlayFab::ProgressionModels::FCreateStatisticDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AggregationSources.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AggregationSources"));
        for (const FString& item : AggregationSources)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (Columns.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Columns"));
        for (const FStatisticColumn& item : Columns)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (EntityType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("EntityType"));
        writer->WriteValue(EntityType);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateStatisticDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (pfVersionConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
        pfVersionConfiguration->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FCreateStatisticDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("AggregationSources"), AggregationSources);

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FStatisticColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityTypeValue = obj->TryGetField(TEXT("EntityType"));
    if (EntityTypeValue.IsValid() && !EntityTypeValue->IsNull())
    {
        FString TmpValue;
        if (EntityTypeValue->TryGetString(TmpValue)) { EntityType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = MakeShareable(new FVersionConfiguration(VersionConfigurationValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FDeleteLeaderboardDefinitionRequest::~FDeleteLeaderboardDefinitionRequest()
{

}

void PlayFab::ProgressionModels::FDeleteLeaderboardDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteLeaderboardDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FDeleteLeaderboardDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FDeleteLeaderboardEntriesRequest::~FDeleteLeaderboardEntriesRequest()
{

}

void PlayFab::ProgressionModels::FDeleteLeaderboardEntriesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (EntityIds.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("EntityIds"));
        for (const FString& item : EntityIds)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteLeaderboardEntriesRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FDeleteLeaderboardEntriesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    obj->TryGetStringArrayField(TEXT("EntityIds"), EntityIds);

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FDeleteStatisticDefinitionRequest::~FDeleteStatisticDefinitionRequest()
{

}

void PlayFab::ProgressionModels::FDeleteStatisticDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteStatisticDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FDeleteStatisticDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FEntityKey::~FEntityKey()
{

}

void PlayFab::ProgressionModels::FEntityKey::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!Id.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: EntityKey::Id, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Id"));
        writer->WriteValue(Id);
    }

    if (Type.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Type"));
        writer->WriteValue(Type);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FEntityKey::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IdValue = obj->TryGetField(TEXT("Id"));
    if (IdValue.IsValid() && !IdValue->IsNull())
    {
        FString TmpValue;
        if (IdValue->TryGetString(TmpValue)) { Id = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TypeValue = obj->TryGetField(TEXT("Type"));
    if (TypeValue.IsValid() && !TypeValue->IsNull())
    {
        FString TmpValue;
        if (TypeValue->TryGetString(TmpValue)) { Type = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FStatisticDelete::~FStatisticDelete()
{

}

void PlayFab::ProgressionModels::FStatisticDelete::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: StatisticDelete::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FStatisticDelete::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FDeleteStatisticsRequest::~FDeleteStatisticsRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FDeleteStatisticsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    writer->WriteArrayStart(TEXT("Statistics"));
    for (const FStatisticDelete& item : Statistics)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FDeleteStatisticsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&StatisticsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Statistics"));
    for (int32 Idx = 0; Idx < StatisticsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = StatisticsArray[Idx];
        Statistics.Add(FStatisticDelete(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::ProgressionModels::FDeleteStatisticsResponse::~FDeleteStatisticsResponse()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FDeleteStatisticsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FDeleteStatisticsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FEmptyResponse::~FEmptyResponse()
{

}

void PlayFab::ProgressionModels::FEmptyResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FEmptyResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::ProgressionModels::FEntityLeaderboardEntry::~FEntityLeaderboardEntry()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FEntityLeaderboardEntry::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DisplayName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("DisplayName"));
        writer->WriteValue(DisplayName);
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("LastUpdated"));
    writeDatetime(LastUpdated, writer);

    if (Metadata.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Metadata"));
        writer->WriteValue(Metadata);
    }

    writer->WriteIdentifierPrefix(TEXT("Rank"));
    writer->WriteValue(Rank);

    if (Scores.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Scores"));
        for (const FString& item : Scores)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FEntityLeaderboardEntry::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DisplayNameValue = obj->TryGetField(TEXT("DisplayName"));
    if (DisplayNameValue.IsValid() && !DisplayNameValue->IsNull())
    {
        FString TmpValue;
        if (DisplayNameValue->TryGetString(TmpValue)) { DisplayName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> LastUpdatedValue = obj->TryGetField(TEXT("LastUpdated"));
    if (LastUpdatedValue.IsValid())
        LastUpdated = readDatetime(LastUpdatedValue);


    const TSharedPtr<FJsonValue> MetadataValue = obj->TryGetField(TEXT("Metadata"));
    if (MetadataValue.IsValid() && !MetadataValue->IsNull())
    {
        FString TmpValue;
        if (MetadataValue->TryGetString(TmpValue)) { Metadata = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RankValue = obj->TryGetField(TEXT("Rank"));
    if (RankValue.IsValid() && !RankValue->IsNull())
    {
        int32 TmpValue;
        if (RankValue->TryGetNumber(TmpValue)) { Rank = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("Scores"), Scores);

    return HasSucceeded;
}

PlayFab::ProgressionModels::FEntityStatisticValue::~FEntityStatisticValue()
{

}

void PlayFab::ProgressionModels::FEntityStatisticValue::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Metadata.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Metadata"));
        writer->WriteValue(Metadata);
    }

    if (Name.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (Scores.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Scores"));
        for (const FString& item : Scores)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(Version);

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FEntityStatisticValue::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MetadataValue = obj->TryGetField(TEXT("Metadata"));
    if (MetadataValue.IsValid() && !MetadataValue->IsNull())
    {
        FString TmpValue;
        if (MetadataValue->TryGetString(TmpValue)) { Metadata = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("Scores"), Scores);

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        int32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FEntityStatistics::~FEntityStatistics()
{
    //if (EntityKey != nullptr) delete EntityKey;

}

void PlayFab::ProgressionModels::FEntityStatistics::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (pfEntityKey.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("EntityKey"));
        pfEntityKey->writeJSON(writer);
    }

    if (Statistics.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Statistics"));
        for (const FEntityStatisticValue& item : Statistics)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FEntityStatistics::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> EntityKeyValue = obj->TryGetField(TEXT("EntityKey"));
    if (EntityKeyValue.IsValid() && !EntityKeyValue->IsNull())
    {
        pfEntityKey = MakeShareable(new FEntityKey(EntityKeyValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&StatisticsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Statistics"));
    for (int32 Idx = 0; Idx < StatisticsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = StatisticsArray[Idx];
        Statistics.Add(FEntityStatisticValue(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

void PlayFab::ProgressionModels::writeExternalFriendSourcesEnumJSON(ExternalFriendSources enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ExternalFriendSourcesNone: writer->WriteValue(TEXT("None")); break;
    case ExternalFriendSourcesSteam: writer->WriteValue(TEXT("Steam")); break;
    case ExternalFriendSourcesFacebook: writer->WriteValue(TEXT("Facebook")); break;
    case ExternalFriendSourcesXbox: writer->WriteValue(TEXT("Xbox")); break;
    case ExternalFriendSourcesPsn: writer->WriteValue(TEXT("Psn")); break;
    case ExternalFriendSourcesAll: writer->WriteValue(TEXT("All")); break;
    }
}

ProgressionModels::ExternalFriendSources PlayFab::ProgressionModels::readExternalFriendSourcesFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readExternalFriendSourcesFromValue(value.IsValid() ? value->AsString() : "");
}

ProgressionModels::ExternalFriendSources PlayFab::ProgressionModels::readExternalFriendSourcesFromValue(const FString& value)
{
    static TMap<FString, ExternalFriendSources> _ExternalFriendSourcesMap;
    if (_ExternalFriendSourcesMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ExternalFriendSourcesMap.Add(TEXT("None"), ExternalFriendSourcesNone);
        _ExternalFriendSourcesMap.Add(TEXT("Steam"), ExternalFriendSourcesSteam);
        _ExternalFriendSourcesMap.Add(TEXT("Facebook"), ExternalFriendSourcesFacebook);
        _ExternalFriendSourcesMap.Add(TEXT("Xbox"), ExternalFriendSourcesXbox);
        _ExternalFriendSourcesMap.Add(TEXT("Psn"), ExternalFriendSourcesPsn);
        _ExternalFriendSourcesMap.Add(TEXT("All"), ExternalFriendSourcesAll);

    }

    if (!value.IsEmpty())
    {
        auto output = _ExternalFriendSourcesMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ExternalFriendSourcesNone; // Basically critical fail
}

PlayFab::ProgressionModels::FGetEntityLeaderboardRequest::~FGetEntityLeaderboardRequest()
{

}

void PlayFab::ProgressionModels::FGetEntityLeaderboardRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!LeaderboardName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetEntityLeaderboardRequest::LeaderboardName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LeaderboardName"));
        writer->WriteValue(LeaderboardName);
    }

    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(static_cast<int64>(PageSize));

    if (StartingPosition.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("StartingPosition"));
        writer->WriteValue(static_cast<int64>(StartingPosition));
    }

    if (Version.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Version"));
        writer->WriteValue(static_cast<int64>(Version));
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetEntityLeaderboardRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> LeaderboardNameValue = obj->TryGetField(TEXT("LeaderboardName"));
    if (LeaderboardNameValue.IsValid() && !LeaderboardNameValue->IsNull())
    {
        FString TmpValue;
        if (LeaderboardNameValue->TryGetString(TmpValue)) { LeaderboardName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        uint32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StartingPositionValue = obj->TryGetField(TEXT("StartingPosition"));
    if (StartingPositionValue.IsValid() && !StartingPositionValue->IsNull())
    {
        uint32 TmpValue;
        if (StartingPositionValue->TryGetNumber(TmpValue)) { StartingPosition = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetEntityLeaderboardResponse::~FGetEntityLeaderboardResponse()
{

}

void PlayFab::ProgressionModels::FGetEntityLeaderboardResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Columns.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Columns"));
        for (const FLeaderboardColumn& item : Columns)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("EntryCount"));
    writer->WriteValue(static_cast<int64>(EntryCount));

    if (NextReset.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("NextReset"));
        writeDatetime(NextReset, writer);
    }

    if (Rankings.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Rankings"));
        for (const FEntityLeaderboardEntry& item : Rankings)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetEntityLeaderboardResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FLeaderboardColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> EntryCountValue = obj->TryGetField(TEXT("EntryCount"));
    if (EntryCountValue.IsValid() && !EntryCountValue->IsNull())
    {
        uint32 TmpValue;
        if (EntryCountValue->TryGetNumber(TmpValue)) { EntryCount = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NextResetValue = obj->TryGetField(TEXT("NextReset"));
    if (NextResetValue.IsValid())
        NextReset = readDatetime(NextResetValue);


    const TArray<TSharedPtr<FJsonValue>>&RankingsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Rankings"));
    for (int32 Idx = 0; Idx < RankingsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RankingsArray[Idx];
        Rankings.Add(FEntityLeaderboardEntry(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetFriendLeaderboardForEntityRequest::~FGetFriendLeaderboardForEntityRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FGetFriendLeaderboardForEntityRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (pfExternalFriendSources.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ExternalFriendSources"));
        writeExternalFriendSourcesEnumJSON(pfExternalFriendSources, writer);
    }

    if (!LeaderboardName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetFriendLeaderboardForEntityRequest::LeaderboardName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LeaderboardName"));
        writer->WriteValue(LeaderboardName);
    }

    if (Version.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Version"));
        writer->WriteValue(static_cast<int64>(Version));
    }

    if (XboxToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("XboxToken"));
        writer->WriteValue(XboxToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetFriendLeaderboardForEntityRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    pfExternalFriendSources = readExternalFriendSourcesFromValue(obj->TryGetField(TEXT("ExternalFriendSources")));

    const TSharedPtr<FJsonValue> LeaderboardNameValue = obj->TryGetField(TEXT("LeaderboardName"));
    if (LeaderboardNameValue.IsValid() && !LeaderboardNameValue->IsNull())
    {
        FString TmpValue;
        if (LeaderboardNameValue->TryGetString(TmpValue)) { LeaderboardName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    const TSharedPtr<FJsonValue> XboxTokenValue = obj->TryGetField(TEXT("XboxToken"));
    if (XboxTokenValue.IsValid() && !XboxTokenValue->IsNull())
    {
        FString TmpValue;
        if (XboxTokenValue->TryGetString(TmpValue)) { XboxToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetLeaderboardAroundEntityRequest::~FGetLeaderboardAroundEntityRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FGetLeaderboardAroundEntityRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (!LeaderboardName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetLeaderboardAroundEntityRequest::LeaderboardName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LeaderboardName"));
        writer->WriteValue(LeaderboardName);
    }

    writer->WriteIdentifierPrefix(TEXT("MaxSurroundingEntries"));
    writer->WriteValue(static_cast<int64>(MaxSurroundingEntries));

    if (Version.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Version"));
        writer->WriteValue(static_cast<int64>(Version));
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetLeaderboardAroundEntityRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> LeaderboardNameValue = obj->TryGetField(TEXT("LeaderboardName"));
    if (LeaderboardNameValue.IsValid() && !LeaderboardNameValue->IsNull())
    {
        FString TmpValue;
        if (LeaderboardNameValue->TryGetString(TmpValue)) { LeaderboardName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MaxSurroundingEntriesValue = obj->TryGetField(TEXT("MaxSurroundingEntries"));
    if (MaxSurroundingEntriesValue.IsValid() && !MaxSurroundingEntriesValue->IsNull())
    {
        uint32 TmpValue;
        if (MaxSurroundingEntriesValue->TryGetNumber(TmpValue)) { MaxSurroundingEntries = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetLeaderboardDefinitionRequest::~FGetLeaderboardDefinitionRequest()
{

}

void PlayFab::ProgressionModels::FGetLeaderboardDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetLeaderboardDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetLeaderboardDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetLeaderboardDefinitionResponse::~FGetLeaderboardDefinitionResponse()
{

}

void PlayFab::ProgressionModels::FGetLeaderboardDefinitionResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteArrayStart(TEXT("Columns"));
    for (const FLeaderboardColumn& item : Columns)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteIdentifierPrefix(TEXT("Created"));
    writeDatetime(Created, writer);

    if (!EntityType.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetLeaderboardDefinitionResponse::EntityType, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("EntityType"));
        writer->WriteValue(EntityType);
    }

    if (LastResetTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastResetTime"));
        writeDatetime(LastResetTime, writer);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetLeaderboardDefinitionResponse::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("SizeLimit"));
    writer->WriteValue(SizeLimit);

    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
    pfVersionConfiguration.writeJSON(writer);

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetLeaderboardDefinitionResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FLeaderboardColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> CreatedValue = obj->TryGetField(TEXT("Created"));
    if (CreatedValue.IsValid())
        Created = readDatetime(CreatedValue);


    const TSharedPtr<FJsonValue> EntityTypeValue = obj->TryGetField(TEXT("EntityType"));
    if (EntityTypeValue.IsValid() && !EntityTypeValue->IsNull())
    {
        FString TmpValue;
        if (EntityTypeValue->TryGetString(TmpValue)) { EntityType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastResetTimeValue = obj->TryGetField(TEXT("LastResetTime"));
    if (LastResetTimeValue.IsValid())
        LastResetTime = readDatetime(LastResetTimeValue);


    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SizeLimitValue = obj->TryGetField(TEXT("SizeLimit"));
    if (SizeLimitValue.IsValid() && !SizeLimitValue->IsNull())
    {
        int32 TmpValue;
        if (SizeLimitValue->TryGetNumber(TmpValue)) { SizeLimit = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = FVersionConfiguration(VersionConfigurationValue->AsObject());
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetLeaderboardForEntitiesRequest::~FGetLeaderboardForEntitiesRequest()
{

}

void PlayFab::ProgressionModels::FGetLeaderboardForEntitiesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteArrayStart(TEXT("EntityIds"));
    for (const FString& item : EntityIds)
        writer->WriteValue(item);
    writer->WriteArrayEnd();


    if (!LeaderboardName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetLeaderboardForEntitiesRequest::LeaderboardName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LeaderboardName"));
        writer->WriteValue(LeaderboardName);
    }

    if (Version.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Version"));
        writer->WriteValue(static_cast<int64>(Version));
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetLeaderboardForEntitiesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    obj->TryGetStringArrayField(TEXT("EntityIds"), EntityIds);

    const TSharedPtr<FJsonValue> LeaderboardNameValue = obj->TryGetField(TEXT("LeaderboardName"));
    if (LeaderboardNameValue.IsValid() && !LeaderboardNameValue->IsNull())
    {
        FString TmpValue;
        if (LeaderboardNameValue->TryGetString(TmpValue)) { LeaderboardName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetStatisticDefinitionRequest::~FGetStatisticDefinitionRequest()
{

}

void PlayFab::ProgressionModels::FGetStatisticDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetStatisticDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetStatisticDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetStatisticDefinitionResponse::~FGetStatisticDefinitionResponse()
{
    //if (VersionConfiguration != nullptr) delete VersionConfiguration;

}

void PlayFab::ProgressionModels::FGetStatisticDefinitionResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AggregationDestinations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AggregationDestinations"));
        for (const FString& item : AggregationDestinations)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (AggregationSources.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AggregationSources"));
        for (const FString& item : AggregationSources)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (Columns.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Columns"));
        for (const FStatisticColumn& item : Columns)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("Created"));
    writeDatetime(Created, writer);

    if (EntityType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("EntityType"));
        writer->WriteValue(EntityType);
    }

    if (LastResetTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastResetTime"));
        writeDatetime(LastResetTime, writer);
    }

    if (LinkedLeaderboardNames.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("LinkedLeaderboardNames"));
        for (const FString& item : LinkedLeaderboardNames)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (Name.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    if (pfVersionConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
        pfVersionConfiguration->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetStatisticDefinitionResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("AggregationDestinations"), AggregationDestinations);

    obj->TryGetStringArrayField(TEXT("AggregationSources"), AggregationSources);

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FStatisticColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> CreatedValue = obj->TryGetField(TEXT("Created"));
    if (CreatedValue.IsValid())
        Created = readDatetime(CreatedValue);


    const TSharedPtr<FJsonValue> EntityTypeValue = obj->TryGetField(TEXT("EntityType"));
    if (EntityTypeValue.IsValid() && !EntityTypeValue->IsNull())
    {
        FString TmpValue;
        if (EntityTypeValue->TryGetString(TmpValue)) { EntityType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastResetTimeValue = obj->TryGetField(TEXT("LastResetTime"));
    if (LastResetTimeValue.IsValid())
        LastResetTime = readDatetime(LastResetTimeValue);


    obj->TryGetStringArrayField(TEXT("LinkedLeaderboardNames"), LinkedLeaderboardNames);

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = MakeShareable(new FVersionConfiguration(VersionConfigurationValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetStatisticsForEntitiesRequest::~FGetStatisticsForEntitiesRequest()
{

}

void PlayFab::ProgressionModels::FGetStatisticsForEntitiesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteArrayStart(TEXT("Entities"));
    for (const FEntityKey& item : Entities)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (StatisticNames.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("StatisticNames"));
        for (const FString& item : StatisticNames)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetStatisticsForEntitiesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&EntitiesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Entities"));
    for (int32 Idx = 0; Idx < EntitiesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = EntitiesArray[Idx];
        Entities.Add(FEntityKey(CurrentItem->AsObject()));
    }


    obj->TryGetStringArrayField(TEXT("StatisticNames"), StatisticNames);

    return HasSucceeded;
}

PlayFab::ProgressionModels::FStatisticColumnCollection::~FStatisticColumnCollection()
{

}

void PlayFab::ProgressionModels::FStatisticColumnCollection::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Columns.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Columns"));
        for (const FStatisticColumn& item : Columns)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FStatisticColumnCollection::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FStatisticColumn(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetStatisticsForEntitiesResponse::~FGetStatisticsForEntitiesResponse()
{

}

void PlayFab::ProgressionModels::FGetStatisticsForEntitiesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ColumnDetails.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("ColumnDetails"));
        for (TMap<FString, FStatisticColumnCollection>::TConstIterator It(ColumnDetails); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            (*It).Value.writeJSON(writer);
        }
        writer->WriteObjectEnd();
    }

    if (EntitiesStatistics.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("EntitiesStatistics"));
        for (const FEntityStatistics& item : EntitiesStatistics)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetStatisticsForEntitiesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* ColumnDetailsObject;
    if (obj->TryGetObjectField(TEXT("ColumnDetails"), ColumnDetailsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*ColumnDetailsObject)->Values); It; ++It)
        {
            ColumnDetails.Add(It.Key(), FStatisticColumnCollection(It.Value()->AsObject()));
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&EntitiesStatisticsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("EntitiesStatistics"));
    for (int32 Idx = 0; Idx < EntitiesStatisticsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = EntitiesStatisticsArray[Idx];
        EntitiesStatistics.Add(FEntityStatistics(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetStatisticsRequest::~FGetStatisticsRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FGetStatisticsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (StatisticNames.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("StatisticNames"));
        for (const FString& item : StatisticNames)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetStatisticsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    obj->TryGetStringArrayField(TEXT("StatisticNames"), StatisticNames);

    return HasSucceeded;
}

PlayFab::ProgressionModels::FGetStatisticsResponse::~FGetStatisticsResponse()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FGetStatisticsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ColumnDetails.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("ColumnDetails"));
        for (TMap<FString, FStatisticColumnCollection>::TConstIterator It(ColumnDetails); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            (*It).Value.writeJSON(writer);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (Statistics.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Statistics"));
        for (TMap<FString, FEntityStatisticValue>::TConstIterator It(Statistics); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            (*It).Value.writeJSON(writer);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FGetStatisticsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* ColumnDetailsObject;
    if (obj->TryGetObjectField(TEXT("ColumnDetails"), ColumnDetailsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*ColumnDetailsObject)->Values); It; ++It)
        {
            ColumnDetails.Add(It.Key(), FStatisticColumnCollection(It.Value()->AsObject()));
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* StatisticsObject;
    if (obj->TryGetObjectField(TEXT("Statistics"), StatisticsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*StatisticsObject)->Values); It; ++It)
        {
            Statistics.Add(It.Key(), FEntityStatisticValue(It.Value()->AsObject()));
        }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FIncrementLeaderboardVersionRequest::~FIncrementLeaderboardVersionRequest()
{

}

void PlayFab::ProgressionModels::FIncrementLeaderboardVersionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: IncrementLeaderboardVersionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FIncrementLeaderboardVersionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FIncrementLeaderboardVersionResponse::~FIncrementLeaderboardVersionResponse()
{

}

void PlayFab::ProgressionModels::FIncrementLeaderboardVersionResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FIncrementLeaderboardVersionResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FIncrementStatisticVersionRequest::~FIncrementStatisticVersionRequest()
{

}

void PlayFab::ProgressionModels::FIncrementStatisticVersionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: IncrementStatisticVersionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FIncrementStatisticVersionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FIncrementStatisticVersionResponse::~FIncrementStatisticVersionResponse()
{

}

void PlayFab::ProgressionModels::FIncrementStatisticVersionResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FIncrementStatisticVersionResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FLeaderboardDefinition::~FLeaderboardDefinition()
{

}

void PlayFab::ProgressionModels::FLeaderboardDefinition::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteArrayStart(TEXT("Columns"));
    for (const FLeaderboardColumn& item : Columns)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteIdentifierPrefix(TEXT("Created"));
    writeDatetime(Created, writer);

    if (!EntityType.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: LeaderboardDefinition::EntityType, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("EntityType"));
        writer->WriteValue(EntityType);
    }

    if (LastResetTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastResetTime"));
        writeDatetime(LastResetTime, writer);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: LeaderboardDefinition::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("SizeLimit"));
    writer->WriteValue(SizeLimit);

    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
    pfVersionConfiguration.writeJSON(writer);

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FLeaderboardDefinition::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FLeaderboardColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> CreatedValue = obj->TryGetField(TEXT("Created"));
    if (CreatedValue.IsValid())
        Created = readDatetime(CreatedValue);


    const TSharedPtr<FJsonValue> EntityTypeValue = obj->TryGetField(TEXT("EntityType"));
    if (EntityTypeValue.IsValid() && !EntityTypeValue->IsNull())
    {
        FString TmpValue;
        if (EntityTypeValue->TryGetString(TmpValue)) { EntityType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastResetTimeValue = obj->TryGetField(TEXT("LastResetTime"));
    if (LastResetTimeValue.IsValid())
        LastResetTime = readDatetime(LastResetTimeValue);


    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SizeLimitValue = obj->TryGetField(TEXT("SizeLimit"));
    if (SizeLimitValue.IsValid() && !SizeLimitValue->IsNull())
    {
        int32 TmpValue;
        if (SizeLimitValue->TryGetNumber(TmpValue)) { SizeLimit = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = FVersionConfiguration(VersionConfigurationValue->AsObject());
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FLeaderboardEntryUpdate::~FLeaderboardEntryUpdate()
{

}

void PlayFab::ProgressionModels::FLeaderboardEntryUpdate::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!EntityId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: LeaderboardEntryUpdate::EntityId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("EntityId"));
        writer->WriteValue(EntityId);
    }

    if (Metadata.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Metadata"));
        writer->WriteValue(Metadata);
    }

    if (Scores.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Scores"));
        for (const FString& item : Scores)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FLeaderboardEntryUpdate::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> EntityIdValue = obj->TryGetField(TEXT("EntityId"));
    if (EntityIdValue.IsValid() && !EntityIdValue->IsNull())
    {
        FString TmpValue;
        if (EntityIdValue->TryGetString(TmpValue)) { EntityId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MetadataValue = obj->TryGetField(TEXT("Metadata"));
    if (MetadataValue.IsValid() && !MetadataValue->IsNull())
    {
        FString TmpValue;
        if (MetadataValue->TryGetString(TmpValue)) { Metadata = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("Scores"), Scores);

    return HasSucceeded;
}

PlayFab::ProgressionModels::FListLeaderboardDefinitionsRequest::~FListLeaderboardDefinitionsRequest()
{

}

void PlayFab::ProgressionModels::FListLeaderboardDefinitionsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FListLeaderboardDefinitionsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FListLeaderboardDefinitionsResponse::~FListLeaderboardDefinitionsResponse()
{

}

void PlayFab::ProgressionModels::FListLeaderboardDefinitionsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (LeaderboardDefinitions.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("LeaderboardDefinitions"));
        for (const FLeaderboardDefinition& item : LeaderboardDefinitions)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FListLeaderboardDefinitionsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&LeaderboardDefinitionsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("LeaderboardDefinitions"));
    for (int32 Idx = 0; Idx < LeaderboardDefinitionsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = LeaderboardDefinitionsArray[Idx];
        LeaderboardDefinitions.Add(FLeaderboardDefinition(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::ProgressionModels::FListStatisticDefinitionsRequest::~FListStatisticDefinitionsRequest()
{

}

void PlayFab::ProgressionModels::FListStatisticDefinitionsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FListStatisticDefinitionsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FStatisticDefinition::~FStatisticDefinition()
{
    //if (VersionConfiguration != nullptr) delete VersionConfiguration;

}

void PlayFab::ProgressionModels::FStatisticDefinition::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AggregationDestinations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AggregationDestinations"));
        for (const FString& item : AggregationDestinations)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (AggregationSources.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AggregationSources"));
        for (const FString& item : AggregationSources)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (Columns.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Columns"));
        for (const FStatisticColumn& item : Columns)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("Created"));
    writeDatetime(Created, writer);

    if (EntityType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("EntityType"));
        writer->WriteValue(EntityType);
    }

    if (LastResetTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastResetTime"));
        writeDatetime(LastResetTime, writer);
    }

    if (LinkedLeaderboardNames.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("LinkedLeaderboardNames"));
        for (const FString& item : LinkedLeaderboardNames)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (Name.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("Version"));
    writer->WriteValue(static_cast<int64>(Version));

    if (pfVersionConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
        pfVersionConfiguration->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FStatisticDefinition::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("AggregationDestinations"), AggregationDestinations);

    obj->TryGetStringArrayField(TEXT("AggregationSources"), AggregationSources);

    const TArray<TSharedPtr<FJsonValue>>&ColumnsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Columns"));
    for (int32 Idx = 0; Idx < ColumnsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ColumnsArray[Idx];
        Columns.Add(FStatisticColumn(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> CreatedValue = obj->TryGetField(TEXT("Created"));
    if (CreatedValue.IsValid())
        Created = readDatetime(CreatedValue);


    const TSharedPtr<FJsonValue> EntityTypeValue = obj->TryGetField(TEXT("EntityType"));
    if (EntityTypeValue.IsValid() && !EntityTypeValue->IsNull())
    {
        FString TmpValue;
        if (EntityTypeValue->TryGetString(TmpValue)) { EntityType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastResetTimeValue = obj->TryGetField(TEXT("LastResetTime"));
    if (LastResetTimeValue.IsValid())
        LastResetTime = readDatetime(LastResetTimeValue);


    obj->TryGetStringArrayField(TEXT("LinkedLeaderboardNames"), LinkedLeaderboardNames);

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = MakeShareable(new FVersionConfiguration(VersionConfigurationValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FListStatisticDefinitionsResponse::~FListStatisticDefinitionsResponse()
{

}

void PlayFab::ProgressionModels::FListStatisticDefinitionsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (StatisticDefinitions.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("StatisticDefinitions"));
        for (const FStatisticDefinition& item : StatisticDefinitions)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FListStatisticDefinitionsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&StatisticDefinitionsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("StatisticDefinitions"));
    for (int32 Idx = 0; Idx < StatisticDefinitionsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = StatisticDefinitionsArray[Idx];
        StatisticDefinitions.Add(FStatisticDefinition(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::ProgressionModels::FStatisticUpdate::~FStatisticUpdate()
{

}

void PlayFab::ProgressionModels::FStatisticUpdate::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Metadata.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Metadata"));
        writer->WriteValue(Metadata);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: StatisticUpdate::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (Scores.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Scores"));
        for (const FString& item : Scores)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (Version.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Version"));
        writer->WriteValue(static_cast<int64>(Version));
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FStatisticUpdate::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MetadataValue = obj->TryGetField(TEXT("Metadata"));
    if (MetadataValue.IsValid() && !MetadataValue->IsNull())
    {
        FString TmpValue;
        if (MetadataValue->TryGetString(TmpValue)) { Metadata = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("Scores"), Scores);

    const TSharedPtr<FJsonValue> VersionValue = obj->TryGetField(TEXT("Version"));
    if (VersionValue.IsValid() && !VersionValue->IsNull())
    {
        uint32 TmpValue;
        if (VersionValue->TryGetNumber(TmpValue)) { Version = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FUnlinkLeaderboardFromStatisticRequest::~FUnlinkLeaderboardFromStatisticRequest()
{

}

void PlayFab::ProgressionModels::FUnlinkLeaderboardFromStatisticRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UnlinkLeaderboardFromStatisticRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (!StatisticName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UnlinkLeaderboardFromStatisticRequest::StatisticName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("StatisticName"));
        writer->WriteValue(StatisticName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FUnlinkLeaderboardFromStatisticRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StatisticNameValue = obj->TryGetField(TEXT("StatisticName"));
    if (StatisticNameValue.IsValid() && !StatisticNameValue->IsNull())
    {
        FString TmpValue;
        if (StatisticNameValue->TryGetString(TmpValue)) { StatisticName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FUpdateLeaderboardDefinitionRequest::~FUpdateLeaderboardDefinitionRequest()
{
    //if (VersionConfiguration != nullptr) delete VersionConfiguration;

}

void PlayFab::ProgressionModels::FUpdateLeaderboardDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateLeaderboardDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (SizeLimit.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("SizeLimit"));
        writer->WriteValue(SizeLimit);
    }

    if (pfVersionConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
        pfVersionConfiguration->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FUpdateLeaderboardDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SizeLimitValue = obj->TryGetField(TEXT("SizeLimit"));
    if (SizeLimitValue.IsValid() && !SizeLimitValue->IsNull())
    {
        int32 TmpValue;
        if (SizeLimitValue->TryGetNumber(TmpValue)) { SizeLimit = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = MakeShareable(new FVersionConfiguration(VersionConfigurationValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FUpdateLeaderboardEntriesRequest::~FUpdateLeaderboardEntriesRequest()
{

}

void PlayFab::ProgressionModels::FUpdateLeaderboardEntriesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Entries"));
        for (const FLeaderboardEntryUpdate& item : Entries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (!LeaderboardName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateLeaderboardEntriesRequest::LeaderboardName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LeaderboardName"));
        writer->WriteValue(LeaderboardName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FUpdateLeaderboardEntriesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&EntriesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Entries"));
    for (int32 Idx = 0; Idx < EntriesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = EntriesArray[Idx];
        Entries.Add(FLeaderboardEntryUpdate(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> LeaderboardNameValue = obj->TryGetField(TEXT("LeaderboardName"));
    if (LeaderboardNameValue.IsValid() && !LeaderboardNameValue->IsNull())
    {
        FString TmpValue;
        if (LeaderboardNameValue->TryGetString(TmpValue)) { LeaderboardName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FUpdateStatisticDefinitionRequest::~FUpdateStatisticDefinitionRequest()
{
    //if (VersionConfiguration != nullptr) delete VersionConfiguration;

}

void PlayFab::ProgressionModels::FUpdateStatisticDefinitionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateStatisticDefinitionRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (pfVersionConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("VersionConfiguration"));
        pfVersionConfiguration->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FUpdateStatisticDefinitionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VersionConfigurationValue = obj->TryGetField(TEXT("VersionConfiguration"));
    if (VersionConfigurationValue.IsValid() && !VersionConfigurationValue->IsNull())
    {
        pfVersionConfiguration = MakeShareable(new FVersionConfiguration(VersionConfigurationValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FUpdateStatisticsRequest::~FUpdateStatisticsRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FUpdateStatisticsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    writer->WriteArrayStart(TEXT("Statistics"));
    for (const FStatisticUpdate& item : Statistics)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (TransactionId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("TransactionId"));
        writer->WriteValue(TransactionId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FUpdateStatisticsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&StatisticsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Statistics"));
    for (int32 Idx = 0; Idx < StatisticsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = StatisticsArray[Idx];
        Statistics.Add(FStatisticUpdate(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> TransactionIdValue = obj->TryGetField(TEXT("TransactionId"));
    if (TransactionIdValue.IsValid() && !TransactionIdValue->IsNull())
    {
        FString TmpValue;
        if (TransactionIdValue->TryGetString(TmpValue)) { TransactionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::ProgressionModels::FUpdateStatisticsResponse::~FUpdateStatisticsResponse()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::ProgressionModels::FUpdateStatisticsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ColumnDetails.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("ColumnDetails"));
        for (TMap<FString, FStatisticColumnCollection>::TConstIterator It(ColumnDetails); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            (*It).Value.writeJSON(writer);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (Statistics.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Statistics"));
        for (TMap<FString, FEntityStatisticValue>::TConstIterator It(Statistics); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            (*It).Value.writeJSON(writer);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::ProgressionModels::FUpdateStatisticsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* ColumnDetailsObject;
    if (obj->TryGetObjectField(TEXT("ColumnDetails"), ColumnDetailsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*ColumnDetailsObject)->Values); It; ++It)
        {
            ColumnDetails.Add(It.Key(), FStatisticColumnCollection(It.Value()->AsObject()));
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* StatisticsObject;
    if (obj->TryGetObjectField(TEXT("Statistics"), StatisticsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*StatisticsObject)->Values); It; ++It)
        {
            Statistics.Add(It.Key(), FEntityStatisticValue(It.Value()->AsObject()));
        }
    }

    return HasSucceeded;
}

