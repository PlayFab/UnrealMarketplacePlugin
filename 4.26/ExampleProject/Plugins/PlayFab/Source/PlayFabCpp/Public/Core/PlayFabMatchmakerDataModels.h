//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "PlayFabCppBaseModel.h"

namespace PlayFab
{
namespace MatchmakerModels
{

    struct PLAYFABCPP_API FAuthUserRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Session Ticket provided by the client.
        FString AuthorizationTicket;

        FAuthUserRequest() :
            FPlayFabCppRequestCommon(),
            AuthorizationTicket()
            {}

        FAuthUserRequest(const FAuthUserRequest& src) :
            FPlayFabCppRequestCommon(),
            AuthorizationTicket(src.AuthorizationTicket)
            {}

        FAuthUserRequest(const TSharedPtr<FJsonObject>& obj) : FAuthUserRequest()
        {
            readFromValue(obj);
        }

        ~FAuthUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAuthUserResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // Boolean indicating if the user has been authorized to use the external match-making service.
        bool Authorized;

        // [optional] PlayFab unique identifier of the account that has been authorized.
        FString PlayFabId;

        FAuthUserResponse() :
            FPlayFabCppResultCommon(),
            Authorized(false),
            PlayFabId()
            {}

        FAuthUserResponse(const FAuthUserResponse& src) :
            FPlayFabCppResultCommon(),
            Authorized(src.Authorized),
            PlayFabId(src.PlayFabId)
            {}

        FAuthUserResponse(const TSharedPtr<FJsonObject>& obj) : FAuthUserResponse()
        {
            readFromValue(obj);
        }

        ~FAuthUserResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FItemInstance : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        /**
         * [optional] A set of custom key-value pairs on the instance of the inventory item, which is not to be confused with the catalog
         * item's custom data.
         */
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // [optional] Currency type for the cost of the catalog item. Not available when granting items.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency. Not available when granting items.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FItemInstance() :
            FPlayFabCppBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PurchaseDate(),
            RemainingUses(),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FItemInstance(const FItemInstance& src) :
            FPlayFabCppBaseModel(),
            Annotation(src.Annotation),
            BundleContents(src.BundleContents),
            BundleParent(src.BundleParent),
            CatalogVersion(src.CatalogVersion),
            CustomData(src.CustomData),
            DisplayName(src.DisplayName),
            Expiration(src.Expiration),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            PurchaseDate(src.PurchaseDate),
            RemainingUses(src.RemainingUses),
            UnitCurrency(src.UnitCurrency),
            UnitPrice(src.UnitPrice),
            UsesIncrementedBy(src.UsesIncrementedBy)
            {}

        FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }

        ~FItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerJoinedRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * Unique identifier of the Game Server Instance the user is joining. This must be a Game Server Instance started with the
         * Matchmaker/StartGame API.
         */
        FString LobbyId;

        // PlayFab unique identifier for the player joining.
        FString PlayFabId;

        FPlayerJoinedRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId(),
            PlayFabId()
            {}

        FPlayerJoinedRequest(const FPlayerJoinedRequest& src) :
            FPlayFabCppRequestCommon(),
            CustomTags(src.CustomTags),
            LobbyId(src.LobbyId),
            PlayFabId(src.PlayFabId)
            {}

        FPlayerJoinedRequest(const TSharedPtr<FJsonObject>& obj) : FPlayerJoinedRequest()
        {
            readFromValue(obj);
        }

        ~FPlayerJoinedRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerJoinedResponse : public PlayFab::FPlayFabCppResultCommon
    {
        FPlayerJoinedResponse() :
            FPlayFabCppResultCommon()
            {}

        FPlayerJoinedResponse(const FPlayerJoinedResponse& src) :
            FPlayFabCppResultCommon()
            {}

        FPlayerJoinedResponse(const TSharedPtr<FJsonObject>& obj) : FPlayerJoinedResponse()
        {
            readFromValue(obj);
        }

        ~FPlayerJoinedResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerLeftRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * Unique identifier of the Game Server Instance the user is leaving. This must be a Game Server Instance started with the
         * Matchmaker/StartGame API.
         */
        FString LobbyId;

        // PlayFab unique identifier for the player leaving.
        FString PlayFabId;

        FPlayerLeftRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId(),
            PlayFabId()
            {}

        FPlayerLeftRequest(const FPlayerLeftRequest& src) :
            FPlayFabCppRequestCommon(),
            CustomTags(src.CustomTags),
            LobbyId(src.LobbyId),
            PlayFabId(src.PlayFabId)
            {}

        FPlayerLeftRequest(const TSharedPtr<FJsonObject>& obj) : FPlayerLeftRequest()
        {
            readFromValue(obj);
        }

        ~FPlayerLeftRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerLeftResponse : public PlayFab::FPlayFabCppResultCommon
    {
        FPlayerLeftResponse() :
            FPlayFabCppResultCommon()
            {}

        FPlayerLeftResponse(const FPlayerLeftResponse& src) :
            FPlayFabCppResultCommon()
            {}

        FPlayerLeftResponse(const TSharedPtr<FJsonObject>& obj) : FPlayerLeftResponse()
        {
            readFromValue(obj);
        }

        ~FPlayerLeftResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Region
    {
        RegionUSCentral,
        RegionUSEast,
        RegionEUWest,
        RegionSingapore,
        RegionJapan,
        RegionBrazil,
        RegionAustralia
    };

    PLAYFABCPP_API void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
    PLAYFABCPP_API Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API Region readRegionFromValue(const FString& value);

    struct PLAYFABCPP_API FStartGameRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique identifier of the previously uploaded build executable which is to be started.
        FString Build;

        // [optional] Custom command line argument when starting game server process.
        FString CustomCommandLineData;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * HTTP endpoint URL for receiving game status events, if using an external matchmaker. When the game ends, PlayFab will
         * make a POST request to this URL with the X-SecretKey header set to the value of the game's secret and an
         * application/json body of { "EventName": "game_ended", "GameID": "<gameid>" }.
         */
        FString ExternalMatchmakerEventEndpoint;

        // Game mode for this Game Server Instance.
        FString GameMode;

        // Region with which to associate the server, for filtering.
        Region pfRegion;

        FStartGameRequest() :
            FPlayFabCppRequestCommon(),
            Build(),
            CustomCommandLineData(),
            CustomTags(),
            ExternalMatchmakerEventEndpoint(),
            GameMode(),
            pfRegion()
            {}

        FStartGameRequest(const FStartGameRequest& src) :
            FPlayFabCppRequestCommon(),
            Build(src.Build),
            CustomCommandLineData(src.CustomCommandLineData),
            CustomTags(src.CustomTags),
            ExternalMatchmakerEventEndpoint(src.ExternalMatchmakerEventEndpoint),
            GameMode(src.GameMode),
            pfRegion(src.pfRegion)
            {}

        FStartGameRequest(const TSharedPtr<FJsonObject>& obj) : FStartGameRequest()
        {
            readFromValue(obj);
        }

        ~FStartGameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FStartGameResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Unique identifier for the game/lobby in the new Game Server Instance.
        FString GameID;

        // [optional] IPV4 address of the server
        FString ServerIPV4Address;

        // [optional] IPV6 address of the new Game Server Instance.
        FString ServerIPV6Address;

        // Port number for communication with the Game Server Instance.
        uint32 ServerPort;

        // [optional] Public DNS name (if any) of the server
        FString ServerPublicDNSName;

        FStartGameResponse() :
            FPlayFabCppResultCommon(),
            GameID(),
            ServerIPV4Address(),
            ServerIPV6Address(),
            ServerPort(0),
            ServerPublicDNSName()
            {}

        FStartGameResponse(const FStartGameResponse& src) :
            FPlayFabCppResultCommon(),
            GameID(src.GameID),
            ServerIPV4Address(src.ServerIPV4Address),
            ServerIPV6Address(src.ServerIPV6Address),
            ServerPort(src.ServerPort),
            ServerPublicDNSName(src.ServerPublicDNSName)
            {}

        FStartGameResponse(const TSharedPtr<FJsonObject>& obj) : FStartGameResponse()
        {
            readFromValue(obj);
        }

        ~FStartGameResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserInfoRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * Minimum catalog version for which data is requested (filters the results to only contain inventory items which have a
         * catalog version of this or higher).
         */
        int32 MinCatalogVersion;

        // PlayFab unique identifier of the user whose information is being requested.
        FString PlayFabId;

        FUserInfoRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            MinCatalogVersion(0),
            PlayFabId()
            {}

        FUserInfoRequest(const FUserInfoRequest& src) :
            FPlayFabCppRequestCommon(),
            CustomTags(src.CustomTags),
            MinCatalogVersion(src.MinCatalogVersion),
            PlayFabId(src.PlayFabId)
            {}

        FUserInfoRequest(const TSharedPtr<FJsonObject>& obj) : FUserInfoRequest()
        {
            readFromValue(obj);
        }

        ~FUserInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVirtualCurrencyRechargeTime : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value
         * through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen
         * below this value.
         */
        int32 RechargeMax;

        // Server timestamp in UTC indicating the next time the virtual currency will be incremented.
        FDateTime RechargeTime;

        // Time remaining (in seconds) before the next recharge increment of the virtual currency.
        int32 SecondsToRecharge;

        FVirtualCurrencyRechargeTime() :
            FPlayFabCppBaseModel(),
            RechargeMax(0),
            RechargeTime(0),
            SecondsToRecharge(0)
            {}

        FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
            FPlayFabCppBaseModel(),
            RechargeMax(src.RechargeMax),
            RechargeTime(src.RechargeTime),
            SecondsToRecharge(src.SecondsToRecharge)
            {}

        FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyRechargeTime();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserInfoResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Array of inventory items in the user's current inventory.
        TArray<FItemInstance> Inventory;
        // Boolean indicating whether the user is a developer.
        bool IsDeveloper;

        // [optional] PlayFab unique identifier of the user whose information was requested.
        FString PlayFabId;

        // [optional] Steam unique identifier, if the user has an associated Steam account.
        FString SteamId;

        // [optional] Title specific display name, if set.
        FString TitleDisplayName;

        // [optional] PlayFab unique user name.
        FString Username;

        // [optional] Array of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FUserInfoResponse() :
            FPlayFabCppResultCommon(),
            Inventory(),
            IsDeveloper(false),
            PlayFabId(),
            SteamId(),
            TitleDisplayName(),
            Username(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FUserInfoResponse(const FUserInfoResponse& src) :
            FPlayFabCppResultCommon(),
            Inventory(src.Inventory),
            IsDeveloper(src.IsDeveloper),
            PlayFabId(src.PlayFabId),
            SteamId(src.SteamId),
            TitleDisplayName(src.TitleDisplayName),
            Username(src.Username),
            VirtualCurrency(src.VirtualCurrency),
            VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
            {}

        FUserInfoResponse(const TSharedPtr<FJsonObject>& obj) : FUserInfoResponse()
        {
            readFromValue(obj);
        }

        ~FUserInfoResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
