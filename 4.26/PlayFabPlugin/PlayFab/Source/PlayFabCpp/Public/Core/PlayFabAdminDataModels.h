//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "PlayFabCppBaseModel.h"

namespace PlayFab
{
namespace AdminModels
{

    struct PLAYFABCPP_API FAbortTaskInstanceRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // ID of a task instance that is being aborted.
        FString TaskInstanceId;

        FAbortTaskInstanceRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            TaskInstanceId()
            {}

        FAbortTaskInstanceRequest(const FAbortTaskInstanceRequest& src) = default;

        FAbortTaskInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FAbortTaskInstanceRequest()
        {
            readFromValue(obj);
        }

        ~FAbortTaskInstanceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FActionsOnPlayersInSegmentTaskParameter : public PlayFab::FPlayFabCppBaseModel
    {
        // ID of the action to perform on each player in segment.
        FString ActionId;

        // ID of the segment to perform actions on.
        FString SegmentId;

        FActionsOnPlayersInSegmentTaskParameter() :
            FPlayFabCppBaseModel(),
            ActionId(),
            SegmentId()
            {}

        FActionsOnPlayersInSegmentTaskParameter(const FActionsOnPlayersInSegmentTaskParameter& src) = default;

        FActionsOnPlayersInSegmentTaskParameter(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskParameter()
        {
            readFromValue(obj);
        }

        ~FActionsOnPlayersInSegmentTaskParameter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TaskInstanceStatus
    {
        TaskInstanceStatusSucceeded,
        TaskInstanceStatusStarting,
        TaskInstanceStatusInProgress,
        TaskInstanceStatusFailed,
        TaskInstanceStatusAborted,
        TaskInstanceStatusStalled
    };

    PLAYFABCPP_API void writeTaskInstanceStatusEnumJSON(TaskInstanceStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API TaskInstanceStatus readTaskInstanceStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API TaskInstanceStatus readTaskInstanceStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FNameIdentifier : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Id Identifier, if present
        FString Id;

        // [optional] Name Identifier, if present
        FString Name;

        FNameIdentifier() :
            FPlayFabCppBaseModel(),
            Id(),
            Name()
            {}

        FNameIdentifier(const FNameIdentifier& src) = default;

        FNameIdentifier(const TSharedPtr<FJsonObject>& obj) : FNameIdentifier()
        {
            readFromValue(obj);
        }

        ~FNameIdentifier();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FActionsOnPlayersInSegmentTaskSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] UTC timestamp when the task completed.
        Boxed<FDateTime> CompletedAt;

        // [optional] Error message for last processing attempt, if an error occured.
        FString ErrorMessage;

        // [optional] Flag indicating if the error was fatal, if false job will be retried.
        Boxed<bool> ErrorWasFatal;

        // [optional] Estimated time remaining in seconds.
        Boxed<double> EstimatedSecondsRemaining;

        // [optional] Progress represented as percentage.
        Boxed<double> PercentComplete;

        // [optional] If manually scheduled, ID of user who scheduled the task.
        FString ScheduledByUserId;

        // UTC timestamp when the task started.
        FDateTime StartedAt;

        // [optional] Current status of the task instance.
        Boxed<TaskInstanceStatus> Status;

        // [optional] Identifier of the task this instance belongs to.
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        // [optional] ID of the task instance.
        FString TaskInstanceId;

        // [optional] Total players in segment when task was started.
        Boxed<int32> TotalPlayersInSegment;

        // [optional] Total number of players that have had the actions applied to.
        Boxed<int32> TotalPlayersProcessed;

        FActionsOnPlayersInSegmentTaskSummary() :
            FPlayFabCppBaseModel(),
            CompletedAt(),
            ErrorMessage(),
            ErrorWasFatal(),
            EstimatedSecondsRemaining(),
            PercentComplete(),
            ScheduledByUserId(),
            StartedAt(0),
            Status(),
            TaskIdentifier(nullptr),
            TaskInstanceId(),
            TotalPlayersInSegment(),
            TotalPlayersProcessed()
            {}

        FActionsOnPlayersInSegmentTaskSummary(const FActionsOnPlayersInSegmentTaskSummary& src) = default;

        FActionsOnPlayersInSegmentTaskSummary(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskSummary()
        {
            readFromValue(obj);
        }

        ~FActionsOnPlayersInSegmentTaskSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAdCampaignAttribution : public PlayFab::FPlayFabCppBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttribution() :
            FPlayFabCppBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttribution(const FAdCampaignAttribution& src) = default;

        FAdCampaignAttribution(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttribution()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttribution();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAdCampaignAttributionModel : public PlayFab::FPlayFabCppBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttributionModel() :
            FPlayFabCppBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttributionModel(const FAdCampaignAttributionModel& src) = default;

        FAdCampaignAttributionModel(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttributionModel()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttributionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SegmentFilterComparison
    {
        SegmentFilterComparisonGreaterThan,
        SegmentFilterComparisonLessThan,
        SegmentFilterComparisonEqualTo,
        SegmentFilterComparisonNotEqualTo,
        SegmentFilterComparisonGreaterThanOrEqual,
        SegmentFilterComparisonLessThanOrEqual,
        SegmentFilterComparisonExists,
        SegmentFilterComparisonContains,
        SegmentFilterComparisonNotContains
    };

    PLAYFABCPP_API void writeSegmentFilterComparisonEnumJSON(SegmentFilterComparison enumVal, JsonWriter& writer);
    PLAYFABCPP_API SegmentFilterComparison readSegmentFilterComparisonFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SegmentFilterComparison readSegmentFilterComparisonFromValue(const FString& value);

    struct PLAYFABCPP_API FAdCampaignSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Campaign id.
        FString CampaignId;

        // [optional] Campaign source.
        FString CampaignSource;

        // [optional] Campaign comparison.
        Boxed<SegmentFilterComparison> Comparison;

        FAdCampaignSegmentFilter() :
            FPlayFabCppBaseModel(),
            CampaignId(),
            CampaignSource(),
            Comparison()
            {}

        FAdCampaignSegmentFilter(const FAdCampaignSegmentFilter& src) = default;

        FAdCampaignSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FAdCampaignSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FAdCampaignSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddLocalizedNewsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Localized body text of the news.
        FString Body;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Language of the news item.
        FString Language;

        // Unique id of the updated news item.
        FString NewsId;

        // Localized title (headline) of the news item.
        FString Title;

        FAddLocalizedNewsRequest() :
            FPlayFabCppRequestCommon(),
            Body(),
            CustomTags(),
            Language(),
            NewsId(),
            Title()
            {}

        FAddLocalizedNewsRequest(const FAddLocalizedNewsRequest& src) = default;

        FAddLocalizedNewsRequest(const TSharedPtr<FJsonObject>& obj) : FAddLocalizedNewsRequest()
        {
            readFromValue(obj);
        }

        ~FAddLocalizedNewsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddLocalizedNewsResult : public PlayFab::FPlayFabCppResultCommon
    {
        FAddLocalizedNewsResult() :
            FPlayFabCppResultCommon()
            {}

        FAddLocalizedNewsResult(const FAddLocalizedNewsResult& src) = default;

        FAddLocalizedNewsResult(const TSharedPtr<FJsonObject>& obj) : FAddLocalizedNewsResult()
        {
            readFromValue(obj);
        }

        ~FAddLocalizedNewsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddNewsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Default body text of the news.
        FString Body;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Time this news was published. If not set, defaults to now.
        Boxed<FDateTime> Timestamp;

        // Default title (headline) of the news item.
        FString Title;

        FAddNewsRequest() :
            FPlayFabCppRequestCommon(),
            Body(),
            CustomTags(),
            Timestamp(),
            Title()
            {}

        FAddNewsRequest(const FAddNewsRequest& src) = default;

        FAddNewsRequest(const TSharedPtr<FJsonObject>& obj) : FAddNewsRequest()
        {
            readFromValue(obj);
        }

        ~FAddNewsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddNewsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Unique id of the new news item
        FString NewsId;

        FAddNewsResult() :
            FPlayFabCppResultCommon(),
            NewsId()
            {}

        FAddNewsResult(const FAddNewsResult& src) = default;

        FAddNewsResult(const TSharedPtr<FJsonObject>& obj) : FAddNewsResult()
        {
            readFromValue(obj);
        }

        ~FAddNewsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddPlayerTagRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique tag for player profile.
        FString TagName;

        FAddPlayerTagRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PlayFabId(),
            TagName()
            {}

        FAddPlayerTagRequest(const FAddPlayerTagRequest& src) = default;

        FAddPlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagRequest()
        {
            readFromValue(obj);
        }

        ~FAddPlayerTagRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddPlayerTagResult : public PlayFab::FPlayFabCppResultCommon
    {
        FAddPlayerTagResult() :
            FPlayFabCppResultCommon()
            {}

        FAddPlayerTagResult(const FAddPlayerTagResult& src) = default;

        FAddPlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagResult()
        {
            readFromValue(obj);
        }

        ~FAddPlayerTagResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Region
    {
        RegionUSCentral,
        RegionUSEast,
        RegionEUWest,
        RegionSingapore,
        RegionJapan,
        RegionBrazil,
        RegionAustralia
    };

    PLAYFABCPP_API void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
    PLAYFABCPP_API Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API Region readRegionFromValue(const FString& value);

    struct PLAYFABCPP_API FAddServerBuildRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] server host regions in which this build should be running and available
        TArray<Region> ActiveRegions;
        // unique identifier for the build executable
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        FAddServerBuildRequest() :
            FPlayFabCppRequestCommon(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            CustomTags(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0)
            {}

        FAddServerBuildRequest(const FAddServerBuildRequest& src) = default;

        FAddServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FAddServerBuildRequest()
        {
            readFromValue(obj);
        }

        ~FAddServerBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum GameBuildStatus
    {
        GameBuildStatusAvailable,
        GameBuildStatusValidating,
        GameBuildStatusInvalidBuildPackage,
        GameBuildStatusProcessing,
        GameBuildStatusFailedToProcess
    };

    PLAYFABCPP_API void writeGameBuildStatusEnumJSON(GameBuildStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API GameBuildStatus readGameBuildStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API GameBuildStatus readGameBuildStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FAddServerBuildResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // [optional] unique identifier for this build executable
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] the current status of the build validation and processing steps
        Boxed<GameBuildStatus> Status;

        // time this build was last modified (or uploaded, if this build has never been modified)
        FDateTime Timestamp;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FAddServerBuildResult() :
            FPlayFabCppResultCommon(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Status(),
            Timestamp(0),
            TitleId()
            {}

        FAddServerBuildResult(const FAddServerBuildResult& src) = default;

        FAddServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FAddServerBuildResult()
        {
            readFromValue(obj);
        }

        ~FAddServerBuildResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddUserVirtualCurrencyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * Amount to be added to the user balance of the specified virtual currency. Maximum VC balance is Int32 (2,147,483,647).
         * Any increase over this value will be discarded.
         */
        int32 Amount;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // PlayFab unique identifier of the user whose virtual currency balance is to be increased.
        FString PlayFabId;

        // Name of the virtual currency which is to be incremented.
        FString VirtualCurrency;

        FAddUserVirtualCurrencyRequest() :
            FPlayFabCppRequestCommon(),
            Amount(0),
            CustomTags(),
            PlayFabId(),
            VirtualCurrency()
            {}

        FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) = default;

        FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FAddUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVirtualCurrencyData : public PlayFab::FPlayFabCppBaseModel
    {
        // unique two-character identifier for this currency type (e.g.: "CC")
        FString CurrencyCode;

        // [optional] friendly name to show in the developer portal, reports, etc.
        FString DisplayName;

        // [optional] amount to automatically grant users upon first login to the title
        Boxed<int32> InitialDeposit;

        // [optional] maximum amount to which the currency will recharge (cannot exceed MaxAmount, but can be less)
        Boxed<int32> RechargeMax;

        // [optional] rate at which the currency automatically be added to over time, in units per day (24 hours)
        Boxed<int32> RechargeRate;

        FVirtualCurrencyData() :
            FPlayFabCppBaseModel(),
            CurrencyCode(),
            DisplayName(),
            InitialDeposit(),
            RechargeMax(),
            RechargeRate()
            {}

        FVirtualCurrencyData(const FVirtualCurrencyData& src) = default;

        FVirtualCurrencyData(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyData()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyData();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAddVirtualCurrencyTypesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * List of virtual currencies and their initial deposits (the amount a user is granted when signing in for the first time)
         * to the title
         */
        TArray<FVirtualCurrencyData> VirtualCurrencies;
        FAddVirtualCurrencyTypesRequest() :
            FPlayFabCppRequestCommon(),
            VirtualCurrencies()
            {}

        FAddVirtualCurrencyTypesRequest(const FAddVirtualCurrencyTypesRequest& src) = default;

        FAddVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FAddVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }

        ~FAddVirtualCurrencyTypesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAllPlayersSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        FAllPlayersSegmentFilter() :
            FPlayFabCppBaseModel()
            {}

        FAllPlayersSegmentFilter(const FAllPlayersSegmentFilter& src) = default;

        FAllPlayersSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FAllPlayersSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FAllPlayersSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Conditionals
    {
        ConditionalsAny,
        ConditionalsTrue,
        ConditionalsFalse
    };

    PLAYFABCPP_API void writeConditionalsEnumJSON(Conditionals enumVal, JsonWriter& writer);
    PLAYFABCPP_API Conditionals readConditionalsFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API Conditionals readConditionalsFromValue(const FString& value);

    struct PLAYFABCPP_API FApiCondition : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Require that API calls contain an RSA encrypted payload or signed headers.
        Boxed<Conditionals> HasSignatureOrEncryption;

        FApiCondition() :
            FPlayFabCppBaseModel(),
            HasSignatureOrEncryption()
            {}

        FApiCondition(const FApiCondition& src) = default;

        FApiCondition(const TSharedPtr<FJsonObject>& obj) : FApiCondition()
        {
            readFromValue(obj);
        }

        ~FApiCondition();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum AuthTokenType
    {
        AuthTokenTypeEmail
    };

    PLAYFABCPP_API void writeAuthTokenTypeEnumJSON(AuthTokenType enumVal, JsonWriter& writer);
    PLAYFABCPP_API AuthTokenType readAuthTokenTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AuthTokenType readAuthTokenTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FBanInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // The active state of this ban. Expired bans may still have this value set to true but they will have no effect.
        bool Active;

        // [optional] The unique Ban Id associated with this ban.
        FString BanId;

        // [optional] The time when this ban was applied.
        Boxed<FDateTime> Created;

        // [optional] The time when this ban expires. Permanent bans do not have expiration date.
        Boxed<FDateTime> Expires;

        // [optional] The IP address on which the ban was applied. May affect multiple players.
        FString IPAddress;

        // [optional] The MAC address on which the ban was applied. May affect multiple players.
        FString MACAddress;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The reason why this ban was applied.
        FString Reason;

        FBanInfo() :
            FPlayFabCppBaseModel(),
            Active(false),
            BanId(),
            Created(),
            Expires(),
            IPAddress(),
            MACAddress(),
            PlayFabId(),
            Reason()
            {}

        FBanInfo(const FBanInfo& src) = default;

        FBanInfo(const TSharedPtr<FJsonObject>& obj) : FBanInfo()
        {
            readFromValue(obj);
        }

        ~FBanInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBanPlayerSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Ban hours duration.
        Boxed<uint32> BanHours;

        // [optional] Reason for ban.
        FString ReasonForBan;

        FBanPlayerSegmentAction() :
            FPlayFabCppBaseModel(),
            BanHours(),
            ReasonForBan()
            {}

        FBanPlayerSegmentAction(const FBanPlayerSegmentAction& src) = default;

        FBanPlayerSegmentAction(const TSharedPtr<FJsonObject>& obj) : FBanPlayerSegmentAction()
        {
            readFromValue(obj);
        }

        ~FBanPlayerSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBanRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The duration in hours for the ban. Leave this blank for a permanent ban.
        Boxed<uint32> DurationInHours;

        // [optional] IP address to be banned. May affect multiple players.
        FString IPAddress;

        // [optional] MAC address to be banned. May affect multiple players.
        FString MACAddress;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The reason for this ban. Maximum 140 characters.
        FString Reason;

        FBanRequest() :
            FPlayFabCppBaseModel(),
            DurationInHours(),
            IPAddress(),
            MACAddress(),
            PlayFabId(),
            Reason()
            {}

        FBanRequest(const FBanRequest& src) = default;

        FBanRequest(const TSharedPtr<FJsonObject>& obj) : FBanRequest()
        {
            readFromValue(obj);
        }

        ~FBanRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBanUsersRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // List of ban requests to be applied. Maximum 100.
        TArray<FBanRequest> Bans;
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FBanUsersRequest() :
            FPlayFabCppRequestCommon(),
            Bans(),
            CustomTags()
            {}

        FBanUsersRequest(const FBanUsersRequest& src) = default;

        FBanUsersRequest(const TSharedPtr<FJsonObject>& obj) : FBanUsersRequest()
        {
            readFromValue(obj);
        }

        ~FBanUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBanUsersResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Information on the bans that were applied
        TArray<FBanInfo> BanData;
        FBanUsersResult() :
            FPlayFabCppResultCommon(),
            BanData()
            {}

        FBanUsersResult(const FBanUsersResult& src) = default;

        FBanUsersResult(const TSharedPtr<FJsonObject>& obj) : FBanUsersResult()
        {
            readFromValue(obj);
        }

        ~FBanUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBlankResult : public PlayFab::FPlayFabCppResultCommon
    {
        FBlankResult() :
            FPlayFabCppResultCommon()
            {}

        FBlankResult(const FBlankResult& src) = default;

        FBlankResult(const TSharedPtr<FJsonObject>& obj) : FBlankResult()
        {
            readFromValue(obj);
        }

        ~FBlankResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCatalogItemBundleInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
        TArray<FString> BundledItems;
        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and
         * add the relevant items to the player inventory when the bundle is added)
         */
        TArray<FString> BundledResultTables;
        // [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
        TMap<FString, uint32> BundledVirtualCurrencies;
        FCatalogItemBundleInfo() :
            FPlayFabCppBaseModel(),
            BundledItems(),
            BundledResultTables(),
            BundledVirtualCurrencies()
            {}

        FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) = default;

        FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemBundleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCatalogItemConsumableInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] number of times this object can be used, after which it will be removed from the player inventory
        Boxed<uint32> UsageCount;

        /**
         * [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed
         * (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on
         * this item's details have completed)
         */
        Boxed<uint32> UsagePeriod;

        /**
         * [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values
         * added together, and share the result - when that period has elapsed, all the items in the group will be removed
         */
        FString UsagePeriodGroup;

        FCatalogItemConsumableInfo() :
            FPlayFabCppBaseModel(),
            UsageCount(),
            UsagePeriod(),
            UsagePeriodGroup()
            {}

        FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) = default;

        FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemConsumableInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCatalogItemContainerInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
        TArray<FString> ItemContents;
        /**
         * [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will
         * open the container, adding the contents to the player inventory and currency balances)
         */
        FString KeyItemId;

        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables
         * will be resolved and add the relevant items to the player inventory)
         */
        TArray<FString> ResultTableContents;
        // [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
        TMap<FString, uint32> VirtualCurrencyContents;
        FCatalogItemContainerInfo() :
            FPlayFabCppBaseModel(),
            ItemContents(),
            KeyItemId(),
            ResultTableContents(),
            VirtualCurrencyContents()
            {}

        FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) = default;

        FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemContainerInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCatalogItem : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables
         * and virtual currencies
         */
        TSharedPtr<FCatalogItemBundleInfo> Bundle;

        // if true, then an item instance of this type can be used to grant a character to a user.
        bool CanBecomeCharacter;

        // [optional] catalog version for this item
        FString CatalogVersion;

        // [optional] defines the consumable properties (number of uses, timeout) for the item
        TSharedPtr<FCatalogItemConsumableInfo> Consumable;

        /**
         * [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual
         * currencies, and what item (if any) is required to open it via the UnlockContainerItem API
         */
        TSharedPtr<FCatalogItemContainerInfo> Container;

        // [optional] game specific custom data
        FString CustomData;

        // [optional] text description of item, to show in-game
        FString Description;

        // [optional] text name for the item, to show in-game
        FString DisplayName;

        /**
         * If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited
         * edition item, this value determines the total number of instances to allocate for the title. Once this limit has been
         * reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of
         * false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less
         * than zero, it will be ignored.
         */
        int32 InitialLimitedEditionCount;

        // BETA: If true, then only a fixed number can ever be granted.
        bool IsLimitedEdition;

        /**
         * if true, then only one item instance of this type will exist and its remaininguses will be incremented instead.
         * RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
         */
        bool IsStackable;

        // if true, then an item instance of this type can be traded between players using the trading APIs
        bool IsTradable;

        // [optional] class to which the item belongs
        FString ItemClass;

        // unique identifier for this item
        FString ItemId;

        /**
         * [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP
         * URL.
         */
        FString ItemImageUrl;

        // [optional] override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] list of item tags
        TArray<FString> Tags;
        // [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FCatalogItem() :
            FPlayFabCppBaseModel(),
            Bundle(nullptr),
            CanBecomeCharacter(false),
            CatalogVersion(),
            Consumable(nullptr),
            Container(nullptr),
            CustomData(),
            Description(),
            DisplayName(),
            InitialLimitedEditionCount(0),
            IsLimitedEdition(false),
            IsStackable(false),
            IsTradable(false),
            ItemClass(),
            ItemId(),
            ItemImageUrl(),
            RealCurrencyPrices(),
            Tags(),
            VirtualCurrencyPrices()
            {}

        FCatalogItem(const FCatalogItem& src) = default;

        FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }

        ~FCatalogItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCheckLimitedEditionItemAvailabilityRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Which catalog is being updated. If null, uses the default catalog.
        FString CatalogVersion;

        // The item to check for.
        FString ItemId;

        FCheckLimitedEditionItemAvailabilityRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion(),
            ItemId()
            {}

        FCheckLimitedEditionItemAvailabilityRequest(const FCheckLimitedEditionItemAvailabilityRequest& src) = default;

        FCheckLimitedEditionItemAvailabilityRequest(const TSharedPtr<FJsonObject>& obj) : FCheckLimitedEditionItemAvailabilityRequest()
        {
            readFromValue(obj);
        }

        ~FCheckLimitedEditionItemAvailabilityRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCheckLimitedEditionItemAvailabilityResult : public PlayFab::FPlayFabCppResultCommon
    {
        // The amount of the specified resource remaining.
        int32 Amount;

        FCheckLimitedEditionItemAvailabilityResult() :
            FPlayFabCppResultCommon(),
            Amount(0)
            {}

        FCheckLimitedEditionItemAvailabilityResult(const FCheckLimitedEditionItemAvailabilityResult& src) = default;

        FCheckLimitedEditionItemAvailabilityResult(const TSharedPtr<FJsonObject>& obj) : FCheckLimitedEditionItemAvailabilityResult()
        {
            readFromValue(obj);
        }

        ~FCheckLimitedEditionItemAvailabilityResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCloudScriptFile : public PlayFab::FPlayFabCppBaseModel
    {
        // Contents of the Cloud Script javascript. Must be string-escaped javascript.
        FString FileContents;

        /**
         * Name of the javascript file. These names are not used internally by the server, they are only for developer
         * organizational purposes.
         */
        FString Filename;

        FCloudScriptFile() :
            FPlayFabCppBaseModel(),
            FileContents(),
            Filename()
            {}

        FCloudScriptFile(const FCloudScriptFile& src) = default;

        FCloudScriptFile(const TSharedPtr<FJsonObject>& obj) : FCloudScriptFile()
        {
            readFromValue(obj);
        }

        ~FCloudScriptFile();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCloudScriptTaskParameter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Argument to pass to the CloudScript function.
        FJsonKeeper Argument;

        // [optional] Name of the CloudScript function to execute.
        FString FunctionName;

        FCloudScriptTaskParameter() :
            FPlayFabCppBaseModel(),
            Argument(),
            FunctionName()
            {}

        FCloudScriptTaskParameter(const FCloudScriptTaskParameter& src) = default;

        FCloudScriptTaskParameter(const TSharedPtr<FJsonObject>& obj) : FCloudScriptTaskParameter()
        {
            readFromValue(obj);
        }

        ~FCloudScriptTaskParameter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FScriptExecutionError : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded,
         * CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
         */
        FString Error;

        // [optional] Details about the error
        FString Message;

        // [optional] Point during the execution of the script at which the error occurred, if any
        FString StackTrace;

        FScriptExecutionError() :
            FPlayFabCppBaseModel(),
            Error(),
            Message(),
            StackTrace()
            {}

        FScriptExecutionError(const FScriptExecutionError& src) = default;

        FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }

        ~FScriptExecutionError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLogStatement : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Optional object accompanying the message as contextual information
        FJsonKeeper Data;

        // [optional] 'Debug', 'Info', or 'Error'
        FString Level;

        // [optional] undefined
        FString Message;

        FLogStatement() :
            FPlayFabCppBaseModel(),
            Data(),
            Level(),
            Message()
            {}

        FLogStatement(const FLogStatement& src) = default;

        FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }

        ~FLogStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FExecuteCloudScriptResult : public PlayFab::FPlayFabCppBaseModel
    {
        // Number of PlayFab API requests issued by the CloudScript function
        int32 APIRequestsIssued;

        // [optional] Information about the error, if any, that occurred during execution
        TSharedPtr<FScriptExecutionError> Error;

        double ExecutionTimeSeconds;

        // [optional] The name of the function that executed
        FString FunctionName;

        // [optional] The object returned from the CloudScript function, if any
        FJsonKeeper FunctionResult;

        /**
         * [optional] Flag indicating if the FunctionResult was too large and was subsequently dropped from this event. This only occurs if
         * the total event size is larger than 350KB.
         */
        Boxed<bool> FunctionResultTooLarge;

        // Number of external HTTP requests issued by the CloudScript function
        int32 HttpRequestsIssued;

        /**
         * [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info()
         * and log.error() and error entries for API and HTTP request failures.
         */
        TArray<FLogStatement> Logs;
        /**
         * [optional] Flag indicating if the logs were too large and were subsequently dropped from this event. This only occurs if the total
         * event size is larger than 350KB after the FunctionResult was removed.
         */
        Boxed<bool> LogsTooLarge;

        uint32 MemoryConsumedBytes;

        /**
         * Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP
         * requests.
         */
        double ProcessorTimeSeconds;

        // The revision of the CloudScript that executed
        int32 Revision;

        FExecuteCloudScriptResult() :
            FPlayFabCppBaseModel(),
            APIRequestsIssued(0),
            Error(nullptr),
            ExecutionTimeSeconds(0),
            FunctionName(),
            FunctionResult(),
            FunctionResultTooLarge(),
            HttpRequestsIssued(0),
            Logs(),
            LogsTooLarge(),
            MemoryConsumedBytes(0),
            ProcessorTimeSeconds(0),
            Revision(0)
            {}

        FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) = default;

        FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCloudScriptTaskSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] UTC timestamp when the task completed.
        Boxed<FDateTime> CompletedAt;

        // [optional] Estimated time remaining in seconds.
        Boxed<double> EstimatedSecondsRemaining;

        // [optional] Progress represented as percentage.
        Boxed<double> PercentComplete;

        // [optional] Result of CloudScript execution
        TSharedPtr<FExecuteCloudScriptResult> Result;

        // [optional] If manually scheduled, ID of user who scheduled the task.
        FString ScheduledByUserId;

        // UTC timestamp when the task started.
        FDateTime StartedAt;

        // [optional] Current status of the task instance.
        Boxed<TaskInstanceStatus> Status;

        // [optional] Identifier of the task this instance belongs to.
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        // [optional] ID of the task instance.
        FString TaskInstanceId;

        FCloudScriptTaskSummary() :
            FPlayFabCppBaseModel(),
            CompletedAt(),
            EstimatedSecondsRemaining(),
            PercentComplete(),
            Result(nullptr),
            ScheduledByUserId(),
            StartedAt(0),
            Status(),
            TaskIdentifier(nullptr),
            TaskInstanceId()
            {}

        FCloudScriptTaskSummary(const FCloudScriptTaskSummary& src) = default;

        FCloudScriptTaskSummary(const TSharedPtr<FJsonObject>& obj) : FCloudScriptTaskSummary()
        {
            readFromValue(obj);
        }

        ~FCloudScriptTaskSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCloudScriptVersionStatus : public PlayFab::FPlayFabCppBaseModel
    {
        // Most recent revision for this Cloud Script version
        int32 LatestRevision;

        // Published code revision for this Cloud Script version
        int32 PublishedRevision;

        // Version number
        int32 Version;

        FCloudScriptVersionStatus() :
            FPlayFabCppBaseModel(),
            LatestRevision(0),
            PublishedRevision(0),
            Version(0)
            {}

        FCloudScriptVersionStatus(const FCloudScriptVersionStatus& src) = default;

        FCloudScriptVersionStatus(const TSharedPtr<FJsonObject>& obj) : FCloudScriptVersionStatus()
        {
            readFromValue(obj);
        }

        ~FCloudScriptVersionStatus();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EmailVerificationStatus
    {
        EmailVerificationStatusUnverified,
        EmailVerificationStatusPending,
        EmailVerificationStatusConfirmed
    };

    PLAYFABCPP_API void writeEmailVerificationStatusEnumJSON(EmailVerificationStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API EmailVerificationStatus readEmailVerificationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API EmailVerificationStatus readEmailVerificationStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FContactEmailInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfo() :
            FPlayFabCppBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfo(const FContactEmailInfo& src) = default;

        FContactEmailInfo(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfo()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FContactEmailInfoModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfoModel() :
            FPlayFabCppBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfoModel(const FContactEmailInfoModel& src) = default;

        FContactEmailInfoModel(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfoModel()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfoModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FContentInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Key of the content
        FString Key;

        // Last modified time
        FDateTime LastModified;

        // Size of the content in bytes
        double Size;

        FContentInfo() :
            FPlayFabCppBaseModel(),
            Key(),
            LastModified(0),
            Size(0)
            {}

        FContentInfo(const FContentInfo& src) = default;

        FContentInfo(const TSharedPtr<FJsonObject>& obj) : FContentInfo()
        {
            readFromValue(obj);
        }

        ~FContentInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ContinentCode
    {
        ContinentCodeAF,
        ContinentCodeAN,
        ContinentCodeAS,
        ContinentCodeEU,
        ContinentCodeNA,
        ContinentCodeOC,
        ContinentCodeSA
    };

    PLAYFABCPP_API void writeContinentCodeEnumJSON(ContinentCode enumVal, JsonWriter& writer);
    PLAYFABCPP_API ContinentCode readContinentCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ContinentCode readContinentCodeFromValue(const FString& value);

    enum CountryCode
    {
        CountryCodeAF,
        CountryCodeAX,
        CountryCodeAL,
        CountryCodeDZ,
        CountryCodeAS,
        CountryCodeAD,
        CountryCodeAO,
        CountryCodeAI,
        CountryCodeAQ,
        CountryCodeAG,
        CountryCodeAR,
        CountryCodeAM,
        CountryCodeAW,
        CountryCodeAU,
        CountryCodeAT,
        CountryCodeAZ,
        CountryCodeBS,
        CountryCodeBH,
        CountryCodeBD,
        CountryCodeBB,
        CountryCodeBY,
        CountryCodeBE,
        CountryCodeBZ,
        CountryCodeBJ,
        CountryCodeBM,
        CountryCodeBT,
        CountryCodeBO,
        CountryCodeBQ,
        CountryCodeBA,
        CountryCodeBW,
        CountryCodeBV,
        CountryCodeBR,
        CountryCodeIO,
        CountryCodeBN,
        CountryCodeBG,
        CountryCodeBF,
        CountryCodeBI,
        CountryCodeKH,
        CountryCodeCM,
        CountryCodeCA,
        CountryCodeCV,
        CountryCodeKY,
        CountryCodeCF,
        CountryCodeTD,
        CountryCodeCL,
        CountryCodeCN,
        CountryCodeCX,
        CountryCodeCC,
        CountryCodeCO,
        CountryCodeKM,
        CountryCodeCG,
        CountryCodeCD,
        CountryCodeCK,
        CountryCodeCR,
        CountryCodeCI,
        CountryCodeHR,
        CountryCodeCU,
        CountryCodeCW,
        CountryCodeCY,
        CountryCodeCZ,
        CountryCodeDK,
        CountryCodeDJ,
        CountryCodeDM,
        CountryCodeDO,
        CountryCodeEC,
        CountryCodeEG,
        CountryCodeSV,
        CountryCodeGQ,
        CountryCodeER,
        CountryCodeEE,
        CountryCodeET,
        CountryCodeFK,
        CountryCodeFO,
        CountryCodeFJ,
        CountryCodeFI,
        CountryCodeFR,
        CountryCodeGF,
        CountryCodePF,
        CountryCodeTF,
        CountryCodeGA,
        CountryCodeGM,
        CountryCodeGE,
        CountryCodeDE,
        CountryCodeGH,
        CountryCodeGI,
        CountryCodeGR,
        CountryCodeGL,
        CountryCodeGD,
        CountryCodeGP,
        CountryCodeGU,
        CountryCodeGT,
        CountryCodeGG,
        CountryCodeGN,
        CountryCodeGW,
        CountryCodeGY,
        CountryCodeHT,
        CountryCodeHM,
        CountryCodeVA,
        CountryCodeHN,
        CountryCodeHK,
        CountryCodeHU,
        CountryCodeIS,
        CountryCodeIN,
        CountryCodeID,
        CountryCodeIR,
        CountryCodeIQ,
        CountryCodeIE,
        CountryCodeIM,
        CountryCodeIL,
        CountryCodeIT,
        CountryCodeJM,
        CountryCodeJP,
        CountryCodeJE,
        CountryCodeJO,
        CountryCodeKZ,
        CountryCodeKE,
        CountryCodeKI,
        CountryCodeKP,
        CountryCodeKR,
        CountryCodeKW,
        CountryCodeKG,
        CountryCodeLA,
        CountryCodeLV,
        CountryCodeLB,
        CountryCodeLS,
        CountryCodeLR,
        CountryCodeLY,
        CountryCodeLI,
        CountryCodeLT,
        CountryCodeLU,
        CountryCodeMO,
        CountryCodeMK,
        CountryCodeMG,
        CountryCodeMW,
        CountryCodeMY,
        CountryCodeMV,
        CountryCodeML,
        CountryCodeMT,
        CountryCodeMH,
        CountryCodeMQ,
        CountryCodeMR,
        CountryCodeMU,
        CountryCodeYT,
        CountryCodeMX,
        CountryCodeFM,
        CountryCodeMD,
        CountryCodeMC,
        CountryCodeMN,
        CountryCodeME,
        CountryCodeMS,
        CountryCodeMA,
        CountryCodeMZ,
        CountryCodeMM,
        CountryCodeNA,
        CountryCodeNR,
        CountryCodeNP,
        CountryCodeNL,
        CountryCodeNC,
        CountryCodeNZ,
        CountryCodeNI,
        CountryCodeNE,
        CountryCodeNG,
        CountryCodeNU,
        CountryCodeNF,
        CountryCodeMP,
        CountryCodeNO,
        CountryCodeOM,
        CountryCodePK,
        CountryCodePW,
        CountryCodePS,
        CountryCodePA,
        CountryCodePG,
        CountryCodePY,
        CountryCodePE,
        CountryCodePH,
        CountryCodePN,
        CountryCodePL,
        CountryCodePT,
        CountryCodePR,
        CountryCodeQA,
        CountryCodeRE,
        CountryCodeRO,
        CountryCodeRU,
        CountryCodeRW,
        CountryCodeBL,
        CountryCodeSH,
        CountryCodeKN,
        CountryCodeLC,
        CountryCodeMF,
        CountryCodePM,
        CountryCodeVC,
        CountryCodeWS,
        CountryCodeSM,
        CountryCodeST,
        CountryCodeSA,
        CountryCodeSN,
        CountryCodeRS,
        CountryCodeSC,
        CountryCodeSL,
        CountryCodeSG,
        CountryCodeSX,
        CountryCodeSK,
        CountryCodeSI,
        CountryCodeSB,
        CountryCodeSO,
        CountryCodeZA,
        CountryCodeGS,
        CountryCodeSS,
        CountryCodeES,
        CountryCodeLK,
        CountryCodeSD,
        CountryCodeSR,
        CountryCodeSJ,
        CountryCodeSZ,
        CountryCodeSE,
        CountryCodeCH,
        CountryCodeSY,
        CountryCodeTW,
        CountryCodeTJ,
        CountryCodeTZ,
        CountryCodeTH,
        CountryCodeTL,
        CountryCodeTG,
        CountryCodeTK,
        CountryCodeTO,
        CountryCodeTT,
        CountryCodeTN,
        CountryCodeTR,
        CountryCodeTM,
        CountryCodeTC,
        CountryCodeTV,
        CountryCodeUG,
        CountryCodeUA,
        CountryCodeAE,
        CountryCodeGB,
        CountryCodeUS,
        CountryCodeUM,
        CountryCodeUY,
        CountryCodeUZ,
        CountryCodeVU,
        CountryCodeVE,
        CountryCodeVN,
        CountryCodeVG,
        CountryCodeVI,
        CountryCodeWF,
        CountryCodeEH,
        CountryCodeYE,
        CountryCodeZM,
        CountryCodeZW
    };

    PLAYFABCPP_API void writeCountryCodeEnumJSON(CountryCode enumVal, JsonWriter& writer);
    PLAYFABCPP_API CountryCode readCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API CountryCode readCountryCodeFromValue(const FString& value);

    struct PLAYFABCPP_API FCreateActionsOnPlayerSegmentTaskRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // Task details related to segment and action
        FActionsOnPlayersInSegmentTaskParameter Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        FCreateActionsOnPlayerSegmentTaskRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Description(),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule()
            {}

        FCreateActionsOnPlayerSegmentTaskRequest(const FCreateActionsOnPlayerSegmentTaskRequest& src) = default;

        FCreateActionsOnPlayerSegmentTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateActionsOnPlayerSegmentTaskRequest()
        {
            readFromValue(obj);
        }

        ~FCreateActionsOnPlayerSegmentTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateCloudScriptTaskRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // Task details related to CloudScript
        FCloudScriptTaskParameter Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        FCreateCloudScriptTaskRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Description(),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule()
            {}

        FCreateCloudScriptTaskRequest(const FCreateCloudScriptTaskRequest& src) = default;

        FCreateCloudScriptTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateCloudScriptTaskRequest()
        {
            readFromValue(obj);
        }

        ~FCreateCloudScriptTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FInsightsScalingTaskParameter : public PlayFab::FPlayFabCppBaseModel
    {
        // Insights Performance Level to scale to.
        int32 Level;

        FInsightsScalingTaskParameter() :
            FPlayFabCppBaseModel(),
            Level(0)
            {}

        FInsightsScalingTaskParameter(const FInsightsScalingTaskParameter& src) = default;

        FInsightsScalingTaskParameter(const TSharedPtr<FJsonObject>& obj) : FInsightsScalingTaskParameter()
        {
            readFromValue(obj);
        }

        ~FInsightsScalingTaskParameter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateInsightsScheduledScalingTaskRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // Task details related to Insights Scaling
        FInsightsScalingTaskParameter Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        FCreateInsightsScheduledScalingTaskRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Description(),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule()
            {}

        FCreateInsightsScheduledScalingTaskRequest(const FCreateInsightsScheduledScalingTaskRequest& src) = default;

        FCreateInsightsScheduledScalingTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateInsightsScheduledScalingTaskRequest()
        {
            readFromValue(obj);
        }

        ~FCreateInsightsScheduledScalingTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FOpenIdIssuerInformation : public PlayFab::FPlayFabCppBaseModel
    {
        // Authorization endpoint URL to direct users to for signin.
        FString AuthorizationUrl;

        // The URL of the issuer of the tokens. This must match the exact URL of the issuer field in tokens.
        FString Issuer;

        // JSON Web Key Set for validating the signature of tokens.
        FJsonKeeper JsonWebKeySet;

        // Token endpoint URL for code verification.
        FString TokenUrl;

        FOpenIdIssuerInformation() :
            FPlayFabCppBaseModel(),
            AuthorizationUrl(),
            Issuer(),
            JsonWebKeySet(),
            TokenUrl()
            {}

        FOpenIdIssuerInformation(const FOpenIdIssuerInformation& src) = default;

        FOpenIdIssuerInformation(const TSharedPtr<FJsonObject>& obj) : FOpenIdIssuerInformation()
        {
            readFromValue(obj);
        }

        ~FOpenIdIssuerInformation();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateOpenIdConnectionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The client ID given by the ID provider.
        FString ClientId;

        // The client secret given by the ID provider.
        FString ClientSecret;

        // A name for the connection that identifies it within the title.
        FString ConnectionId;

        // [optional] Ignore 'nonce' claim in identity tokens.
        Boxed<bool> IgnoreNonce;

        /**
         * [optional] The discovery document URL to read issuer information from. This must be the absolute URL to the JSON OpenId
         * Configuration document and must be accessible from the internet. If you don't know it, try your issuer URL followed by
         * "/.well-known/openid-configuration". For example, if the issuer is https://example.com, try
         * https://example.com/.well-known/openid-configuration
         */
        FString IssuerDiscoveryUrl;

        // [optional] Manually specified information for an OpenID Connect issuer.
        TSharedPtr<FOpenIdIssuerInformation> IssuerInformation;

        FCreateOpenIdConnectionRequest() :
            FPlayFabCppRequestCommon(),
            ClientId(),
            ClientSecret(),
            ConnectionId(),
            IgnoreNonce(),
            IssuerDiscoveryUrl(),
            IssuerInformation(nullptr)
            {}

        FCreateOpenIdConnectionRequest(const FCreateOpenIdConnectionRequest& src) = default;

        FCreateOpenIdConnectionRequest(const TSharedPtr<FJsonObject>& obj) : FCreateOpenIdConnectionRequest()
        {
            readFromValue(obj);
        }

        ~FCreateOpenIdConnectionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreatePlayerSharedSecretRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Friendly name for this key
        FString FriendlyName;

        FCreatePlayerSharedSecretRequest() :
            FPlayFabCppRequestCommon(),
            FriendlyName()
            {}

        FCreatePlayerSharedSecretRequest(const FCreatePlayerSharedSecretRequest& src) = default;

        FCreatePlayerSharedSecretRequest(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerSharedSecretRequest()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerSharedSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreatePlayerSharedSecretResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The player shared secret to use when calling Client/GetTitlePublicKey
        FString SecretKey;

        FCreatePlayerSharedSecretResult() :
            FPlayFabCppResultCommon(),
            SecretKey()
            {}

        FCreatePlayerSharedSecretResult(const FCreatePlayerSharedSecretResult& src) = default;

        FCreatePlayerSharedSecretResult(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerSharedSecretResult()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerSharedSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum StatisticAggregationMethod
    {
        StatisticAggregationMethodLast,
        StatisticAggregationMethodMin,
        StatisticAggregationMethodMax,
        StatisticAggregationMethodSum
    };

    PLAYFABCPP_API void writeStatisticAggregationMethodEnumJSON(StatisticAggregationMethod enumVal, JsonWriter& writer);
    PLAYFABCPP_API StatisticAggregationMethod readStatisticAggregationMethodFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API StatisticAggregationMethod readStatisticAggregationMethodFromValue(const FString& value);

    enum StatisticResetIntervalOption
    {
        StatisticResetIntervalOptionNever,
        StatisticResetIntervalOptionHour,
        StatisticResetIntervalOptionDay,
        StatisticResetIntervalOptionWeek,
        StatisticResetIntervalOptionMonth
    };

    PLAYFABCPP_API void writeStatisticResetIntervalOptionEnumJSON(StatisticResetIntervalOption enumVal, JsonWriter& writer);
    PLAYFABCPP_API StatisticResetIntervalOption readStatisticResetIntervalOptionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API StatisticResetIntervalOption readStatisticResetIntervalOptionFromValue(const FString& value);

    struct PLAYFABCPP_API FCreatePlayerStatisticDefinitionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] the aggregation method to use in updating the statistic (defaults to last)
        Boxed<StatisticAggregationMethod> AggregationMethod;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // unique name of the statistic
        FString StatisticName;

        // [optional] interval at which the values of the statistic for all players are reset (resets begin at the next interval boundary)
        Boxed<StatisticResetIntervalOption> VersionChangeInterval;

        FCreatePlayerStatisticDefinitionRequest() :
            FPlayFabCppRequestCommon(),
            AggregationMethod(),
            CustomTags(),
            StatisticName(),
            VersionChangeInterval()
            {}

        FCreatePlayerStatisticDefinitionRequest(const FCreatePlayerStatisticDefinitionRequest& src) = default;

        FCreatePlayerStatisticDefinitionRequest(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerStatisticDefinitionRequest()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerStatisticDefinitionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerStatisticDefinition : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] the aggregation method to use in updating the statistic (defaults to last)
        Boxed<StatisticAggregationMethod> AggregationMethod;

        // current active version of the statistic, incremented each time the statistic resets
        uint32 CurrentVersion;

        // [optional] unique name of the statistic
        FString StatisticName;

        // [optional] interval at which the values of the statistic for all players are reset automatically
        Boxed<StatisticResetIntervalOption> VersionChangeInterval;

        FPlayerStatisticDefinition() :
            FPlayFabCppBaseModel(),
            AggregationMethod(),
            CurrentVersion(0),
            StatisticName(),
            VersionChangeInterval()
            {}

        FPlayerStatisticDefinition(const FPlayerStatisticDefinition& src) = default;

        FPlayerStatisticDefinition(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticDefinition()
        {
            readFromValue(obj);
        }

        ~FPlayerStatisticDefinition();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreatePlayerStatisticDefinitionResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] created statistic definition
        TSharedPtr<FPlayerStatisticDefinition> Statistic;

        FCreatePlayerStatisticDefinitionResult() :
            FPlayFabCppResultCommon(),
            Statistic(nullptr)
            {}

        FCreatePlayerStatisticDefinitionResult(const FCreatePlayerStatisticDefinitionResult& src) = default;

        FCreatePlayerStatisticDefinitionResult(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerStatisticDefinitionResult()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerStatisticDefinitionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeletePlayerSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        FDeletePlayerSegmentAction() :
            FPlayFabCppBaseModel()
            {}

        FDeletePlayerSegmentAction(const FDeletePlayerSegmentAction& src) = default;

        FDeletePlayerSegmentAction(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerSegmentAction()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeletePlayerStatisticSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Statistic name.
        FString StatisticName;

        FDeletePlayerStatisticSegmentAction() :
            FPlayFabCppBaseModel(),
            StatisticName()
            {}

        FDeletePlayerStatisticSegmentAction(const FDeletePlayerStatisticSegmentAction& src) = default;

        FDeletePlayerStatisticSegmentAction(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerStatisticSegmentAction()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerStatisticSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FEmailNotificationSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Email template id.
        FString EmailTemplateId;

        // [optional] Email template name.
        FString EmailTemplateName;

        FEmailNotificationSegmentAction() :
            FPlayFabCppBaseModel(),
            EmailTemplateId(),
            EmailTemplateName()
            {}

        FEmailNotificationSegmentAction(const FEmailNotificationSegmentAction& src) = default;

        FEmailNotificationSegmentAction(const TSharedPtr<FJsonObject>& obj) : FEmailNotificationSegmentAction()
        {
            readFromValue(obj);
        }

        ~FEmailNotificationSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FExecuteAzureFunctionSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Azure function.
        FString AzureFunction;

        // [optional] Azure function parameter.
        FJsonKeeper FunctionParameter;

        // Generate play stream event.
        bool GenerateFunctionExecutedEvents;

        FExecuteAzureFunctionSegmentAction() :
            FPlayFabCppBaseModel(),
            AzureFunction(),
            FunctionParameter(),
            GenerateFunctionExecutedEvents(false)
            {}

        FExecuteAzureFunctionSegmentAction(const FExecuteAzureFunctionSegmentAction& src) = default;

        FExecuteAzureFunctionSegmentAction(const TSharedPtr<FJsonObject>& obj) : FExecuteAzureFunctionSegmentAction()
        {
            readFromValue(obj);
        }

        ~FExecuteAzureFunctionSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FExecuteCloudScriptSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Cloud script function.
        FString CloudScriptFunction;

        // Generate play stream event.
        bool CloudScriptPublishResultsToPlayStream;

        // [optional] Cloud script function parameter.
        FJsonKeeper FunctionParameter;

        // [optional] Cloud script function parameter json text.
        FString FunctionParameterJson;

        FExecuteCloudScriptSegmentAction() :
            FPlayFabCppBaseModel(),
            CloudScriptFunction(),
            CloudScriptPublishResultsToPlayStream(false),
            FunctionParameter(),
            FunctionParameterJson()
            {}

        FExecuteCloudScriptSegmentAction(const FExecuteCloudScriptSegmentAction& src) = default;

        FExecuteCloudScriptSegmentAction(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptSegmentAction()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGrantItemSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Item catalog id.
        FString CatelogId;

        // [optional] Item id.
        FString ItemId;

        // Item quantity.
        uint32 Quantity;

        FGrantItemSegmentAction() :
            FPlayFabCppBaseModel(),
            CatelogId(),
            ItemId(),
            Quantity(0)
            {}

        FGrantItemSegmentAction(const FGrantItemSegmentAction& src) = default;

        FGrantItemSegmentAction(const TSharedPtr<FJsonObject>& obj) : FGrantItemSegmentAction()
        {
            readFromValue(obj);
        }

        ~FGrantItemSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGrantVirtualCurrencySegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // Virtual currency amount.
        int32 Amount;

        // [optional] Virtual currency code.
        FString CurrencyCode;

        FGrantVirtualCurrencySegmentAction() :
            FPlayFabCppBaseModel(),
            Amount(0),
            CurrencyCode()
            {}

        FGrantVirtualCurrencySegmentAction(const FGrantVirtualCurrencySegmentAction& src) = default;

        FGrantVirtualCurrencySegmentAction(const TSharedPtr<FJsonObject>& obj) : FGrantVirtualCurrencySegmentAction()
        {
            readFromValue(obj);
        }

        ~FGrantVirtualCurrencySegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FIncrementPlayerStatisticSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // Increment value.
        int32 IncrementValue;

        // [optional] Statistic name.
        FString StatisticName;

        FIncrementPlayerStatisticSegmentAction() :
            FPlayFabCppBaseModel(),
            IncrementValue(0),
            StatisticName()
            {}

        FIncrementPlayerStatisticSegmentAction(const FIncrementPlayerStatisticSegmentAction& src) = default;

        FIncrementPlayerStatisticSegmentAction(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticSegmentAction()
        {
            readFromValue(obj);
        }

        ~FIncrementPlayerStatisticSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPushNotificationSegmentAction : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Push notification template id.
        FString PushNotificationTemplateId;

        FPushNotificationSegmentAction() :
            FPlayFabCppBaseModel(),
            PushNotificationTemplateId()
            {}

        FPushNotificationSegmentAction(const FPushNotificationSegmentAction& src) = default;

        FPushNotificationSegmentAction(const TSharedPtr<FJsonObject>& obj) : FPushNotificationSegmentAction()
        {
            readFromValue(obj);
        }

        ~FPushNotificationSegmentAction();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSegmentTrigger : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Ban player segment trigger action.
        TSharedPtr<FBanPlayerSegmentAction> BanPlayerAction;

        // [optional] Delete player segment trigger action.
        TSharedPtr<FDeletePlayerSegmentAction> DeletePlayerAction;

        // [optional] Delete player statistic segment trigger action.
        TSharedPtr<FDeletePlayerStatisticSegmentAction> DeletePlayerStatisticAction;

        // [optional] Email notification segment trigger action.
        TSharedPtr<FEmailNotificationSegmentAction> EmailNotificationAction;

        // [optional] Execute azure function segment trigger action.
        TSharedPtr<FExecuteAzureFunctionSegmentAction> ExecuteAzureFunctionAction;

        // [optional] Execute cloud script segment trigger action.
        TSharedPtr<FExecuteCloudScriptSegmentAction> ExecuteCloudScriptAction;

        // [optional] Grant item segment trigger action.
        TSharedPtr<FGrantItemSegmentAction> GrantItemAction;

        // [optional] Grant virtual currency segment trigger action.
        TSharedPtr<FGrantVirtualCurrencySegmentAction> GrantVirtualCurrencyAction;

        // [optional] Increment player statistic segment trigger action.
        TSharedPtr<FIncrementPlayerStatisticSegmentAction> IncrementPlayerStatisticAction;

        // [optional] Push notification segment trigger action.
        TSharedPtr<FPushNotificationSegmentAction> PushNotificationAction;

        FSegmentTrigger() :
            FPlayFabCppBaseModel(),
            BanPlayerAction(nullptr),
            DeletePlayerAction(nullptr),
            DeletePlayerStatisticAction(nullptr),
            EmailNotificationAction(nullptr),
            ExecuteAzureFunctionAction(nullptr),
            ExecuteCloudScriptAction(nullptr),
            GrantItemAction(nullptr),
            GrantVirtualCurrencyAction(nullptr),
            IncrementPlayerStatisticAction(nullptr),
            PushNotificationAction(nullptr)
            {}

        FSegmentTrigger(const FSegmentTrigger& src) = default;

        FSegmentTrigger(const TSharedPtr<FJsonObject>& obj) : FSegmentTrigger()
        {
            readFromValue(obj);
        }

        ~FSegmentTrigger();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FFirstLoginDateSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] First player login date comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // First player login date.
        FDateTime LogInDate;

        FFirstLoginDateSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            LogInDate(0)
            {}

        FFirstLoginDateSegmentFilter(const FFirstLoginDateSegmentFilter& src) = default;

        FFirstLoginDateSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FFirstLoginDateSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FFirstLoginDateSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FFirstLoginTimespanSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] First player login duration comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // First player login duration.
        double DurationInMinutes;

        FFirstLoginTimespanSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            DurationInMinutes(0)
            {}

        FFirstLoginTimespanSegmentFilter(const FFirstLoginTimespanSegmentFilter& src) = default;

        FFirstLoginTimespanSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FFirstLoginTimespanSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FFirstLoginTimespanSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLastLoginDateSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Last player login date comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // Last player login date.
        FDateTime LogInDate;

        FLastLoginDateSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            LogInDate(0)
            {}

        FLastLoginDateSegmentFilter(const FLastLoginDateSegmentFilter& src) = default;

        FLastLoginDateSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FLastLoginDateSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FLastLoginDateSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLastLoginTimespanSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Last player login duration comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // Last player login duration.
        double DurationInMinutes;

        FLastLoginTimespanSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            DurationInMinutes(0)
            {}

        FLastLoginTimespanSegmentFilter(const FLastLoginTimespanSegmentFilter& src) = default;

        FLastLoginTimespanSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FLastLoginTimespanSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FLastLoginTimespanSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SegmentLoginIdentityProvider
    {
        SegmentLoginIdentityProviderUnknown,
        SegmentLoginIdentityProviderPlayFab,
        SegmentLoginIdentityProviderCustom,
        SegmentLoginIdentityProviderGameCenter,
        SegmentLoginIdentityProviderGooglePlay,
        SegmentLoginIdentityProviderSteam,
        SegmentLoginIdentityProviderXBoxLive,
        SegmentLoginIdentityProviderPSN,
        SegmentLoginIdentityProviderKongregate,
        SegmentLoginIdentityProviderFacebook,
        SegmentLoginIdentityProviderIOSDevice,
        SegmentLoginIdentityProviderAndroidDevice,
        SegmentLoginIdentityProviderTwitch,
        SegmentLoginIdentityProviderWindowsHello,
        SegmentLoginIdentityProviderGameServer,
        SegmentLoginIdentityProviderCustomServer,
        SegmentLoginIdentityProviderNintendoSwitch,
        SegmentLoginIdentityProviderFacebookInstantGames,
        SegmentLoginIdentityProviderOpenIdConnect,
        SegmentLoginIdentityProviderApple,
        SegmentLoginIdentityProviderNintendoSwitchAccount
    };

    PLAYFABCPP_API void writeSegmentLoginIdentityProviderEnumJSON(SegmentLoginIdentityProvider enumVal, JsonWriter& writer);
    PLAYFABCPP_API SegmentLoginIdentityProvider readSegmentLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SegmentLoginIdentityProvider readSegmentLoginIdentityProviderFromValue(const FString& value);

    struct PLAYFABCPP_API FLinkedUserAccountSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Login provider.
        Boxed<SegmentLoginIdentityProvider> LoginProvider;

        FLinkedUserAccountSegmentFilter() :
            FPlayFabCppBaseModel(),
            LoginProvider()
            {}

        FLinkedUserAccountSegmentFilter(const FLinkedUserAccountSegmentFilter& src) = default;

        FLinkedUserAccountSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FLinkedUserAccountSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FLinkedUserAccountSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLinkedUserAccountHasEmailSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Login provider comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // [optional] Login provider.
        Boxed<SegmentLoginIdentityProvider> LoginProvider;

        FLinkedUserAccountHasEmailSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            LoginProvider()
            {}

        FLinkedUserAccountHasEmailSegmentFilter(const FLinkedUserAccountHasEmailSegmentFilter& src) = default;

        FLinkedUserAccountHasEmailSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FLinkedUserAccountHasEmailSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FLinkedUserAccountHasEmailSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SegmentCountryCode
    {
        SegmentCountryCodeAF,
        SegmentCountryCodeAX,
        SegmentCountryCodeAL,
        SegmentCountryCodeDZ,
        SegmentCountryCodeAS,
        SegmentCountryCodeAD,
        SegmentCountryCodeAO,
        SegmentCountryCodeAI,
        SegmentCountryCodeAQ,
        SegmentCountryCodeAG,
        SegmentCountryCodeAR,
        SegmentCountryCodeAM,
        SegmentCountryCodeAW,
        SegmentCountryCodeAU,
        SegmentCountryCodeAT,
        SegmentCountryCodeAZ,
        SegmentCountryCodeBS,
        SegmentCountryCodeBH,
        SegmentCountryCodeBD,
        SegmentCountryCodeBB,
        SegmentCountryCodeBY,
        SegmentCountryCodeBE,
        SegmentCountryCodeBZ,
        SegmentCountryCodeBJ,
        SegmentCountryCodeBM,
        SegmentCountryCodeBT,
        SegmentCountryCodeBO,
        SegmentCountryCodeBQ,
        SegmentCountryCodeBA,
        SegmentCountryCodeBW,
        SegmentCountryCodeBV,
        SegmentCountryCodeBR,
        SegmentCountryCodeIO,
        SegmentCountryCodeBN,
        SegmentCountryCodeBG,
        SegmentCountryCodeBF,
        SegmentCountryCodeBI,
        SegmentCountryCodeKH,
        SegmentCountryCodeCM,
        SegmentCountryCodeCA,
        SegmentCountryCodeCV,
        SegmentCountryCodeKY,
        SegmentCountryCodeCF,
        SegmentCountryCodeTD,
        SegmentCountryCodeCL,
        SegmentCountryCodeCN,
        SegmentCountryCodeCX,
        SegmentCountryCodeCC,
        SegmentCountryCodeCO,
        SegmentCountryCodeKM,
        SegmentCountryCodeCG,
        SegmentCountryCodeCD,
        SegmentCountryCodeCK,
        SegmentCountryCodeCR,
        SegmentCountryCodeCI,
        SegmentCountryCodeHR,
        SegmentCountryCodeCU,
        SegmentCountryCodeCW,
        SegmentCountryCodeCY,
        SegmentCountryCodeCZ,
        SegmentCountryCodeDK,
        SegmentCountryCodeDJ,
        SegmentCountryCodeDM,
        SegmentCountryCodeDO,
        SegmentCountryCodeEC,
        SegmentCountryCodeEG,
        SegmentCountryCodeSV,
        SegmentCountryCodeGQ,
        SegmentCountryCodeER,
        SegmentCountryCodeEE,
        SegmentCountryCodeET,
        SegmentCountryCodeFK,
        SegmentCountryCodeFO,
        SegmentCountryCodeFJ,
        SegmentCountryCodeFI,
        SegmentCountryCodeFR,
        SegmentCountryCodeGF,
        SegmentCountryCodePF,
        SegmentCountryCodeTF,
        SegmentCountryCodeGA,
        SegmentCountryCodeGM,
        SegmentCountryCodeGE,
        SegmentCountryCodeDE,
        SegmentCountryCodeGH,
        SegmentCountryCodeGI,
        SegmentCountryCodeGR,
        SegmentCountryCodeGL,
        SegmentCountryCodeGD,
        SegmentCountryCodeGP,
        SegmentCountryCodeGU,
        SegmentCountryCodeGT,
        SegmentCountryCodeGG,
        SegmentCountryCodeGN,
        SegmentCountryCodeGW,
        SegmentCountryCodeGY,
        SegmentCountryCodeHT,
        SegmentCountryCodeHM,
        SegmentCountryCodeVA,
        SegmentCountryCodeHN,
        SegmentCountryCodeHK,
        SegmentCountryCodeHU,
        SegmentCountryCodeIS,
        SegmentCountryCodeIN,
        SegmentCountryCodeID,
        SegmentCountryCodeIR,
        SegmentCountryCodeIQ,
        SegmentCountryCodeIE,
        SegmentCountryCodeIM,
        SegmentCountryCodeIL,
        SegmentCountryCodeIT,
        SegmentCountryCodeJM,
        SegmentCountryCodeJP,
        SegmentCountryCodeJE,
        SegmentCountryCodeJO,
        SegmentCountryCodeKZ,
        SegmentCountryCodeKE,
        SegmentCountryCodeKI,
        SegmentCountryCodeKP,
        SegmentCountryCodeKR,
        SegmentCountryCodeKW,
        SegmentCountryCodeKG,
        SegmentCountryCodeLA,
        SegmentCountryCodeLV,
        SegmentCountryCodeLB,
        SegmentCountryCodeLS,
        SegmentCountryCodeLR,
        SegmentCountryCodeLY,
        SegmentCountryCodeLI,
        SegmentCountryCodeLT,
        SegmentCountryCodeLU,
        SegmentCountryCodeMO,
        SegmentCountryCodeMK,
        SegmentCountryCodeMG,
        SegmentCountryCodeMW,
        SegmentCountryCodeMY,
        SegmentCountryCodeMV,
        SegmentCountryCodeML,
        SegmentCountryCodeMT,
        SegmentCountryCodeMH,
        SegmentCountryCodeMQ,
        SegmentCountryCodeMR,
        SegmentCountryCodeMU,
        SegmentCountryCodeYT,
        SegmentCountryCodeMX,
        SegmentCountryCodeFM,
        SegmentCountryCodeMD,
        SegmentCountryCodeMC,
        SegmentCountryCodeMN,
        SegmentCountryCodeME,
        SegmentCountryCodeMS,
        SegmentCountryCodeMA,
        SegmentCountryCodeMZ,
        SegmentCountryCodeMM,
        SegmentCountryCodeNA,
        SegmentCountryCodeNR,
        SegmentCountryCodeNP,
        SegmentCountryCodeNL,
        SegmentCountryCodeNC,
        SegmentCountryCodeNZ,
        SegmentCountryCodeNI,
        SegmentCountryCodeNE,
        SegmentCountryCodeNG,
        SegmentCountryCodeNU,
        SegmentCountryCodeNF,
        SegmentCountryCodeMP,
        SegmentCountryCodeNO,
        SegmentCountryCodeOM,
        SegmentCountryCodePK,
        SegmentCountryCodePW,
        SegmentCountryCodePS,
        SegmentCountryCodePA,
        SegmentCountryCodePG,
        SegmentCountryCodePY,
        SegmentCountryCodePE,
        SegmentCountryCodePH,
        SegmentCountryCodePN,
        SegmentCountryCodePL,
        SegmentCountryCodePT,
        SegmentCountryCodePR,
        SegmentCountryCodeQA,
        SegmentCountryCodeRE,
        SegmentCountryCodeRO,
        SegmentCountryCodeRU,
        SegmentCountryCodeRW,
        SegmentCountryCodeBL,
        SegmentCountryCodeSH,
        SegmentCountryCodeKN,
        SegmentCountryCodeLC,
        SegmentCountryCodeMF,
        SegmentCountryCodePM,
        SegmentCountryCodeVC,
        SegmentCountryCodeWS,
        SegmentCountryCodeSM,
        SegmentCountryCodeST,
        SegmentCountryCodeSA,
        SegmentCountryCodeSN,
        SegmentCountryCodeRS,
        SegmentCountryCodeSC,
        SegmentCountryCodeSL,
        SegmentCountryCodeSG,
        SegmentCountryCodeSX,
        SegmentCountryCodeSK,
        SegmentCountryCodeSI,
        SegmentCountryCodeSB,
        SegmentCountryCodeSO,
        SegmentCountryCodeZA,
        SegmentCountryCodeGS,
        SegmentCountryCodeSS,
        SegmentCountryCodeES,
        SegmentCountryCodeLK,
        SegmentCountryCodeSD,
        SegmentCountryCodeSR,
        SegmentCountryCodeSJ,
        SegmentCountryCodeSZ,
        SegmentCountryCodeSE,
        SegmentCountryCodeCH,
        SegmentCountryCodeSY,
        SegmentCountryCodeTW,
        SegmentCountryCodeTJ,
        SegmentCountryCodeTZ,
        SegmentCountryCodeTH,
        SegmentCountryCodeTL,
        SegmentCountryCodeTG,
        SegmentCountryCodeTK,
        SegmentCountryCodeTO,
        SegmentCountryCodeTT,
        SegmentCountryCodeTN,
        SegmentCountryCodeTR,
        SegmentCountryCodeTM,
        SegmentCountryCodeTC,
        SegmentCountryCodeTV,
        SegmentCountryCodeUG,
        SegmentCountryCodeUA,
        SegmentCountryCodeAE,
        SegmentCountryCodeGB,
        SegmentCountryCodeUS,
        SegmentCountryCodeUM,
        SegmentCountryCodeUY,
        SegmentCountryCodeUZ,
        SegmentCountryCodeVU,
        SegmentCountryCodeVE,
        SegmentCountryCodeVN,
        SegmentCountryCodeVG,
        SegmentCountryCodeVI,
        SegmentCountryCodeWF,
        SegmentCountryCodeEH,
        SegmentCountryCodeYE,
        SegmentCountryCodeZM,
        SegmentCountryCodeZW
    };

    PLAYFABCPP_API void writeSegmentCountryCodeEnumJSON(SegmentCountryCode enumVal, JsonWriter& writer);
    PLAYFABCPP_API SegmentCountryCode readSegmentCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SegmentCountryCode readSegmentCountryCodeFromValue(const FString& value);

    struct PLAYFABCPP_API FLocationSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Segment country code.
        Boxed<SegmentCountryCode> CountryCode;

        FLocationSegmentFilter() :
            FPlayFabCppBaseModel(),
            CountryCode()
            {}

        FLocationSegmentFilter(const FLocationSegmentFilter& src) = default;

        FLocationSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FLocationSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FLocationSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SegmentPushNotificationDevicePlatform
    {
        SegmentPushNotificationDevicePlatformApplePushNotificationService,
        SegmentPushNotificationDevicePlatformGoogleCloudMessaging
    };

    PLAYFABCPP_API void writeSegmentPushNotificationDevicePlatformEnumJSON(SegmentPushNotificationDevicePlatform enumVal, JsonWriter& writer);
    PLAYFABCPP_API SegmentPushNotificationDevicePlatform readSegmentPushNotificationDevicePlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SegmentPushNotificationDevicePlatform readSegmentPushNotificationDevicePlatformFromValue(const FString& value);

    struct PLAYFABCPP_API FPushNotificationSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Push notification device platform.
        Boxed<SegmentPushNotificationDevicePlatform> PushNotificationDevicePlatform;

        FPushNotificationSegmentFilter() :
            FPlayFabCppBaseModel(),
            PushNotificationDevicePlatform()
            {}

        FPushNotificationSegmentFilter(const FPushNotificationSegmentFilter& src) = default;

        FPushNotificationSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FPushNotificationSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FPushNotificationSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FStatisticSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Statistic filter comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // [optional] Statistic filter value.
        FString FilterValue;

        // [optional] Statistic name.
        FString Name;

        // [optional] Use current version of statistic?
        Boxed<bool> UseCurrentVersion;

        // [optional] Statistic version.
        Boxed<int32> Version;

        FStatisticSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            FilterValue(),
            Name(),
            UseCurrentVersion(),
            Version()
            {}

        FStatisticSegmentFilter(const FStatisticSegmentFilter& src) = default;

        FStatisticSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FStatisticSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FStatisticSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FTagSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Tag comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // [optional] Tag value.
        FString TagValue;

        FTagSegmentFilter() :
            FPlayFabCppBaseModel(),
            Comparison(),
            TagValue()
            {}

        FTagSegmentFilter(const FTagSegmentFilter& src) = default;

        FTagSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FTagSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FTagSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FTotalValueToDateInUSDSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Total value to date USD amount.
        FString Amount;

        // [optional] Total value to date USD comparison.
        Boxed<SegmentFilterComparison> Comparison;

        FTotalValueToDateInUSDSegmentFilter() :
            FPlayFabCppBaseModel(),
            Amount(),
            Comparison()
            {}

        FTotalValueToDateInUSDSegmentFilter(const FTotalValueToDateInUSDSegmentFilter& src) = default;

        FTotalValueToDateInUSDSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FTotalValueToDateInUSDSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FTotalValueToDateInUSDSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserOriginationSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] User login provider.
        Boxed<SegmentLoginIdentityProvider> LoginProvider;

        FUserOriginationSegmentFilter() :
            FPlayFabCppBaseModel(),
            LoginProvider()
            {}

        FUserOriginationSegmentFilter(const FUserOriginationSegmentFilter& src) = default;

        FUserOriginationSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FUserOriginationSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FUserOriginationSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SegmentCurrency
    {
        SegmentCurrencyAED,
        SegmentCurrencyAFN,
        SegmentCurrencyALL,
        SegmentCurrencyAMD,
        SegmentCurrencyANG,
        SegmentCurrencyAOA,
        SegmentCurrencyARS,
        SegmentCurrencyAUD,
        SegmentCurrencyAWG,
        SegmentCurrencyAZN,
        SegmentCurrencyBAM,
        SegmentCurrencyBBD,
        SegmentCurrencyBDT,
        SegmentCurrencyBGN,
        SegmentCurrencyBHD,
        SegmentCurrencyBIF,
        SegmentCurrencyBMD,
        SegmentCurrencyBND,
        SegmentCurrencyBOB,
        SegmentCurrencyBRL,
        SegmentCurrencyBSD,
        SegmentCurrencyBTN,
        SegmentCurrencyBWP,
        SegmentCurrencyBYR,
        SegmentCurrencyBZD,
        SegmentCurrencyCAD,
        SegmentCurrencyCDF,
        SegmentCurrencyCHF,
        SegmentCurrencyCLP,
        SegmentCurrencyCNY,
        SegmentCurrencyCOP,
        SegmentCurrencyCRC,
        SegmentCurrencyCUC,
        SegmentCurrencyCUP,
        SegmentCurrencyCVE,
        SegmentCurrencyCZK,
        SegmentCurrencyDJF,
        SegmentCurrencyDKK,
        SegmentCurrencyDOP,
        SegmentCurrencyDZD,
        SegmentCurrencyEGP,
        SegmentCurrencyERN,
        SegmentCurrencyETB,
        SegmentCurrencyEUR,
        SegmentCurrencyFJD,
        SegmentCurrencyFKP,
        SegmentCurrencyGBP,
        SegmentCurrencyGEL,
        SegmentCurrencyGGP,
        SegmentCurrencyGHS,
        SegmentCurrencyGIP,
        SegmentCurrencyGMD,
        SegmentCurrencyGNF,
        SegmentCurrencyGTQ,
        SegmentCurrencyGYD,
        SegmentCurrencyHKD,
        SegmentCurrencyHNL,
        SegmentCurrencyHRK,
        SegmentCurrencyHTG,
        SegmentCurrencyHUF,
        SegmentCurrencyIDR,
        SegmentCurrencyILS,
        SegmentCurrencyIMP,
        SegmentCurrencyINR,
        SegmentCurrencyIQD,
        SegmentCurrencyIRR,
        SegmentCurrencyISK,
        SegmentCurrencyJEP,
        SegmentCurrencyJMD,
        SegmentCurrencyJOD,
        SegmentCurrencyJPY,
        SegmentCurrencyKES,
        SegmentCurrencyKGS,
        SegmentCurrencyKHR,
        SegmentCurrencyKMF,
        SegmentCurrencyKPW,
        SegmentCurrencyKRW,
        SegmentCurrencyKWD,
        SegmentCurrencyKYD,
        SegmentCurrencyKZT,
        SegmentCurrencyLAK,
        SegmentCurrencyLBP,
        SegmentCurrencyLKR,
        SegmentCurrencyLRD,
        SegmentCurrencyLSL,
        SegmentCurrencyLYD,
        SegmentCurrencyMAD,
        SegmentCurrencyMDL,
        SegmentCurrencyMGA,
        SegmentCurrencyMKD,
        SegmentCurrencyMMK,
        SegmentCurrencyMNT,
        SegmentCurrencyMOP,
        SegmentCurrencyMRO,
        SegmentCurrencyMUR,
        SegmentCurrencyMVR,
        SegmentCurrencyMWK,
        SegmentCurrencyMXN,
        SegmentCurrencyMYR,
        SegmentCurrencyMZN,
        SegmentCurrencyNAD,
        SegmentCurrencyNGN,
        SegmentCurrencyNIO,
        SegmentCurrencyNOK,
        SegmentCurrencyNPR,
        SegmentCurrencyNZD,
        SegmentCurrencyOMR,
        SegmentCurrencyPAB,
        SegmentCurrencyPEN,
        SegmentCurrencyPGK,
        SegmentCurrencyPHP,
        SegmentCurrencyPKR,
        SegmentCurrencyPLN,
        SegmentCurrencyPYG,
        SegmentCurrencyQAR,
        SegmentCurrencyRON,
        SegmentCurrencyRSD,
        SegmentCurrencyRUB,
        SegmentCurrencyRWF,
        SegmentCurrencySAR,
        SegmentCurrencySBD,
        SegmentCurrencySCR,
        SegmentCurrencySDG,
        SegmentCurrencySEK,
        SegmentCurrencySGD,
        SegmentCurrencySHP,
        SegmentCurrencySLL,
        SegmentCurrencySOS,
        SegmentCurrencySPL,
        SegmentCurrencySRD,
        SegmentCurrencySTD,
        SegmentCurrencySVC,
        SegmentCurrencySYP,
        SegmentCurrencySZL,
        SegmentCurrencyTHB,
        SegmentCurrencyTJS,
        SegmentCurrencyTMT,
        SegmentCurrencyTND,
        SegmentCurrencyTOP,
        SegmentCurrencyTRY,
        SegmentCurrencyTTD,
        SegmentCurrencyTVD,
        SegmentCurrencyTWD,
        SegmentCurrencyTZS,
        SegmentCurrencyUAH,
        SegmentCurrencyUGX,
        SegmentCurrencyUSD,
        SegmentCurrencyUYU,
        SegmentCurrencyUZS,
        SegmentCurrencyVEF,
        SegmentCurrencyVND,
        SegmentCurrencyVUV,
        SegmentCurrencyWST,
        SegmentCurrencyXAF,
        SegmentCurrencyXCD,
        SegmentCurrencyXDR,
        SegmentCurrencyXOF,
        SegmentCurrencyXPF,
        SegmentCurrencyYER,
        SegmentCurrencyZAR,
        SegmentCurrencyZMW,
        SegmentCurrencyZWD
    };

    PLAYFABCPP_API void writeSegmentCurrencyEnumJSON(SegmentCurrency enumVal, JsonWriter& writer);
    PLAYFABCPP_API SegmentCurrency readSegmentCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SegmentCurrency readSegmentCurrencyFromValue(const FString& value);

    struct PLAYFABCPP_API FValueToDateSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Value to date amount.
        FString Amount;

        // [optional] Value to date comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // [optional] Currency using for filter.
        Boxed<SegmentCurrency> Currency;

        FValueToDateSegmentFilter() :
            FPlayFabCppBaseModel(),
            Amount(),
            Comparison(),
            Currency()
            {}

        FValueToDateSegmentFilter(const FValueToDateSegmentFilter& src) = default;

        FValueToDateSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FValueToDateSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FValueToDateSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVirtualCurrencyBalanceSegmentFilter : public PlayFab::FPlayFabCppBaseModel
    {
        // Total amount.
        int32 Amount;

        // [optional] Amount comparison.
        Boxed<SegmentFilterComparison> Comparison;

        // [optional] Currency code.
        FString CurrencyCode;

        FVirtualCurrencyBalanceSegmentFilter() :
            FPlayFabCppBaseModel(),
            Amount(0),
            Comparison(),
            CurrencyCode()
            {}

        FVirtualCurrencyBalanceSegmentFilter(const FVirtualCurrencyBalanceSegmentFilter& src) = default;

        FVirtualCurrencyBalanceSegmentFilter(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyBalanceSegmentFilter()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyBalanceSegmentFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSegmentAndDefinition : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Filter property for ad campaign filter.
        TSharedPtr<FAdCampaignSegmentFilter> AdCampaignFilter;

        // [optional] property for all player filter.
        TSharedPtr<FAllPlayersSegmentFilter> AllPlayersFilter;

        // [optional] Filter property for first login date.
        TSharedPtr<FFirstLoginDateSegmentFilter> FirstLoginDateFilter;

        // [optional] Filter property for first login timespan.
        TSharedPtr<FFirstLoginTimespanSegmentFilter> FirstLoginFilter;

        // [optional] Filter property for last login date.
        TSharedPtr<FLastLoginDateSegmentFilter> LastLoginDateFilter;

        // [optional] Filter property for last login timespan.
        TSharedPtr<FLastLoginTimespanSegmentFilter> LastLoginFilter;

        // [optional] Filter property for linked in user account.
        TSharedPtr<FLinkedUserAccountSegmentFilter> LinkedUserAccountFilter;

        // [optional] Filter property for linked in user account has email.
        TSharedPtr<FLinkedUserAccountHasEmailSegmentFilter> LinkedUserAccountHasEmailFilter;

        // [optional] Filter property for location.
        TSharedPtr<FLocationSegmentFilter> LocationFilter;

        // [optional] Filter property for push notification.
        TSharedPtr<FPushNotificationSegmentFilter> PushNotificationFilter;

        // [optional] Filter property for statistics.
        TSharedPtr<FStatisticSegmentFilter> StatisticFilter;

        // [optional] Filter property for tags.
        TSharedPtr<FTagSegmentFilter> TagFilter;

        // [optional] Filter property for total value to date in USD.
        TSharedPtr<FTotalValueToDateInUSDSegmentFilter> TotalValueToDateInUSDFilter;

        // [optional] Filter property for user origination.
        TSharedPtr<FUserOriginationSegmentFilter> UserOriginationFilter;

        // [optional] Filter property for value to date.
        TSharedPtr<FValueToDateSegmentFilter> ValueToDateFilter;

        // [optional] Filter property for virtual currency.
        TSharedPtr<FVirtualCurrencyBalanceSegmentFilter> VirtualCurrencyBalanceFilter;

        FSegmentAndDefinition() :
            FPlayFabCppBaseModel(),
            AdCampaignFilter(nullptr),
            AllPlayersFilter(nullptr),
            FirstLoginDateFilter(nullptr),
            FirstLoginFilter(nullptr),
            LastLoginDateFilter(nullptr),
            LastLoginFilter(nullptr),
            LinkedUserAccountFilter(nullptr),
            LinkedUserAccountHasEmailFilter(nullptr),
            LocationFilter(nullptr),
            PushNotificationFilter(nullptr),
            StatisticFilter(nullptr),
            TagFilter(nullptr),
            TotalValueToDateInUSDFilter(nullptr),
            UserOriginationFilter(nullptr),
            ValueToDateFilter(nullptr),
            VirtualCurrencyBalanceFilter(nullptr)
            {}

        FSegmentAndDefinition(const FSegmentAndDefinition& src) = default;

        FSegmentAndDefinition(const TSharedPtr<FJsonObject>& obj) : FSegmentAndDefinition()
        {
            readFromValue(obj);
        }

        ~FSegmentAndDefinition();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSegmentOrDefinition : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] List of segment and definitions.
        TArray<FSegmentAndDefinition> SegmentAndDefinitions;
        FSegmentOrDefinition() :
            FPlayFabCppBaseModel(),
            SegmentAndDefinitions()
            {}

        FSegmentOrDefinition(const FSegmentOrDefinition& src) = default;

        FSegmentOrDefinition(const TSharedPtr<FJsonObject>& obj) : FSegmentOrDefinition()
        {
            readFromValue(obj);
        }

        ~FSegmentOrDefinition();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSegmentModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Segment description.
        FString Description;

        // [optional] Segment actions for current entered segment players.
        TArray<FSegmentTrigger> EnteredSegmentActions;
        // Segment last updated date time.
        FDateTime LastUpdateTime;

        // [optional] Segment actions for current left segment players.
        TArray<FSegmentTrigger> LeftSegmentActions;
        // [optional] Segment name.
        FString Name;

        // [optional] Segment id in hex.
        FString SegmentId;

        // [optional] Segment or definitions. This includes segment and definitions and filters.
        TArray<FSegmentOrDefinition> SegmentOrDefinitions;
        FSegmentModel() :
            FPlayFabCppBaseModel(),
            Description(),
            EnteredSegmentActions(),
            LastUpdateTime(0),
            LeftSegmentActions(),
            Name(),
            SegmentId(),
            SegmentOrDefinitions()
            {}

        FSegmentModel(const FSegmentModel& src) = default;

        FSegmentModel(const TSharedPtr<FJsonObject>& obj) : FSegmentModel()
        {
            readFromValue(obj);
        }

        ~FSegmentModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateSegmentRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Segment model with all of the segment properties data.
        FSegmentModel pfSegmentModel;

        FCreateSegmentRequest() :
            FPlayFabCppRequestCommon(),
            pfSegmentModel()
            {}

        FCreateSegmentRequest(const FCreateSegmentRequest& src) = default;

        FCreateSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FCreateSegmentRequest()
        {
            readFromValue(obj);
        }

        ~FCreateSegmentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateSegmentResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Error message.
        FString ErrorMessage;

        // [optional] Segment id.
        FString SegmentId;

        FCreateSegmentResponse() :
            FPlayFabCppResultCommon(),
            ErrorMessage(),
            SegmentId()
            {}

        FCreateSegmentResponse(const FCreateSegmentResponse& src) = default;

        FCreateSegmentResponse(const TSharedPtr<FJsonObject>& obj) : FCreateSegmentResponse()
        {
            readFromValue(obj);
        }

        ~FCreateSegmentResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateTaskResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] ID of the task
        FString TaskId;

        FCreateTaskResult() :
            FPlayFabCppResultCommon(),
            TaskId()
            {}

        FCreateTaskResult(const FCreateTaskResult& src) = default;

        FCreateTaskResult(const TSharedPtr<FJsonObject>& obj) : FCreateTaskResult()
        {
            readFromValue(obj);
        }

        ~FCreateTaskResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Currency
    {
        CurrencyAED,
        CurrencyAFN,
        CurrencyALL,
        CurrencyAMD,
        CurrencyANG,
        CurrencyAOA,
        CurrencyARS,
        CurrencyAUD,
        CurrencyAWG,
        CurrencyAZN,
        CurrencyBAM,
        CurrencyBBD,
        CurrencyBDT,
        CurrencyBGN,
        CurrencyBHD,
        CurrencyBIF,
        CurrencyBMD,
        CurrencyBND,
        CurrencyBOB,
        CurrencyBRL,
        CurrencyBSD,
        CurrencyBTN,
        CurrencyBWP,
        CurrencyBYR,
        CurrencyBZD,
        CurrencyCAD,
        CurrencyCDF,
        CurrencyCHF,
        CurrencyCLP,
        CurrencyCNY,
        CurrencyCOP,
        CurrencyCRC,
        CurrencyCUC,
        CurrencyCUP,
        CurrencyCVE,
        CurrencyCZK,
        CurrencyDJF,
        CurrencyDKK,
        CurrencyDOP,
        CurrencyDZD,
        CurrencyEGP,
        CurrencyERN,
        CurrencyETB,
        CurrencyEUR,
        CurrencyFJD,
        CurrencyFKP,
        CurrencyGBP,
        CurrencyGEL,
        CurrencyGGP,
        CurrencyGHS,
        CurrencyGIP,
        CurrencyGMD,
        CurrencyGNF,
        CurrencyGTQ,
        CurrencyGYD,
        CurrencyHKD,
        CurrencyHNL,
        CurrencyHRK,
        CurrencyHTG,
        CurrencyHUF,
        CurrencyIDR,
        CurrencyILS,
        CurrencyIMP,
        CurrencyINR,
        CurrencyIQD,
        CurrencyIRR,
        CurrencyISK,
        CurrencyJEP,
        CurrencyJMD,
        CurrencyJOD,
        CurrencyJPY,
        CurrencyKES,
        CurrencyKGS,
        CurrencyKHR,
        CurrencyKMF,
        CurrencyKPW,
        CurrencyKRW,
        CurrencyKWD,
        CurrencyKYD,
        CurrencyKZT,
        CurrencyLAK,
        CurrencyLBP,
        CurrencyLKR,
        CurrencyLRD,
        CurrencyLSL,
        CurrencyLYD,
        CurrencyMAD,
        CurrencyMDL,
        CurrencyMGA,
        CurrencyMKD,
        CurrencyMMK,
        CurrencyMNT,
        CurrencyMOP,
        CurrencyMRO,
        CurrencyMUR,
        CurrencyMVR,
        CurrencyMWK,
        CurrencyMXN,
        CurrencyMYR,
        CurrencyMZN,
        CurrencyNAD,
        CurrencyNGN,
        CurrencyNIO,
        CurrencyNOK,
        CurrencyNPR,
        CurrencyNZD,
        CurrencyOMR,
        CurrencyPAB,
        CurrencyPEN,
        CurrencyPGK,
        CurrencyPHP,
        CurrencyPKR,
        CurrencyPLN,
        CurrencyPYG,
        CurrencyQAR,
        CurrencyRON,
        CurrencyRSD,
        CurrencyRUB,
        CurrencyRWF,
        CurrencySAR,
        CurrencySBD,
        CurrencySCR,
        CurrencySDG,
        CurrencySEK,
        CurrencySGD,
        CurrencySHP,
        CurrencySLL,
        CurrencySOS,
        CurrencySPL,
        CurrencySRD,
        CurrencySTD,
        CurrencySVC,
        CurrencySYP,
        CurrencySZL,
        CurrencyTHB,
        CurrencyTJS,
        CurrencyTMT,
        CurrencyTND,
        CurrencyTOP,
        CurrencyTRY,
        CurrencyTTD,
        CurrencyTVD,
        CurrencyTWD,
        CurrencyTZS,
        CurrencyUAH,
        CurrencyUGX,
        CurrencyUSD,
        CurrencyUYU,
        CurrencyUZS,
        CurrencyVEF,
        CurrencyVND,
        CurrencyVUV,
        CurrencyWST,
        CurrencyXAF,
        CurrencyXCD,
        CurrencyXDR,
        CurrencyXOF,
        CurrencyXPF,
        CurrencyYER,
        CurrencyZAR,
        CurrencyZMW,
        CurrencyZWD
    };

    PLAYFABCPP_API void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
    PLAYFABCPP_API Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API Currency readCurrencyFromValue(const FString& value);

    struct PLAYFABCPP_API FDeleteContentRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Key of the content item to be deleted
        FString Key;

        FDeleteContentRequest() :
            FPlayFabCppRequestCommon(),
            Key()
            {}

        FDeleteContentRequest(const FDeleteContentRequest& src) = default;

        FDeleteContentRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteContentRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteContentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteMasterPlayerAccountRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Developer created string to identify a user without PlayFab ID
        FString MetaData;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FDeleteMasterPlayerAccountRequest() :
            FPlayFabCppRequestCommon(),
            MetaData(),
            PlayFabId()
            {}

        FDeleteMasterPlayerAccountRequest(const FDeleteMasterPlayerAccountRequest& src) = default;

        FDeleteMasterPlayerAccountRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteMasterPlayerAccountRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteMasterPlayerAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteMasterPlayerAccountResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] A notification email with this job receipt Id will be sent to the title notification email address when deletion is
         * complete.
         */
        FString JobReceiptId;

        // [optional] List of titles from which the player's data will be deleted.
        TArray<FString> TitleIds;
        FDeleteMasterPlayerAccountResult() :
            FPlayFabCppResultCommon(),
            JobReceiptId(),
            TitleIds()
            {}

        FDeleteMasterPlayerAccountResult(const FDeleteMasterPlayerAccountResult& src) = default;

        FDeleteMasterPlayerAccountResult(const TSharedPtr<FJsonObject>& obj) : FDeleteMasterPlayerAccountResult()
        {
            readFromValue(obj);
        }

        ~FDeleteMasterPlayerAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteOpenIdConnectionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // unique name of the connection
        FString ConnectionId;

        FDeleteOpenIdConnectionRequest() :
            FPlayFabCppRequestCommon(),
            ConnectionId()
            {}

        FDeleteOpenIdConnectionRequest(const FDeleteOpenIdConnectionRequest& src) = default;

        FDeleteOpenIdConnectionRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteOpenIdConnectionRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteOpenIdConnectionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeletePlayerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FDeletePlayerRequest() :
            FPlayFabCppRequestCommon(),
            PlayFabId()
            {}

        FDeletePlayerRequest(const FDeletePlayerRequest& src) = default;

        FDeletePlayerRequest(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerRequest()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeletePlayerResult : public PlayFab::FPlayFabCppResultCommon
    {
        FDeletePlayerResult() :
            FPlayFabCppResultCommon()
            {}

        FDeletePlayerResult(const FDeletePlayerResult& src) = default;

        FDeletePlayerResult(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerResult()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeletePlayerSharedSecretRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The shared secret key to delete
        FString SecretKey;

        FDeletePlayerSharedSecretRequest() :
            FPlayFabCppRequestCommon(),
            SecretKey()
            {}

        FDeletePlayerSharedSecretRequest(const FDeletePlayerSharedSecretRequest& src) = default;

        FDeletePlayerSharedSecretRequest(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerSharedSecretRequest()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerSharedSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeletePlayerSharedSecretResult : public PlayFab::FPlayFabCppResultCommon
    {
        FDeletePlayerSharedSecretResult() :
            FPlayFabCppResultCommon()
            {}

        FDeletePlayerSharedSecretResult(const FDeletePlayerSharedSecretResult& src) = default;

        FDeletePlayerSharedSecretResult(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerSharedSecretResult()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerSharedSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteSegmentRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Segment id.
        FString SegmentId;

        FDeleteSegmentRequest() :
            FPlayFabCppRequestCommon(),
            SegmentId()
            {}

        FDeleteSegmentRequest(const FDeleteSegmentRequest& src) = default;

        FDeleteSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteSegmentRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteSegmentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteSegmentsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Error message.
        FString ErrorMessage;

        FDeleteSegmentsResponse() :
            FPlayFabCppResultCommon(),
            ErrorMessage()
            {}

        FDeleteSegmentsResponse(const FDeleteSegmentsResponse& src) = default;

        FDeleteSegmentsResponse(const TSharedPtr<FJsonObject>& obj) : FDeleteSegmentsResponse()
        {
            readFromValue(obj);
        }

        ~FDeleteSegmentsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteStoreRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] catalog version of the store to delete. If null, uses the default catalog.
        FString CatalogVersion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // unqiue identifier for the store which is to be deleted
        FString StoreId;

        FDeleteStoreRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion(),
            CustomTags(),
            StoreId()
            {}

        FDeleteStoreRequest(const FDeleteStoreRequest& src) = default;

        FDeleteStoreRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteStoreRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteStoreRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteStoreResult : public PlayFab::FPlayFabCppResultCommon
    {
        FDeleteStoreResult() :
            FPlayFabCppResultCommon()
            {}

        FDeleteStoreResult(const FDeleteStoreResult& src) = default;

        FDeleteStoreResult(const TSharedPtr<FJsonObject>& obj) : FDeleteStoreResult()
        {
            readFromValue(obj);
        }

        ~FDeleteStoreResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteTaskRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Specify either the task ID or the name of task to be deleted.
        TSharedPtr<FNameIdentifier> Identifier;

        FDeleteTaskRequest() :
            FPlayFabCppRequestCommon(),
            Identifier(nullptr)
            {}

        FDeleteTaskRequest(const FDeleteTaskRequest& src) = default;

        FDeleteTaskRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteTaskRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteTitleDataOverrideRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Name of the override.
        FString OverrideLabel;

        FDeleteTitleDataOverrideRequest() :
            FPlayFabCppRequestCommon(),
            OverrideLabel()
            {}

        FDeleteTitleDataOverrideRequest(const FDeleteTitleDataOverrideRequest& src) = default;

        FDeleteTitleDataOverrideRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteTitleDataOverrideRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteTitleDataOverrideRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteTitleDataOverrideResult : public PlayFab::FPlayFabCppResultCommon
    {
        FDeleteTitleDataOverrideResult() :
            FPlayFabCppResultCommon()
            {}

        FDeleteTitleDataOverrideResult(const FDeleteTitleDataOverrideResult& src) = default;

        FDeleteTitleDataOverrideResult(const TSharedPtr<FJsonObject>& obj) : FDeleteTitleDataOverrideResult()
        {
            readFromValue(obj);
        }

        ~FDeleteTitleDataOverrideResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteTitleRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FDeleteTitleRequest() :
            FPlayFabCppRequestCommon()
            {}

        FDeleteTitleRequest(const FDeleteTitleRequest& src) = default;

        FDeleteTitleRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteTitleRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteTitleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteTitleResult : public PlayFab::FPlayFabCppResultCommon
    {
        FDeleteTitleResult() :
            FPlayFabCppResultCommon()
            {}

        FDeleteTitleResult(const FDeleteTitleResult& src) = default;

        FDeleteTitleResult(const TSharedPtr<FJsonObject>& obj) : FDeleteTitleResult()
        {
            readFromValue(obj);
        }

        ~FDeleteTitleResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EffectType
    {
        EffectTypeAllow,
        EffectTypeDeny
    };

    PLAYFABCPP_API void writeEffectTypeEnumJSON(EffectType enumVal, JsonWriter& writer);
    PLAYFABCPP_API EffectType readEffectTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API EffectType readEffectTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FEmptyResponse : public PlayFab::FPlayFabCppResultCommon
    {
        FEmptyResponse() :
            FPlayFabCppResultCommon()
            {}

        FEmptyResponse(const FEmptyResponse& src) = default;

        FEmptyResponse(const TSharedPtr<FJsonObject>& obj) : FEmptyResponse()
        {
            readFromValue(obj);
        }

        ~FEmptyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FEntityKey : public PlayFab::FPlayFabCppBaseModel
    {
        // Unique ID of the entity.
        FString Id;

        // [optional] Entity type. See https://docs.microsoft.com/gaming/playfab/features/data/entities/available-built-in-entity-types
        FString Type;

        FEntityKey() :
            FPlayFabCppBaseModel(),
            Id(),
            Type()
            {}

        FEntityKey(const FEntityKey& src) = default;

        FEntityKey(const TSharedPtr<FJsonObject>& obj) : FEntityKey()
        {
            readFromValue(obj);
        }

        ~FEntityKey();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FExportMasterPlayerDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FExportMasterPlayerDataRequest() :
            FPlayFabCppRequestCommon(),
            PlayFabId()
            {}

        FExportMasterPlayerDataRequest(const FExportMasterPlayerDataRequest& src) = default;

        FExportMasterPlayerDataRequest(const TSharedPtr<FJsonObject>& obj) : FExportMasterPlayerDataRequest()
        {
            readFromValue(obj);
        }

        ~FExportMasterPlayerDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FExportMasterPlayerDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] An email with this job receipt Id containing the export download link will be sent to the title notification email
         * address when the export is complete.
         */
        FString JobReceiptId;

        FExportMasterPlayerDataResult() :
            FPlayFabCppResultCommon(),
            JobReceiptId()
            {}

        FExportMasterPlayerDataResult(const FExportMasterPlayerDataResult& src) = default;

        FExportMasterPlayerDataResult(const TSharedPtr<FJsonObject>& obj) : FExportMasterPlayerDataResult()
        {
            readFromValue(obj);
        }

        ~FExportMasterPlayerDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGameModeInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // specific game mode type
        FString Gamemode;

        // maximum user count a specific Game Server Instance can support
        uint32 MaxPlayerCount;

        // minimum user count required for this Game Server Instance to continue (usually 1)
        uint32 MinPlayerCount;

        // [optional] whether to start as an open session, meaning that players can matchmake into it (defaults to true)
        Boxed<bool> StartOpen;

        FGameModeInfo() :
            FPlayFabCppBaseModel(),
            Gamemode(),
            MaxPlayerCount(0),
            MinPlayerCount(0),
            StartOpen()
            {}

        FGameModeInfo(const FGameModeInfo& src) = default;

        FGameModeInfo(const TSharedPtr<FJsonObject>& obj) : FGameModeInfo()
        {
            readFromValue(obj);
        }

        ~FGameModeInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetActionsOnPlayersInSegmentTaskInstanceResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Parameter of this task instance
        TSharedPtr<FActionsOnPlayersInSegmentTaskParameter> Parameter;

        // [optional] Status summary of the actions-on-players-in-segment task instance
        TSharedPtr<FActionsOnPlayersInSegmentTaskSummary> Summary;

        FGetActionsOnPlayersInSegmentTaskInstanceResult() :
            FPlayFabCppResultCommon(),
            Parameter(nullptr),
            Summary(nullptr)
            {}

        FGetActionsOnPlayersInSegmentTaskInstanceResult(const FGetActionsOnPlayersInSegmentTaskInstanceResult& src) = default;

        FGetActionsOnPlayersInSegmentTaskInstanceResult(const TSharedPtr<FJsonObject>& obj) : FGetActionsOnPlayersInSegmentTaskInstanceResult()
        {
            readFromValue(obj);
        }

        ~FGetActionsOnPlayersInSegmentTaskInstanceResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAllSegmentsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FGetAllSegmentsRequest() :
            FPlayFabCppRequestCommon()
            {}

        FGetAllSegmentsRequest(const FGetAllSegmentsRequest& src) = default;

        FGetAllSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetAllSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetSegmentResult : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Identifier of the segments AB Test, if it is attached to one.
        FString ABTestParent;

        // Unique identifier for this segment.
        FString Id;

        // [optional] Segment name.
        FString Name;

        FGetSegmentResult() :
            FPlayFabCppBaseModel(),
            ABTestParent(),
            Id(),
            Name()
            {}

        FGetSegmentResult(const FGetSegmentResult& src) = default;

        FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAllSegmentsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Array of segments for this title.
        TArray<FGetSegmentResult> Segments;
        FGetAllSegmentsResult() :
            FPlayFabCppResultCommon(),
            Segments()
            {}

        FGetAllSegmentsResult(const FGetAllSegmentsResult& src) = default;

        FGetAllSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetAllSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCatalogItemsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Which catalog is being requested. If null, uses the default catalog.
        FString CatalogVersion;

        FGetCatalogItemsRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion()
            {}

        FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) = default;

        FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCatalogItemsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Array of items which can be purchased.
        TArray<FCatalogItem> Catalog;
        FGetCatalogItemsResult() :
            FPlayFabCppResultCommon(),
            Catalog()
            {}

        FGetCatalogItemsResult(const FGetCatalogItemsResult& src) = default;

        FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCloudScriptRevisionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Revision number. If left null, defaults to the latest revision
        Boxed<int32> Revision;

        // [optional] Version number. If left null, defaults to the latest version
        Boxed<int32> Version;

        FGetCloudScriptRevisionRequest() :
            FPlayFabCppRequestCommon(),
            Revision(),
            Version()
            {}

        FGetCloudScriptRevisionRequest(const FGetCloudScriptRevisionRequest& src) = default;

        FGetCloudScriptRevisionRequest(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptRevisionRequest()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptRevisionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCloudScriptRevisionResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Time this revision was created
        FDateTime CreatedAt;

        // [optional] List of Cloud Script files in this revision.
        TArray<FCloudScriptFile> Files;
        // True if this is the currently published revision
        bool IsPublished;

        // Revision number.
        int32 Revision;

        // Version number.
        int32 Version;

        FGetCloudScriptRevisionResult() :
            FPlayFabCppResultCommon(),
            CreatedAt(0),
            Files(),
            IsPublished(false),
            Revision(0),
            Version(0)
            {}

        FGetCloudScriptRevisionResult(const FGetCloudScriptRevisionResult& src) = default;

        FGetCloudScriptRevisionResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptRevisionResult()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptRevisionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCloudScriptTaskInstanceResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Parameter of this task instance
        TSharedPtr<FCloudScriptTaskParameter> Parameter;

        // [optional] Status summary of the CloudScript task instance
        TSharedPtr<FCloudScriptTaskSummary> Summary;

        FGetCloudScriptTaskInstanceResult() :
            FPlayFabCppResultCommon(),
            Parameter(nullptr),
            Summary(nullptr)
            {}

        FGetCloudScriptTaskInstanceResult(const FGetCloudScriptTaskInstanceResult& src) = default;

        FGetCloudScriptTaskInstanceResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptTaskInstanceResult()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptTaskInstanceResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCloudScriptVersionsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FGetCloudScriptVersionsRequest() :
            FPlayFabCppRequestCommon()
            {}

        FGetCloudScriptVersionsRequest(const FGetCloudScriptVersionsRequest& src) = default;

        FGetCloudScriptVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptVersionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptVersionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetCloudScriptVersionsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] List of versions
        TArray<FCloudScriptVersionStatus> Versions;
        FGetCloudScriptVersionsResult() :
            FPlayFabCppResultCommon(),
            Versions()
            {}

        FGetCloudScriptVersionsResult(const FGetCloudScriptVersionsResult& src) = default;

        FGetCloudScriptVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptVersionsResult()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptVersionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContentListRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] Limits the response to keys that begin with the specified prefix. You can use prefixes to list contents under a folder,
         * or for a specified version, etc.
         */
        FString Prefix;

        FGetContentListRequest() :
            FPlayFabCppRequestCommon(),
            Prefix()
            {}

        FGetContentListRequest(const FGetContentListRequest& src) = default;

        FGetContentListRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentListRequest()
        {
            readFromValue(obj);
        }

        ~FGetContentListRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContentListResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] List of content items.
        TArray<FContentInfo> Contents;
        // Number of content items returned. We currently have a maximum of 1000 items limit.
        int32 ItemCount;

        // The total size of listed contents in bytes.
        uint32 TotalSize;

        FGetContentListResult() :
            FPlayFabCppResultCommon(),
            Contents(),
            ItemCount(0),
            TotalSize(0)
            {}

        FGetContentListResult(const FGetContentListResult& src) = default;

        FGetContentListResult(const TSharedPtr<FJsonObject>& obj) : FGetContentListResult()
        {
            readFromValue(obj);
        }

        ~FGetContentListResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContentUploadUrlRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] A standard MIME type describing the format of the contents. The same MIME type has to be set in the header when
         * uploading the content. If not specified, the MIME type is 'binary/octet-stream' by default.
         */
        FString ContentType;

        // Key of the content item to upload, usually formatted as a path, e.g. images/a.png
        FString Key;

        FGetContentUploadUrlRequest() :
            FPlayFabCppRequestCommon(),
            ContentType(),
            Key()
            {}

        FGetContentUploadUrlRequest(const FGetContentUploadUrlRequest& src) = default;

        FGetContentUploadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentUploadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetContentUploadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContentUploadUrlResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] URL for uploading content via HTTP PUT method. The URL requires the 'x-ms-blob-type' header to have the value
         * 'BlockBlob'. The URL will expire in approximately one hour.
         */
        FString URL;

        FGetContentUploadUrlResult() :
            FPlayFabCppResultCommon(),
            URL()
            {}

        FGetContentUploadUrlResult(const FGetContentUploadUrlResult& src) = default;

        FGetContentUploadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentUploadUrlResult()
        {
            readFromValue(obj);
        }

        ~FGetContentUploadUrlResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetDataReportRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Reporting year (UTC)
        int32 Day;

        // Reporting month (UTC)
        int32 Month;

        // Report name
        FString ReportName;

        // Reporting year (UTC)
        int32 Year;

        FGetDataReportRequest() :
            FPlayFabCppRequestCommon(),
            Day(0),
            Month(0),
            ReportName(),
            Year(0)
            {}

        FGetDataReportRequest(const FGetDataReportRequest& src) = default;

        FGetDataReportRequest(const TSharedPtr<FJsonObject>& obj) : FGetDataReportRequest()
        {
            readFromValue(obj);
        }

        ~FGetDataReportRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetDataReportResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] The URL where the requested report can be downloaded. This can be any PlayFab generated reports. The full list of
         * reports can be found at: https://docs.microsoft.com/en-us/gaming/playfab/features/analytics/reports/quickstart.
         */
        FString DownloadUrl;

        FGetDataReportResult() :
            FPlayFabCppResultCommon(),
            DownloadUrl()
            {}

        FGetDataReportResult(const FGetDataReportResult& src) = default;

        FGetDataReportResult(const TSharedPtr<FJsonObject>& obj) : FGetDataReportResult()
        {
            readFromValue(obj);
        }

        ~FGetDataReportResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchmakerGameInfoRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // unique identifier of the lobby for which info is being requested
        FString LobbyId;

        FGetMatchmakerGameInfoRequest() :
            FPlayFabCppRequestCommon(),
            LobbyId()
            {}

        FGetMatchmakerGameInfoRequest(const FGetMatchmakerGameInfoRequest& src) = default;

        FGetMatchmakerGameInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchmakerGameInfoResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] version identifier of the game server executable binary being run
        FString BuildVersion;

        // [optional] time when Game Server Instance is currently scheduled to end
        Boxed<FDateTime> EndTime;

        // [optional] unique identifier of the lobby
        FString LobbyId;

        // [optional] game mode for this Game Server Instance
        FString Mode;

        // [optional] array of unique PlayFab identifiers for users currently connected to this Game Server Instance
        TArray<FString> Players;
        // [optional] region in which the Game Server Instance is running
        Boxed<Region> pfRegion;

        // [optional] IPV4 address of the server
        FString ServerIPV4Address;

        // [optional] IPV6 address of the server
        FString ServerIPV6Address;

        // communication port for this Game Server Instance
        uint32 ServerPort;

        // [optional] Public DNS name (if any) of the server
        FString ServerPublicDNSName;

        // time when the Game Server Instance was created
        FDateTime StartTime;

        // [optional] unique identifier of the Game Server Instance for this lobby
        FString TitleId;

        FGetMatchmakerGameInfoResult() :
            FPlayFabCppResultCommon(),
            BuildVersion(),
            EndTime(),
            LobbyId(),
            Mode(),
            Players(),
            pfRegion(),
            ServerIPV4Address(),
            ServerIPV6Address(),
            ServerPort(0),
            ServerPublicDNSName(),
            StartTime(0),
            TitleId()
            {}

        FGetMatchmakerGameInfoResult(const FGetMatchmakerGameInfoResult& src) = default;

        FGetMatchmakerGameInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchmakerGameModesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // previously uploaded build version for which game modes are being requested
        FString BuildVersion;

        FGetMatchmakerGameModesRequest() :
            FPlayFabCppRequestCommon(),
            BuildVersion()
            {}

        FGetMatchmakerGameModesRequest(const FGetMatchmakerGameModesRequest& src) = default;

        FGetMatchmakerGameModesRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameModesRequest()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameModesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchmakerGameModesResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] array of game modes available for the specified build
        TArray<FGameModeInfo> GameModes;
        FGetMatchmakerGameModesResult() :
            FPlayFabCppResultCommon(),
            GameModes()
            {}

        FGetMatchmakerGameModesResult(const FGetMatchmakerGameModesResult& src) = default;

        FGetMatchmakerGameModesResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameModesResult()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameModesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayedTitleListRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayedTitleListRequest() :
            FPlayFabCppRequestCommon(),
            PlayFabId()
            {}

        FGetPlayedTitleListRequest(const FGetPlayedTitleListRequest& src) = default;

        FGetPlayedTitleListRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayedTitleListRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayedTitleListRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayedTitleListResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] List of titles the player has played
        TArray<FString> TitleIds;
        FGetPlayedTitleListResult() :
            FPlayFabCppResultCommon(),
            TitleIds()
            {}

        FGetPlayedTitleListResult(const FGetPlayedTitleListResult& src) = default;

        FGetPlayedTitleListResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayedTitleListResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayedTitleListResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerIdFromAuthTokenRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The auth token of the player requesting the password reset.
        FString Token;

        // The type of auth token of the player requesting the password reset.
        AuthTokenType TokenType;

        FGetPlayerIdFromAuthTokenRequest() :
            FPlayFabCppRequestCommon(),
            Token(),
            TokenType()
            {}

        FGetPlayerIdFromAuthTokenRequest(const FGetPlayerIdFromAuthTokenRequest& src) = default;

        FGetPlayerIdFromAuthTokenRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerIdFromAuthTokenRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerIdFromAuthTokenRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerIdFromAuthTokenResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The player ID from the token passed in
        FString PlayFabId;

        FGetPlayerIdFromAuthTokenResult() :
            FPlayFabCppResultCommon(),
            PlayFabId()
            {}

        FGetPlayerIdFromAuthTokenResult(const FGetPlayerIdFromAuthTokenResult& src) = default;

        FGetPlayerIdFromAuthTokenResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerIdFromAuthTokenResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerIdFromAuthTokenResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerProfileViewConstraints : public PlayFab::FPlayFabCppBaseModel
    {
        // Whether to show player's avatar URL. Defaults to false
        bool ShowAvatarUrl;

        // Whether to show the banned until time. Defaults to false
        bool ShowBannedUntil;

        // Whether to show campaign attributions. Defaults to false
        bool ShowCampaignAttributions;

        // Whether to show contact email addresses. Defaults to false
        bool ShowContactEmailAddresses;

        // Whether to show the created date. Defaults to false
        bool ShowCreated;

        // Whether to show the display name. Defaults to false
        bool ShowDisplayName;

        // Whether to show player's experiment variants. Defaults to false
        bool ShowExperimentVariants;

        // Whether to show the last login time. Defaults to false
        bool ShowLastLogin;

        // Whether to show the linked accounts. Defaults to false
        bool ShowLinkedAccounts;

        // Whether to show player's locations. Defaults to false
        bool ShowLocations;

        // Whether to show player's membership information. Defaults to false
        bool ShowMemberships;

        // Whether to show origination. Defaults to false
        bool ShowOrigination;

        // Whether to show push notification registrations. Defaults to false
        bool ShowPushNotificationRegistrations;

        // Reserved for future development
        bool ShowStatistics;

        // Whether to show tags. Defaults to false
        bool ShowTags;

        // Whether to show the total value to date in usd. Defaults to false
        bool ShowTotalValueToDateInUsd;

        // Whether to show the values to date. Defaults to false
        bool ShowValuesToDate;

        FPlayerProfileViewConstraints() :
            FPlayFabCppBaseModel(),
            ShowAvatarUrl(false),
            ShowBannedUntil(false),
            ShowCampaignAttributions(false),
            ShowContactEmailAddresses(false),
            ShowCreated(false),
            ShowDisplayName(false),
            ShowExperimentVariants(false),
            ShowLastLogin(false),
            ShowLinkedAccounts(false),
            ShowLocations(false),
            ShowMemberships(false),
            ShowOrigination(false),
            ShowPushNotificationRegistrations(false),
            ShowStatistics(false),
            ShowTags(false),
            ShowTotalValueToDateInUsd(false),
            ShowValuesToDate(false)
            {}

        FPlayerProfileViewConstraints(const FPlayerProfileViewConstraints& src) = default;

        FPlayerProfileViewConstraints(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileViewConstraints()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileViewConstraints();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerProfileRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        FGetPlayerProfileRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PlayFabId(),
            ProfileConstraints(nullptr)
            {}

        FGetPlayerProfileRequest(const FGetPlayerProfileRequest& src) = default;

        FGetPlayerProfileRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum LoginIdentityProvider
    {
        LoginIdentityProviderUnknown,
        LoginIdentityProviderPlayFab,
        LoginIdentityProviderCustom,
        LoginIdentityProviderGameCenter,
        LoginIdentityProviderGooglePlay,
        LoginIdentityProviderSteam,
        LoginIdentityProviderXBoxLive,
        LoginIdentityProviderPSN,
        LoginIdentityProviderKongregate,
        LoginIdentityProviderFacebook,
        LoginIdentityProviderIOSDevice,
        LoginIdentityProviderAndroidDevice,
        LoginIdentityProviderTwitch,
        LoginIdentityProviderWindowsHello,
        LoginIdentityProviderGameServer,
        LoginIdentityProviderCustomServer,
        LoginIdentityProviderNintendoSwitch,
        LoginIdentityProviderFacebookInstantGames,
        LoginIdentityProviderOpenIdConnect,
        LoginIdentityProviderApple,
        LoginIdentityProviderNintendoSwitchAccount
    };

    PLAYFABCPP_API void writeLoginIdentityProviderEnumJSON(LoginIdentityProvider enumVal, JsonWriter& writer);
    PLAYFABCPP_API LoginIdentityProvider readLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API LoginIdentityProvider readLoginIdentityProviderFromValue(const FString& value);

    struct PLAYFABCPP_API FLinkedPlatformAccountModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Linked account email of the user on the platform, if available
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Unique account identifier of the user on the platform
        FString PlatformUserId;

        // [optional] Linked account username of the user on the platform, if available
        FString Username;

        FLinkedPlatformAccountModel() :
            FPlayFabCppBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FLinkedPlatformAccountModel(const FLinkedPlatformAccountModel& src) = default;

        FLinkedPlatformAccountModel(const TSharedPtr<FJsonObject>& obj) : FLinkedPlatformAccountModel()
        {
            readFromValue(obj);
        }

        ~FLinkedPlatformAccountModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLocationModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] City name.
        FString City;

        // [optional] The two-character continent code for this location
        Boxed<ContinentCode> pfContinentCode;

        // [optional] The two-character ISO 3166-1 country code for the country associated with the location
        Boxed<CountryCode> pfCountryCode;

        // [optional] Latitude coordinate of the geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the geographic location.
        Boxed<double> Longitude;

        FLocationModel() :
            FPlayFabCppBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FLocationModel(const FLocationModel& src) = default;

        FLocationModel(const TSharedPtr<FJsonObject>& obj) : FLocationModel()
        {
            readFromValue(obj);
        }

        ~FLocationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SubscriptionProviderStatus
    {
        SubscriptionProviderStatusNoError,
        SubscriptionProviderStatusCancelled,
        SubscriptionProviderStatusUnknownError,
        SubscriptionProviderStatusBillingError,
        SubscriptionProviderStatusProductUnavailable,
        SubscriptionProviderStatusCustomerDidNotAcceptPriceChange,
        SubscriptionProviderStatusFreeTrial,
        SubscriptionProviderStatusPaymentPending
    };

    PLAYFABCPP_API void writeSubscriptionProviderStatusEnumJSON(SubscriptionProviderStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FSubscriptionModel : public PlayFab::FPlayFabCppBaseModel
    {
        // When this subscription expires.
        FDateTime Expiration;

        // The time the subscription was orignially purchased
        FDateTime InitialSubscriptionTime;

        // Whether this subscription is currently active. That is, if Expiration > now.
        bool IsActive;

        // [optional] The status of this subscription, according to the subscription provider.
        Boxed<SubscriptionProviderStatus> Status;

        // [optional] The id for this subscription
        FString SubscriptionId;

        // [optional] The item id for this subscription from the primary catalog
        FString SubscriptionItemId;

        // [optional] The provider for this subscription. Apple or Google Play are supported today.
        FString SubscriptionProvider;

        FSubscriptionModel() :
            FPlayFabCppBaseModel(),
            Expiration(0),
            InitialSubscriptionTime(0),
            IsActive(false),
            Status(),
            SubscriptionId(),
            SubscriptionItemId(),
            SubscriptionProvider()
            {}

        FSubscriptionModel(const FSubscriptionModel& src) = default;

        FSubscriptionModel(const TSharedPtr<FJsonObject>& obj) : FSubscriptionModel()
        {
            readFromValue(obj);
        }

        ~FSubscriptionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMembershipModel : public PlayFab::FPlayFabCppBaseModel
    {
        // Whether this membership is active. That is, whether the MembershipExpiration time has been reached.
        bool IsActive;

        // The time this membership expires
        FDateTime MembershipExpiration;

        // [optional] The id of the membership
        FString MembershipId;

        /**
         * [optional] Membership expirations can be explicitly overridden (via game manager or the admin api). If this membership has been
         * overridden, this will be the new expiration time.
         */
        Boxed<FDateTime> OverrideExpiration;

        // [optional] Whether the override expiration is set.
        Boxed<bool> OverrideIsSet;

        // [optional] The list of subscriptions that this player has for this membership
        TArray<FSubscriptionModel> Subscriptions;
        FMembershipModel() :
            FPlayFabCppBaseModel(),
            IsActive(false),
            MembershipExpiration(0),
            MembershipId(),
            OverrideExpiration(),
            OverrideIsSet(),
            Subscriptions()
            {}

        FMembershipModel(const FMembershipModel& src) = default;

        FMembershipModel(const TSharedPtr<FJsonObject>& obj) : FMembershipModel()
        {
            readFromValue(obj);
        }

        ~FMembershipModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PushNotificationPlatform
    {
        PushNotificationPlatformApplePushNotificationService,
        PushNotificationPlatformGoogleCloudMessaging
    };

    PLAYFABCPP_API void writePushNotificationPlatformEnumJSON(PushNotificationPlatform enumVal, JsonWriter& writer);
    PLAYFABCPP_API PushNotificationPlatform readPushNotificationPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API PushNotificationPlatform readPushNotificationPlatformFromValue(const FString& value);

    struct PLAYFABCPP_API FPushNotificationRegistrationModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistrationModel() :
            FPlayFabCppBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistrationModel(const FPushNotificationRegistrationModel& src) = default;

        FPushNotificationRegistrationModel(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistrationModel()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistrationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FStatisticModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Statistic name
        FString Name;

        // Statistic value
        int32 Value;

        // Statistic version (0 if not a versioned statistic)
        int32 Version;

        FStatisticModel() :
            FPlayFabCppBaseModel(),
            Name(),
            Value(0),
            Version(0)
            {}

        FStatisticModel(const FStatisticModel& src) = default;

        FStatisticModel(const TSharedPtr<FJsonObject>& obj) : FStatisticModel()
        {
            readFromValue(obj);
        }

        ~FStatisticModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FTagModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Full value of the tag, including namespace
        FString TagValue;

        FTagModel() :
            FPlayFabCppBaseModel(),
            TagValue()
            {}

        FTagModel(const FTagModel& src) = default;

        FTagModel(const TSharedPtr<FJsonObject>& obj) : FTagModel()
        {
            readFromValue(obj);
        }

        ~FTagModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FValueToDateModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] ISO 4217 code of the currency used in the purchases
        FString Currency;

        /**
         * Total value of the purchases in a whole number of 1/100 monetary units. For example, 999 indicates nine dollars and
         * ninety-nine cents when Currency is 'USD')
         */
        uint32 TotalValue;

        /**
         * [optional] Total value of the purchases in a string representation of decimal monetary units. For example, '9.99' indicates nine
         * dollars and ninety-nine cents when Currency is 'USD'.
         */
        FString TotalValueAsDecimal;

        FValueToDateModel() :
            FPlayFabCppBaseModel(),
            Currency(),
            TotalValue(0),
            TotalValueAsDecimal()
            {}

        FValueToDateModel(const FValueToDateModel& src) = default;

        FValueToDateModel(const TSharedPtr<FJsonObject>& obj) : FValueToDateModel()
        {
            readFromValue(obj);
        }

        ~FValueToDateModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerProfileModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] List of advertising campaigns the player has been attributed to
        TArray<FAdCampaignAttributionModel> AdCampaignAttributions;
        // [optional] URL of the player's avatar image
        FString AvatarUrl;

        // [optional] If the player is currently banned, the UTC Date when the ban expires
        Boxed<FDateTime> BannedUntil;

        // [optional] List of all contact email info associated with the player account
        TArray<FContactEmailInfoModel> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player display name
        FString DisplayName;

        /**
         * [optional] List of experiment variants for the player. Note that these variants are not guaranteed to be up-to-date when returned
         * during login because the player profile is updated only after login. Instead, use the LoginResult.TreatmentAssignment
         * property during login to get the correct variants and variables.
         */
        TArray<FString> ExperimentVariants;
        // [optional] UTC time when the player most recently logged in to the title
        Boxed<FDateTime> LastLogin;

        // [optional] List of all authentication systems linked to this player account
        TArray<FLinkedPlatformAccountModel> LinkedAccounts;
        // [optional] List of geographic locations from which the player has logged in to the title
        TArray<FLocationModel> Locations;
        // [optional] List of memberships for the player, along with whether are expired.
        TArray<FMembershipModel> Memberships;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] PlayFab player account unique identifier
        FString PlayerId;

        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] List of configured end points registered for sending the player push notifications
        TArray<FPushNotificationRegistrationModel> PushNotificationRegistrations;
        // [optional] List of leaderboard statistic values for the player
        TArray<FStatisticModel> Statistics;
        // [optional] List of player's tags for segmentation
        TArray<FTagModel> Tags;
        // [optional] Title ID this player profile applies to
        FString TitleId;

        /**
         * [optional] Sum of the player's purchases made with real-money currencies, converted to US dollars equivalent and represented as a
         * whole number of cents (1/100 USD). For example, 999 indicates nine dollars and ninety-nine cents.
         */
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] List of the player's lifetime purchase totals, summed by real-money currency
        TArray<FValueToDateModel> ValuesToDate;
        FPlayerProfileModel() :
            FPlayFabCppBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            ExperimentVariants(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Memberships(),
            Origination(),
            PlayerId(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate()
            {}

        FPlayerProfileModel(const FPlayerProfileModel& src) = default;

        FPlayerProfileModel(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileModel()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerProfileResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] The profile of the player. This profile is not guaranteed to be up-to-date. For a new player, this profile will not
         * exist.
         */
        TSharedPtr<FPlayerProfileModel> PlayerProfile;

        FGetPlayerProfileResult() :
            FPlayFabCppResultCommon(),
            PlayerProfile(nullptr)
            {}

        FGetPlayerProfileResult(const FGetPlayerProfileResult& src) = default;

        FGetPlayerProfileResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerSegmentsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Array of segments the requested player currently belongs to.
        TArray<FGetSegmentResult> Segments;
        FGetPlayerSegmentsResult() :
            FPlayFabCppResultCommon(),
            Segments()
            {}

        FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) = default;

        FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerSharedSecretsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FGetPlayerSharedSecretsRequest() :
            FPlayFabCppRequestCommon()
            {}

        FGetPlayerSharedSecretsRequest(const FGetPlayerSharedSecretsRequest& src) = default;

        FGetPlayerSharedSecretsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSharedSecretsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSharedSecretsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSharedSecret : public PlayFab::FPlayFabCppBaseModel
    {
        // Flag to indicate if this key is disabled
        bool Disabled;

        // [optional] Friendly name for this key
        FString FriendlyName;

        // [optional] The player shared secret to use when calling Client/GetTitlePublicKey
        FString SecretKey;

        FSharedSecret() :
            FPlayFabCppBaseModel(),
            Disabled(false),
            FriendlyName(),
            SecretKey()
            {}

        FSharedSecret(const FSharedSecret& src) = default;

        FSharedSecret(const TSharedPtr<FJsonObject>& obj) : FSharedSecret()
        {
            readFromValue(obj);
        }

        ~FSharedSecret();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerSharedSecretsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The player shared secret to use when calling Client/GetTitlePublicKey
        TArray<FSharedSecret> SharedSecrets;
        FGetPlayerSharedSecretsResult() :
            FPlayFabCppResultCommon(),
            SharedSecrets()
            {}

        FGetPlayerSharedSecretsResult(const FGetPlayerSharedSecretsResult& src) = default;

        FGetPlayerSharedSecretsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSharedSecretsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSharedSecretsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayersInSegmentRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Continuation token if retrieving subsequent pages of results.
        FString ContinuationToken;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Maximum number of profiles to load. Default is 1,000. Maximum is 10,000.
        Boxed<uint32> MaxBatchSize;

        /**
         * [optional] Number of seconds to keep the continuation token active. After token expiration it is not possible to continue paging
         * results. Default is 300 (5 minutes). Maximum is 1,800 (30 minutes).
         */
        Boxed<uint32> SecondsToLive;

        // Unique identifier for this segment.
        FString SegmentId;

        FGetPlayersInSegmentRequest() :
            FPlayFabCppRequestCommon(),
            ContinuationToken(),
            CustomTags(),
            MaxBatchSize(),
            SecondsToLive(),
            SegmentId()
            {}

        FGetPlayersInSegmentRequest(const FGetPlayersInSegmentRequest& src) = default;

        FGetPlayersInSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayersInSegmentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerLinkedAccount : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Linked account's email
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Platform user identifier
        FString PlatformUserId;

        // [optional] Linked account's username
        FString Username;

        FPlayerLinkedAccount() :
            FPlayFabCppBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FPlayerLinkedAccount(const FPlayerLinkedAccount& src) = default;

        FPlayerLinkedAccount(const TSharedPtr<FJsonObject>& obj) : FPlayerLinkedAccount()
        {
            readFromValue(obj);
        }

        ~FPlayerLinkedAccount();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerLocation : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] City of the player's geographic location.
        FString City;

        // The two-character continent code for this location
        ContinentCode pfContinentCode;

        // The two-character ISO 3166-1 country code for the country associated with the location
        CountryCode pfCountryCode;

        // [optional] Latitude coordinate of the player's geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the player's geographic location.
        Boxed<double> Longitude;

        FPlayerLocation() :
            FPlayFabCppBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FPlayerLocation(const FPlayerLocation& src) = default;

        FPlayerLocation(const TSharedPtr<FJsonObject>& obj) : FPlayerLocation()
        {
            readFromValue(obj);
        }

        ~FPlayerLocation();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerStatistic : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Statistic ID
        FString Id;

        // [optional] Statistic name
        FString Name;

        // Current statistic value
        int32 StatisticValue;

        // Statistic version (0 if not a versioned statistic)
        int32 StatisticVersion;

        FPlayerStatistic() :
            FPlayFabCppBaseModel(),
            Id(),
            Name(),
            StatisticValue(0),
            StatisticVersion(0)
            {}

        FPlayerStatistic(const FPlayerStatistic& src) = default;

        FPlayerStatistic(const TSharedPtr<FJsonObject>& obj) : FPlayerStatistic()
        {
            readFromValue(obj);
        }

        ~FPlayerStatistic();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPushNotificationRegistration : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistration() :
            FPlayFabCppBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistration(const FPushNotificationRegistration& src) = default;

        FPushNotificationRegistration(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistration()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPlayerProfile : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Array of ad campaigns player has been attributed to
        TArray<FAdCampaignAttribution> AdCampaignAttributions;
        // [optional] Image URL of the player's avatar.
        FString AvatarUrl;

        // [optional] Banned until UTC Date. If permanent ban this is set for 20 years after the original ban date.
        Boxed<FDateTime> BannedUntil;

        // [optional] Array of contact email addresses associated with the player
        TArray<FContactEmailInfo> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player Display Name
        FString DisplayName;

        // [optional] Last login
        Boxed<FDateTime> LastLogin;

        // [optional] Array of third party accounts linked to this player
        TArray<FPlayerLinkedAccount> LinkedAccounts;
        // [optional] Dictionary of player's locations by type.
        TMap<FString, FPlayerLocation> Locations;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] List of player variants for experimentation
        TArray<FString> PlayerExperimentVariants;
        // [optional] PlayFab Player ID
        FString PlayerId;

        // [optional] Array of player statistics
        TArray<FPlayerStatistic> PlayerStatistics;
        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] Array of configured push notification end points
        TArray<FPushNotificationRegistration> PushNotificationRegistrations;
        // [optional] Dictionary of player's statistics using only the latest version's value
        TMap<FString, int32> Statistics;
        // [optional] List of player's tags for segmentation.
        TArray<FString> Tags;
        // [optional] Title ID this profile applies to
        FString TitleId;

        // [optional] A sum of player's total purchases in USD across all currencies.
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] Dictionary of player's total purchases by currency.
        TMap<FString, uint32> ValuesToDate;
        // [optional] Dictionary of player's virtual currency balances
        TMap<FString, int32> VirtualCurrencyBalances;
        FPlayerProfile() :
            FPlayFabCppBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Origination(),
            PlayerExperimentVariants(),
            PlayerId(),
            PlayerStatistics(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate(),
            VirtualCurrencyBalances()
            {}

        FPlayerProfile(const FPlayerProfile& src) = default;

        FPlayerProfile(const TSharedPtr<FJsonObject>& obj) : FPlayerProfile()
        {
            readFromValue(obj);
        }

        ~FPlayerProfile();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayersInSegmentResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Continuation token to use to retrieve subsequent pages of results. If token returns null there are no more results.
        FString ContinuationToken;

        // [optional] Array of player profiles in this segment.
        TArray<FPlayerProfile> PlayerProfiles;
        // Count of profiles matching this segment.
        int32 ProfilesInSegment;

        FGetPlayersInSegmentResult() :
            FPlayFabCppResultCommon(),
            ContinuationToken(),
            PlayerProfiles(),
            ProfilesInSegment(0)
            {}

        FGetPlayersInSegmentResult(const FGetPlayersInSegmentResult& src) = default;

        FGetPlayersInSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayersInSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayersSegmentsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayersSegmentsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PlayFabId()
            {}

        FGetPlayersSegmentsRequest(const FGetPlayersSegmentsRequest& src) = default;

        FGetPlayersSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayersSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerStatisticDefinitionsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FGetPlayerStatisticDefinitionsRequest() :
            FPlayFabCppRequestCommon()
            {}

        FGetPlayerStatisticDefinitionsRequest(const FGetPlayerStatisticDefinitionsRequest& src) = default;

        FGetPlayerStatisticDefinitionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticDefinitionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticDefinitionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerStatisticDefinitionsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] the player statistic definitions for the title
        TArray<FPlayerStatisticDefinition> Statistics;
        FGetPlayerStatisticDefinitionsResult() :
            FPlayFabCppResultCommon(),
            Statistics()
            {}

        FGetPlayerStatisticDefinitionsResult(const FGetPlayerStatisticDefinitionsResult& src) = default;

        FGetPlayerStatisticDefinitionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticDefinitionsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticDefinitionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerStatisticVersionsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] unique name of the statistic
        FString StatisticName;

        FGetPlayerStatisticVersionsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            StatisticName()
            {}

        FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) = default;

        FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum StatisticVersionStatus
    {
        StatisticVersionStatusActive,
        StatisticVersionStatusSnapshotPending,
        StatisticVersionStatusSnapshot,
        StatisticVersionStatusArchivalPending,
        StatisticVersionStatusArchived
    };

    PLAYFABCPP_API void writeStatisticVersionStatusEnumJSON(StatisticVersionStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API StatisticVersionStatus readStatisticVersionStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API StatisticVersionStatus readStatisticVersionStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FPlayerStatisticVersion : public PlayFab::FPlayFabCppBaseModel
    {
        // time when the statistic version became active
        FDateTime ActivationTime;

        // [optional] URL for the downloadable archive of player statistic values, if available
        FString ArchiveDownloadUrl;

        // [optional] time when the statistic version became inactive due to statistic version incrementing
        Boxed<FDateTime> DeactivationTime;

        // [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledActivationTime;

        // [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledDeactivationTime;

        // [optional] name of the statistic when the version became active
        FString StatisticName;

        // [optional] status of the statistic version
        Boxed<StatisticVersionStatus> Status;

        // version of the statistic
        uint32 Version;

        FPlayerStatisticVersion() :
            FPlayFabCppBaseModel(),
            ActivationTime(0),
            ArchiveDownloadUrl(),
            DeactivationTime(),
            ScheduledActivationTime(),
            ScheduledDeactivationTime(),
            StatisticName(),
            Status(),
            Version(0)
            {}

        FPlayerStatisticVersion(const FPlayerStatisticVersion& src) = default;

        FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }

        ~FPlayerStatisticVersion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerStatisticVersionsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] version change history of the statistic
        TArray<FPlayerStatisticVersion> StatisticVersions;
        FGetPlayerStatisticVersionsResult() :
            FPlayFabCppResultCommon(),
            StatisticVersions()
            {}

        FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) = default;

        FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerTagsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Optional namespace to filter results by
        FString Namespace;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayerTagsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Namespace(),
            PlayFabId()
            {}

        FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) = default;

        FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPlayerTagsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Canonical tags (including namespace and tag's name) for the requested user
        TArray<FString> Tags;
        FGetPlayerTagsResult() :
            FPlayFabCppResultCommon(),
            PlayFabId(),
            Tags()
            {}

        FGetPlayerTagsResult(const FGetPlayerTagsResult& src) = default;

        FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPolicyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The name of the policy to read. Only supported name is 'ApiPolicy'.
        FString PolicyName;

        FGetPolicyRequest() :
            FPlayFabCppRequestCommon(),
            PolicyName()
            {}

        FGetPolicyRequest(const FGetPolicyRequest& src) = default;

        FGetPolicyRequest(const TSharedPtr<FJsonObject>& obj) : FGetPolicyRequest()
        {
            readFromValue(obj);
        }

        ~FGetPolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPermissionStatement : public PlayFab::FPlayFabCppBaseModel
    {
        // The action this statement effects. The only supported action is 'Execute'.
        FString Action;

        // [optional] Additional conditions to be applied for API Resources.
        TSharedPtr<FApiCondition> ApiConditions;

        // [optional] A comment about the statement. Intended solely for bookkeeping and debugging.
        FString Comment;

        // The effect this statement will have. It could be either Allow or Deny
        EffectType Effect;

        // The principal this statement will effect. The only supported principal is '*'.
        FString Principal;

        /**
         * The resource this statements effects. The only supported resources look like 'pfrn:api--*' for all apis, or
         * 'pfrn:api--/Client/ConfirmPurchase' for specific apis.
         */
        FString Resource;

        FPermissionStatement() :
            FPlayFabCppBaseModel(),
            Action(),
            ApiConditions(nullptr),
            Comment(),
            Effect(),
            Principal(),
            Resource()
            {}

        FPermissionStatement(const FPermissionStatement& src) = default;

        FPermissionStatement(const TSharedPtr<FJsonObject>& obj) : FPermissionStatement()
        {
            readFromValue(obj);
        }

        ~FPermissionStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPolicyResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The name of the policy read.
        FString PolicyName;

        // Policy version.
        int32 PolicyVersion;

        // [optional] The statements in the requested policy.
        TArray<FPermissionStatement> Statements;
        FGetPolicyResponse() :
            FPlayFabCppResultCommon(),
            PolicyName(),
            PolicyVersion(0),
            Statements()
            {}

        FGetPolicyResponse(const FGetPolicyResponse& src) = default;

        FGetPolicyResponse(const TSharedPtr<FJsonObject>& obj) : FGetPolicyResponse()
        {
            readFromValue(obj);
        }

        ~FGetPolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPublisherDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // array of keys to get back data from the Publisher data blob, set by the admin tools
        TArray<FString> Keys;
        FGetPublisherDataRequest() :
            FPlayFabCppRequestCommon(),
            Keys()
            {}

        FGetPublisherDataRequest(const FGetPublisherDataRequest& src) = default;

        FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetPublisherDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetPublisherDataResult() :
            FPlayFabCppResultCommon(),
            Data()
            {}

        FGetPublisherDataResult(const FGetPublisherDataResult& src) = default;

        FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetRandomResultTablesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] catalog version to fetch tables from. Use default catalog version if null
        FString CatalogVersion;

        FGetRandomResultTablesRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion()
            {}

        FGetRandomResultTablesRequest(const FGetRandomResultTablesRequest& src) = default;

        FGetRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesRequest()
        {
            readFromValue(obj);
        }

        ~FGetRandomResultTablesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ResultTableNodeType
    {
        ResultTableNodeTypeItemId,
        ResultTableNodeTypeTableId
    };

    PLAYFABCPP_API void writeResultTableNodeTypeEnumJSON(ResultTableNodeType enumVal, JsonWriter& writer);
    PLAYFABCPP_API ResultTableNodeType readResultTableNodeTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ResultTableNodeType readResultTableNodeTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FResultTableNode : public PlayFab::FPlayFabCppBaseModel
    {
        // Either an ItemId, or the TableId of another random result table
        FString ResultItem;

        // Whether this entry in the table is an item or a link to another table
        ResultTableNodeType ResultItemType;

        // How likely this is to be rolled - larger numbers add more weight
        int32 Weight;

        FResultTableNode() :
            FPlayFabCppBaseModel(),
            ResultItem(),
            ResultItemType(),
            Weight(0)
            {}

        FResultTableNode(const FResultTableNode& src) = default;

        FResultTableNode(const TSharedPtr<FJsonObject>& obj) : FResultTableNode()
        {
            readFromValue(obj);
        }

        ~FResultTableNode();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRandomResultTableListing : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Catalog version this table is associated with
        FString CatalogVersion;

        // Child nodes that indicate what kind of drop table item this actually is.
        TArray<FResultTableNode> Nodes;
        // Unique name for this drop table
        FString TableId;

        FRandomResultTableListing() :
            FPlayFabCppBaseModel(),
            CatalogVersion(),
            Nodes(),
            TableId()
            {}

        FRandomResultTableListing(const FRandomResultTableListing& src) = default;

        FRandomResultTableListing(const TSharedPtr<FJsonObject>& obj) : FRandomResultTableListing()
        {
            readFromValue(obj);
        }

        ~FRandomResultTableListing();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetRandomResultTablesResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] array of random result tables currently available
        TMap<FString, FRandomResultTableListing> Tables;
        FGetRandomResultTablesResult() :
            FPlayFabCppResultCommon(),
            Tables()
            {}

        FGetRandomResultTablesResult(const FGetRandomResultTablesResult& src) = default;

        FGetRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesResult()
        {
            readFromValue(obj);
        }

        ~FGetRandomResultTablesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetSegmentsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Segment ids to filter title segments.
        TArray<FString> SegmentIds;
        FGetSegmentsRequest() :
            FPlayFabCppRequestCommon(),
            SegmentIds()
            {}

        FGetSegmentsRequest(const FGetSegmentsRequest& src) = default;

        FGetSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetSegmentsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Error message.
        FString ErrorMessage;

        // [optional] List of title segments.
        TArray<FSegmentModel> Segments;
        FGetSegmentsResponse() :
            FPlayFabCppResultCommon(),
            ErrorMessage(),
            Segments()
            {}

        FGetSegmentsResponse(const FGetSegmentsResponse& src) = default;

        FGetSegmentsResponse(const TSharedPtr<FJsonObject>& obj) : FGetSegmentsResponse()
        {
            readFromValue(obj);
        }

        ~FGetSegmentsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetServerBuildInfoRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // unique identifier of the previously uploaded build executable for which information is being requested
        FString BuildId;

        FGetServerBuildInfoRequest() :
            FPlayFabCppRequestCommon(),
            BuildId()
            {}

        FGetServerBuildInfoRequest(const FGetServerBuildInfoRequest& src) = default;

        FGetServerBuildInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetServerBuildInfoResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // [optional] unique identifier for this build executable
        FString BuildId;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] error message, if any, about this build
        FString ErrorMessage;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] the current status of the build validation and processing steps
        Boxed<GameBuildStatus> Status;

        // time this build was last modified (or uploaded, if this build has never been modified)
        FDateTime Timestamp;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FGetServerBuildInfoResult() :
            FPlayFabCppResultCommon(),
            ActiveRegions(),
            BuildId(),
            Comment(),
            ErrorMessage(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Status(),
            Timestamp(0),
            TitleId()
            {}

        FGetServerBuildInfoResult(const FGetServerBuildInfoResult& src) = default;

        FGetServerBuildInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetServerBuildUploadURLRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // unique identifier of the game server build to upload
        FString BuildId;

        FGetServerBuildUploadURLRequest() :
            FPlayFabCppRequestCommon(),
            BuildId()
            {}

        FGetServerBuildUploadURLRequest(const FGetServerBuildUploadURLRequest& src) = default;

        FGetServerBuildUploadURLRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildUploadURLRequest()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildUploadURLRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetServerBuildUploadURLResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] pre-authorized URL for uploading the game server build package
        FString URL;

        FGetServerBuildUploadURLResult() :
            FPlayFabCppResultCommon(),
            URL()
            {}

        FGetServerBuildUploadURLResult(const FGetServerBuildUploadURLResult& src) = default;

        FGetServerBuildUploadURLResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildUploadURLResult()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildUploadURLResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetStoreItemsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Catalog version to store items from. Use default catalog version if null
        FString CatalogVersion;

        // Unqiue identifier for the store which is being requested.
        FString StoreId;

        FGetStoreItemsRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion(),
            StoreId()
            {}

        FGetStoreItemsRequest(const FGetStoreItemsRequest& src) = default;

        FGetStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetStoreItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FStoreMarketingModel : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Tagline for a store.
        FString Description;

        // [optional] Display name of a store as it will appear to users.
        FString DisplayName;

        // [optional] Custom data about a store.
        FJsonKeeper Metadata;

        FStoreMarketingModel() :
            FPlayFabCppBaseModel(),
            Description(),
            DisplayName(),
            Metadata()
            {}

        FStoreMarketingModel(const FStoreMarketingModel& src) = default;

        FStoreMarketingModel(const TSharedPtr<FJsonObject>& obj) : FStoreMarketingModel()
        {
            readFromValue(obj);
        }

        ~FStoreMarketingModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SourceType
    {
        SourceTypeAdmin,
        SourceTypeBackEnd,
        SourceTypeGameClient,
        SourceTypeGameServer,
        SourceTypePartner,
        SourceTypeCustom,
        SourceTypeAPI
    };

    PLAYFABCPP_API void writeSourceTypeEnumJSON(SourceType enumVal, JsonWriter& writer);
    PLAYFABCPP_API SourceType readSourceTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SourceType readSourceTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FStoreItem : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Store specific custom data. The data only exists as part of this store; it is not transferred to item instances
        FJsonKeeper CustomData;

        // [optional] Intended display position for this item. Note that 0 is the first position
        Boxed<uint32> DisplayPosition;

        /**
         * Unique identifier of the item as it exists in the catalog - note that this must exactly match the ItemId from the
         * catalog
         */
        FString ItemId;

        // [optional] Override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] Override prices for this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FStoreItem() :
            FPlayFabCppBaseModel(),
            CustomData(),
            DisplayPosition(),
            ItemId(),
            RealCurrencyPrices(),
            VirtualCurrencyPrices()
            {}

        FStoreItem(const FStoreItem& src) = default;

        FStoreItem(const TSharedPtr<FJsonObject>& obj) : FStoreItem()
        {
            readFromValue(obj);
        }

        ~FStoreItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetStoreItemsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The base catalog that this store is a part of.
        FString CatalogVersion;

        // [optional] Additional data about the store.
        TSharedPtr<FStoreMarketingModel> MarketingData;

        // [optional] How the store was last updated (Admin or a third party).
        Boxed<SourceType> Source;

        // [optional] Array of items which can be purchased from this store.
        TArray<FStoreItem> Store;
        // [optional] The ID of this store.
        FString StoreId;

        FGetStoreItemsResult() :
            FPlayFabCppResultCommon(),
            CatalogVersion(),
            MarketingData(nullptr),
            Source(),
            Store(),
            StoreId()
            {}

        FGetStoreItemsResult(const FGetStoreItemsResult& src) = default;

        FGetStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetStoreItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTaskInstanceRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // ID of the requested task instance.
        FString TaskInstanceId;

        FGetTaskInstanceRequest() :
            FPlayFabCppRequestCommon(),
            TaskInstanceId()
            {}

        FGetTaskInstanceRequest(const FGetTaskInstanceRequest& src) = default;

        FGetTaskInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstanceRequest()
        {
            readFromValue(obj);
        }

        ~FGetTaskInstanceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTaskInstancesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Optional range-from filter for task instances' StartedAt timestamp.
        Boxed<FDateTime> StartedAtRangeFrom;

        // [optional] Optional range-to filter for task instances' StartedAt timestamp.
        Boxed<FDateTime> StartedAtRangeTo;

        // [optional] Optional filter for task instances that are of a specific status.
        Boxed<TaskInstanceStatus> StatusFilter;

        /**
         * [optional] Name or ID of the task whose instances are being queried. If not specified, return all task instances that satisfy
         * conditions set by other filters.
         */
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        FGetTaskInstancesRequest() :
            FPlayFabCppRequestCommon(),
            StartedAtRangeFrom(),
            StartedAtRangeTo(),
            StatusFilter(),
            TaskIdentifier(nullptr)
            {}

        FGetTaskInstancesRequest(const FGetTaskInstancesRequest& src) = default;

        FGetTaskInstancesRequest(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstancesRequest()
        {
            readFromValue(obj);
        }

        ~FGetTaskInstancesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ScheduledTaskType
    {
        ScheduledTaskTypeCloudScript,
        ScheduledTaskTypeActionsOnPlayerSegment,
        ScheduledTaskTypeCloudScriptAzureFunctions,
        ScheduledTaskTypeInsightsScheduledScaling
    };

    PLAYFABCPP_API void writeScheduledTaskTypeEnumJSON(ScheduledTaskType enumVal, JsonWriter& writer);
    PLAYFABCPP_API ScheduledTaskType readScheduledTaskTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ScheduledTaskType readScheduledTaskTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FTaskInstanceBasicSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] UTC timestamp when the task completed.
        Boxed<FDateTime> CompletedAt;

        // [optional] Error message for last processing attempt, if an error occured.
        FString ErrorMessage;

        // [optional] Estimated time remaining in seconds.
        Boxed<double> EstimatedSecondsRemaining;

        // [optional] Progress represented as percentage.
        Boxed<double> PercentComplete;

        // [optional] If manually scheduled, ID of user who scheduled the task.
        FString ScheduledByUserId;

        // UTC timestamp when the task started.
        FDateTime StartedAt;

        // [optional] Current status of the task instance.
        Boxed<TaskInstanceStatus> Status;

        // [optional] Identifier of the task this instance belongs to.
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        // [optional] ID of the task instance.
        FString TaskInstanceId;

        // [optional] Type of the task.
        Boxed<ScheduledTaskType> Type;

        FTaskInstanceBasicSummary() :
            FPlayFabCppBaseModel(),
            CompletedAt(),
            ErrorMessage(),
            EstimatedSecondsRemaining(),
            PercentComplete(),
            ScheduledByUserId(),
            StartedAt(0),
            Status(),
            TaskIdentifier(nullptr),
            TaskInstanceId(),
            Type()
            {}

        FTaskInstanceBasicSummary(const FTaskInstanceBasicSummary& src) = default;

        FTaskInstanceBasicSummary(const TSharedPtr<FJsonObject>& obj) : FTaskInstanceBasicSummary()
        {
            readFromValue(obj);
        }

        ~FTaskInstanceBasicSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTaskInstancesResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] Basic status summaries of the queried task instances. Empty If no task instances meets the filter criteria. To get
         * detailed status summary, use Get*TaskInstance API according to task type (e.g.
         * GetActionsOnPlayersInSegmentTaskInstance).
         */
        TArray<FTaskInstanceBasicSummary> Summaries;
        FGetTaskInstancesResult() :
            FPlayFabCppResultCommon(),
            Summaries()
            {}

        FGetTaskInstancesResult(const FGetTaskInstancesResult& src) = default;

        FGetTaskInstancesResult(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstancesResult()
        {
            readFromValue(obj);
        }

        ~FGetTaskInstancesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTasksRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Provide either the task ID or the task name to get a specific task. If not specified, return all defined tasks.
        TSharedPtr<FNameIdentifier> Identifier;

        FGetTasksRequest() :
            FPlayFabCppRequestCommon(),
            Identifier(nullptr)
            {}

        FGetTasksRequest(const FGetTasksRequest& src) = default;

        FGetTasksRequest(const TSharedPtr<FJsonObject>& obj) : FGetTasksRequest()
        {
            readFromValue(obj);
        }

        ~FGetTasksRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FScheduledTask : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // [optional] UTC time of last run
        Boxed<FDateTime> LastRunTime;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // [optional] UTC time of next run
        Boxed<FDateTime> NextRunTime;

        /**
         * [optional] Task parameter. Different types of task have different parameter structure. See each task type's create API
         * documentation for the details.
         */
        FJsonKeeper Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        // [optional] ID of the task
        FString TaskId;

        // [optional] Task type.
        Boxed<ScheduledTaskType> Type;

        FScheduledTask() :
            FPlayFabCppBaseModel(),
            Description(),
            IsActive(false),
            LastRunTime(),
            Name(),
            NextRunTime(),
            Parameter(),
            Schedule(),
            TaskId(),
            Type()
            {}

        FScheduledTask(const FScheduledTask& src) = default;

        FScheduledTask(const TSharedPtr<FJsonObject>& obj) : FScheduledTask()
        {
            readFromValue(obj);
        }

        ~FScheduledTask();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTasksResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Result tasks. Empty if there is no task found.
        TArray<FScheduledTask> Tasks;
        FGetTasksResult() :
            FPlayFabCppResultCommon(),
            Tasks()
            {}

        FGetTasksResult(const FGetTasksResult& src) = default;

        FGetTasksResult(const TSharedPtr<FJsonObject>& obj) : FGetTasksResult()
        {
            readFromValue(obj);
        }

        ~FGetTasksResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Specific keys to search for in the title data (leave null to get all keys)
        TArray<FString> Keys;
        /**
         * [optional] Optional field that specifies the name of an override. This value is ignored when used by the game client; otherwise,
         * the overrides are applied automatically to the title data.
         */
        FString OverrideLabel;

        FGetTitleDataRequest() :
            FPlayFabCppRequestCommon(),
            Keys(),
            OverrideLabel()
            {}

        FGetTitleDataRequest(const FGetTitleDataRequest& src) = default;

        FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetTitleDataResult() :
            FPlayFabCppResultCommon(),
            Data()
            {}

        FGetTitleDataResult(const FGetTitleDataResult& src) = default;

        FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetUserBansRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserBansRequest() :
            FPlayFabCppRequestCommon(),
            PlayFabId()
            {}

        FGetUserBansRequest(const FGetUserBansRequest& src) = default;

        FGetUserBansRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserBansRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetUserBansResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Information about the bans
        TArray<FBanInfo> BanData;
        FGetUserBansResult() :
            FPlayFabCppResultCommon(),
            BanData()
            {}

        FGetUserBansResult(const FGetUserBansResult& src) = default;

        FGetUserBansResult(const TSharedPtr<FJsonObject>& obj) : FGetUserBansResult()
        {
            readFromValue(obj);
        }

        ~FGetUserBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetUserDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the
         * version in the system is greater than this.
         */
        Boxed<uint32> IfChangedFromDataVersion;

        // [optional] Specific keys to search for in the custom user data.
        TArray<FString> Keys;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserDataRequest() :
            FPlayFabCppRequestCommon(),
            IfChangedFromDataVersion(),
            Keys(),
            PlayFabId()
            {}

        FGetUserDataRequest(const FGetUserDataRequest& src) = default;

        FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserDataPermission
    {
        UserDataPermissionPrivate,
        UserDataPermissionPublic
    };

    PLAYFABCPP_API void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
    PLAYFABCPP_API UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API UserDataPermission readUserDataPermissionFromValue(const FString& value);

    struct PLAYFABCPP_API FUserDataRecord : public PlayFab::FPlayFabCppBaseModel
    {
        // Timestamp for when this data was last updated.
        FDateTime LastUpdated;

        /**
         * [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData
         * requests being made by one player about another player.
         */
        Boxed<UserDataPermission> Permission;

        // [optional] Data stored for the specified user data key.
        FString Value;

        FUserDataRecord() :
            FPlayFabCppBaseModel(),
            LastUpdated(0),
            Permission(),
            Value()
            {}

        FUserDataRecord(const FUserDataRecord& src) = default;

        FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }

        ~FUserDataRecord();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetUserDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] User specific data for this title.
        TMap<FString, FUserDataRecord> Data;
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        // [optional] PlayFab unique identifier of the user whose custom data is being returned.
        FString PlayFabId;

        FGetUserDataResult() :
            FPlayFabCppResultCommon(),
            Data(),
            DataVersion(0),
            PlayFabId()
            {}

        FGetUserDataResult(const FGetUserDataResult& src) = default;

        FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }

        ~FGetUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetUserInventoryRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserInventoryRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PlayFabId()
            {}

        FGetUserInventoryRequest(const FGetUserInventoryRequest& src) = default;

        FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FItemInstance : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        /**
         * [optional] A set of custom key-value pairs on the instance of the inventory item, which is not to be confused with the catalog
         * item's custom data.
         */
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // [optional] Currency type for the cost of the catalog item. Not available when granting items.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency. Not available when granting items.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FItemInstance() :
            FPlayFabCppBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PurchaseDate(),
            RemainingUses(),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FItemInstance(const FItemInstance& src) = default;

        FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }

        ~FItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVirtualCurrencyRechargeTime : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value
         * through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen
         * below this value.
         */
        int32 RechargeMax;

        // Server timestamp in UTC indicating the next time the virtual currency will be incremented.
        FDateTime RechargeTime;

        // Time remaining (in seconds) before the next recharge increment of the virtual currency.
        int32 SecondsToRecharge;

        FVirtualCurrencyRechargeTime() :
            FPlayFabCppBaseModel(),
            RechargeMax(0),
            RechargeTime(0),
            SecondsToRecharge(0)
            {}

        FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) = default;

        FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyRechargeTime();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetUserInventoryResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Array of inventory items belonging to the user.
        TArray<FItemInstance> Inventory;
        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Array of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FGetUserInventoryResult() :
            FPlayFabCppResultCommon(),
            Inventory(),
            PlayFabId(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FGetUserInventoryResult(const FGetUserInventoryResult& src) = default;

        FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGrantedItemInstance : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] A set of custom key-value pairs on the instance of the inventory item, which is not to be confused with the catalog
         * item's custom data.
         */
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // Result of this operation.
        bool Result;

        // [optional] Currency type for the cost of the catalog item. Not available when granting items.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency. Not available when granting items.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FGrantedItemInstance() :
            FPlayFabCppBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CharacterId(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PlayFabId(),
            PurchaseDate(),
            RemainingUses(),
            Result(false),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FGrantedItemInstance(const FGrantedItemInstance& src) = default;

        FGrantedItemInstance(const TSharedPtr<FJsonObject>& obj) : FGrantedItemInstance()
        {
            readFromValue(obj);
        }

        ~FGrantedItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FItemGrant : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] String detailing any additional information concerning this operation.
        FString Annotation;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        // Unique identifier of the catalog item to be granted to the user.
        FString ItemId;

        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FItemGrant() :
            FPlayFabCppBaseModel(),
            Annotation(),
            CharacterId(),
            Data(),
            ItemId(),
            KeysToRemove(),
            PlayFabId()
            {}

        FItemGrant(const FItemGrant& src) = default;

        FItemGrant(const TSharedPtr<FJsonObject>& obj) : FItemGrant()
        {
            readFromValue(obj);
        }

        ~FItemGrant();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGrantItemsToUsersRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Catalog version from which items are to be granted.
        FString CatalogVersion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Array of items to grant and the users to whom the items are to be granted.
        TArray<FItemGrant> ItemGrants;
        FGrantItemsToUsersRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion(),
            CustomTags(),
            ItemGrants()
            {}

        FGrantItemsToUsersRequest(const FGrantItemsToUsersRequest& src) = default;

        FGrantItemsToUsersRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersRequest()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGrantItemsToUsersResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Array of items granted to users.
        TArray<FGrantedItemInstance> ItemGrantResults;
        FGrantItemsToUsersResult() :
            FPlayFabCppResultCommon(),
            ItemGrantResults()
            {}

        FGrantItemsToUsersResult(const FGrantItemsToUsersResult& src) = default;

        FGrantItemsToUsersResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersResult()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FIncrementLimitedEditionItemAvailabilityRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Amount to increase availability by.
        int32 Amount;

        // [optional] Which catalog is being updated. If null, uses the default catalog.
        FString CatalogVersion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The item which needs more availability.
        FString ItemId;

        FIncrementLimitedEditionItemAvailabilityRequest() :
            FPlayFabCppRequestCommon(),
            Amount(0),
            CatalogVersion(),
            CustomTags(),
            ItemId()
            {}

        FIncrementLimitedEditionItemAvailabilityRequest(const FIncrementLimitedEditionItemAvailabilityRequest& src) = default;

        FIncrementLimitedEditionItemAvailabilityRequest(const TSharedPtr<FJsonObject>& obj) : FIncrementLimitedEditionItemAvailabilityRequest()
        {
            readFromValue(obj);
        }

        ~FIncrementLimitedEditionItemAvailabilityRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FIncrementLimitedEditionItemAvailabilityResult : public PlayFab::FPlayFabCppResultCommon
    {
        FIncrementLimitedEditionItemAvailabilityResult() :
            FPlayFabCppResultCommon()
            {}

        FIncrementLimitedEditionItemAvailabilityResult(const FIncrementLimitedEditionItemAvailabilityResult& src) = default;

        FIncrementLimitedEditionItemAvailabilityResult(const TSharedPtr<FJsonObject>& obj) : FIncrementLimitedEditionItemAvailabilityResult()
        {
            readFromValue(obj);
        }

        ~FIncrementLimitedEditionItemAvailabilityResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FIncrementPlayerStatisticVersionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] unique name of the statistic
        FString StatisticName;

        FIncrementPlayerStatisticVersionRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            StatisticName()
            {}

        FIncrementPlayerStatisticVersionRequest(const FIncrementPlayerStatisticVersionRequest& src) = default;

        FIncrementPlayerStatisticVersionRequest(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticVersionRequest()
        {
            readFromValue(obj);
        }

        ~FIncrementPlayerStatisticVersionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FIncrementPlayerStatisticVersionResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] version change history of the statistic
        TSharedPtr<FPlayerStatisticVersion> StatisticVersion;

        FIncrementPlayerStatisticVersionResult() :
            FPlayFabCppResultCommon(),
            StatisticVersion(nullptr)
            {}

        FIncrementPlayerStatisticVersionResult(const FIncrementPlayerStatisticVersionResult& src) = default;

        FIncrementPlayerStatisticVersionResult(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticVersionResult()
        {
            readFromValue(obj);
        }

        ~FIncrementPlayerStatisticVersionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FListBuildsRequest() :
            FPlayFabCppRequestCommon()
            {}

        FListBuildsRequest(const FListBuildsRequest& src) = default;

        FListBuildsRequest(const TSharedPtr<FJsonObject>& obj) : FListBuildsRequest()
        {
            readFromValue(obj);
        }

        ~FListBuildsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] array of uploaded game server builds
        TArray<FGetServerBuildInfoResult> Builds;
        FListBuildsResult() :
            FPlayFabCppResultCommon(),
            Builds()
            {}

        FListBuildsResult(const FListBuildsResult& src) = default;

        FListBuildsResult(const TSharedPtr<FJsonObject>& obj) : FListBuildsResult()
        {
            readFromValue(obj);
        }

        ~FListBuildsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListOpenIdConnectionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FListOpenIdConnectionRequest() :
            FPlayFabCppRequestCommon()
            {}

        FListOpenIdConnectionRequest(const FListOpenIdConnectionRequest& src) = default;

        FListOpenIdConnectionRequest(const TSharedPtr<FJsonObject>& obj) : FListOpenIdConnectionRequest()
        {
            readFromValue(obj);
        }

        ~FListOpenIdConnectionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FOpenIdConnection : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The client ID given by the ID provider.
        FString ClientId;

        // [optional] The client secret given by the ID provider.
        FString ClientSecret;

        // [optional] A name for the connection to identify it within the title.
        FString ConnectionId;

        // Shows if data about the connection will be loaded from the issuer's discovery document
        bool DiscoverConfiguration;

        // [optional] Information for an OpenID Connect provider.
        TSharedPtr<FOpenIdIssuerInformation> IssuerInformation;

        FOpenIdConnection() :
            FPlayFabCppBaseModel(),
            ClientId(),
            ClientSecret(),
            ConnectionId(),
            DiscoverConfiguration(false),
            IssuerInformation(nullptr)
            {}

        FOpenIdConnection(const FOpenIdConnection& src) = default;

        FOpenIdConnection(const TSharedPtr<FJsonObject>& obj) : FOpenIdConnection()
        {
            readFromValue(obj);
        }

        ~FOpenIdConnection();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListOpenIdConnectionResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of Open ID Connections
        TArray<FOpenIdConnection> Connections;
        FListOpenIdConnectionResponse() :
            FPlayFabCppResultCommon(),
            Connections()
            {}

        FListOpenIdConnectionResponse(const FListOpenIdConnectionResponse& src) = default;

        FListOpenIdConnectionResponse(const TSharedPtr<FJsonObject>& obj) : FListOpenIdConnectionResponse()
        {
            readFromValue(obj);
        }

        ~FListOpenIdConnectionResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListVirtualCurrencyTypesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        FListVirtualCurrencyTypesRequest() :
            FPlayFabCppRequestCommon()
            {}

        FListVirtualCurrencyTypesRequest(const FListVirtualCurrencyTypesRequest& src) = default;

        FListVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FListVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }

        ~FListVirtualCurrencyTypesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListVirtualCurrencyTypesResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] List of virtual currency names defined for this title
        TArray<FVirtualCurrencyData> VirtualCurrencies;
        FListVirtualCurrencyTypesResult() :
            FPlayFabCppResultCommon(),
            VirtualCurrencies()
            {}

        FListVirtualCurrencyTypesResult(const FListVirtualCurrencyTypesResult& src) = default;

        FListVirtualCurrencyTypesResult(const TSharedPtr<FJsonObject>& obj) : FListVirtualCurrencyTypesResult()
        {
            readFromValue(obj);
        }

        ~FListVirtualCurrencyTypesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLookupUserAccountInfoRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] User email address attached to their account
        FString Email;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Title specific username to match against existing user accounts
        FString TitleDisplayName;

        // [optional] PlayFab username for the account (3-20 characters)
        FString Username;

        FLookupUserAccountInfoRequest() :
            FPlayFabCppRequestCommon(),
            Email(),
            PlayFabId(),
            TitleDisplayName(),
            Username()
            {}

        FLookupUserAccountInfoRequest(const FLookupUserAccountInfoRequest& src) = default;

        FLookupUserAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FLookupUserAccountInfoRequest()
        {
            readFromValue(obj);
        }

        ~FLookupUserAccountInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserAndroidDeviceInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Android device ID
        FString AndroidDeviceId;

        FUserAndroidDeviceInfo() :
            FPlayFabCppBaseModel(),
            AndroidDeviceId()
            {}

        FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) = default;

        FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserAndroidDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserAppleIdInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Apple subject ID
        FString AppleSubjectId;

        FUserAppleIdInfo() :
            FPlayFabCppBaseModel(),
            AppleSubjectId()
            {}

        FUserAppleIdInfo(const FUserAppleIdInfo& src) = default;

        FUserAppleIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserAppleIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserAppleIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserCustomIdInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Custom ID
        FString CustomId;

        FUserCustomIdInfo() :
            FPlayFabCppBaseModel(),
            CustomId()
            {}

        FUserCustomIdInfo(const FUserCustomIdInfo& src) = default;

        FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserCustomIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserFacebookInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Facebook identifier
        FString FacebookId;

        // [optional] Facebook full name
        FString FullName;

        FUserFacebookInfo() :
            FPlayFabCppBaseModel(),
            FacebookId(),
            FullName()
            {}

        FUserFacebookInfo(const FUserFacebookInfo& src) = default;

        FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }

        ~FUserFacebookInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserFacebookInstantGamesIdInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Facebook Instant Games ID
        FString FacebookInstantGamesId;

        FUserFacebookInstantGamesIdInfo() :
            FPlayFabCppBaseModel(),
            FacebookInstantGamesId()
            {}

        FUserFacebookInstantGamesIdInfo(const FUserFacebookInstantGamesIdInfo& src) = default;

        FUserFacebookInstantGamesIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInstantGamesIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserFacebookInstantGamesIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserGameCenterInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Gamecenter identifier
        FString GameCenterId;

        FUserGameCenterInfo() :
            FPlayFabCppBaseModel(),
            GameCenterId()
            {}

        FUserGameCenterInfo(const FUserGameCenterInfo& src) = default;

        FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }

        ~FUserGameCenterInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserGoogleInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Email address of the Google account
        FString GoogleEmail;

        // [optional] Gender information of the Google account
        FString GoogleGender;

        // [optional] Google ID
        FString GoogleId;

        // [optional] Locale of the Google account
        FString GoogleLocale;

        // [optional] Name of the Google account user
        FString GoogleName;

        FUserGoogleInfo() :
            FPlayFabCppBaseModel(),
            GoogleEmail(),
            GoogleGender(),
            GoogleId(),
            GoogleLocale(),
            GoogleName()
            {}

        FUserGoogleInfo(const FUserGoogleInfo& src) = default;

        FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }

        ~FUserGoogleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserIosDeviceInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] iOS device ID
        FString IosDeviceId;

        FUserIosDeviceInfo() :
            FPlayFabCppBaseModel(),
            IosDeviceId()
            {}

        FUserIosDeviceInfo(const FUserIosDeviceInfo& src) = default;

        FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserIosDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserKongregateInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Kongregate ID
        FString KongregateId;

        // [optional] Kongregate Username
        FString KongregateName;

        FUserKongregateInfo() :
            FPlayFabCppBaseModel(),
            KongregateId(),
            KongregateName()
            {}

        FUserKongregateInfo(const FUserKongregateInfo& src) = default;

        FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }

        ~FUserKongregateInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserNintendoSwitchAccountIdInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Nintendo Switch account subject ID
        FString NintendoSwitchAccountSubjectId;

        FUserNintendoSwitchAccountIdInfo() :
            FPlayFabCppBaseModel(),
            NintendoSwitchAccountSubjectId()
            {}

        FUserNintendoSwitchAccountIdInfo(const FUserNintendoSwitchAccountIdInfo& src) = default;

        FUserNintendoSwitchAccountIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserNintendoSwitchAccountIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserNintendoSwitchAccountIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserNintendoSwitchDeviceIdInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Nintendo Switch Device ID
        FString NintendoSwitchDeviceId;

        FUserNintendoSwitchDeviceIdInfo() :
            FPlayFabCppBaseModel(),
            NintendoSwitchDeviceId()
            {}

        FUserNintendoSwitchDeviceIdInfo(const FUserNintendoSwitchDeviceIdInfo& src) = default;

        FUserNintendoSwitchDeviceIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserNintendoSwitchDeviceIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserNintendoSwitchDeviceIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserOpenIdInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] OpenID Connection ID
        FString ConnectionId;

        // [optional] OpenID Issuer
        FString Issuer;

        // [optional] OpenID Subject
        FString Subject;

        FUserOpenIdInfo() :
            FPlayFabCppBaseModel(),
            ConnectionId(),
            Issuer(),
            Subject()
            {}

        FUserOpenIdInfo(const FUserOpenIdInfo& src) = default;

        FUserOpenIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserOpenIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserOpenIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserPrivateAccountInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] user email address
        FString Email;

        FUserPrivateAccountInfo() :
            FPlayFabCppBaseModel(),
            Email()
            {}

        FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) = default;

        FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserPrivateAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserPsnInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] PSN account ID
        FString PsnAccountId;

        // [optional] PSN online ID
        FString PsnOnlineId;

        FUserPsnInfo() :
            FPlayFabCppBaseModel(),
            PsnAccountId(),
            PsnOnlineId()
            {}

        FUserPsnInfo(const FUserPsnInfo& src) = default;

        FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }

        ~FUserPsnInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TitleActivationStatus
    {
        TitleActivationStatusNone,
        TitleActivationStatusActivatedTitleKey,
        TitleActivationStatusPendingSteam,
        TitleActivationStatusActivatedSteam,
        TitleActivationStatusRevokedSteam
    };

    PLAYFABCPP_API void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API TitleActivationStatus readTitleActivationStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FUserSteamInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] what stage of game ownership the user is listed as being in, from Steam
        Boxed<TitleActivationStatus> SteamActivationStatus;

        // [optional] the country in which the player resides, from Steam data
        FString SteamCountry;

        // [optional] currency type set in the user Steam account
        Boxed<Currency> SteamCurrency;

        // [optional] Steam identifier
        FString SteamId;

        // [optional] Steam display name
        FString SteamName;

        FUserSteamInfo() :
            FPlayFabCppBaseModel(),
            SteamActivationStatus(),
            SteamCountry(),
            SteamCurrency(),
            SteamId(),
            SteamName()
            {}

        FUserSteamInfo(const FUserSteamInfo& src) = default;

        FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }

        ~FUserSteamInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserOrigination
    {
        UserOriginationOrganic,
        UserOriginationSteam,
        UserOriginationGoogle,
        UserOriginationAmazon,
        UserOriginationFacebook,
        UserOriginationKongregate,
        UserOriginationGamersFirst,
        UserOriginationUnknown,
        UserOriginationIOS,
        UserOriginationLoadTest,
        UserOriginationAndroid,
        UserOriginationPSN,
        UserOriginationGameCenter,
        UserOriginationCustomId,
        UserOriginationXboxLive,
        UserOriginationParse,
        UserOriginationTwitch,
        UserOriginationServerCustomId,
        UserOriginationNintendoSwitchDeviceId,
        UserOriginationFacebookInstantGamesId,
        UserOriginationOpenIdConnect,
        UserOriginationApple,
        UserOriginationNintendoSwitchAccount
    };

    PLAYFABCPP_API void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
    PLAYFABCPP_API UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API UserOrigination readUserOriginationFromValue(const FString& value);

    struct PLAYFABCPP_API FUserTitleInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] URL to the player's avatar.
        FString AvatarUrl;

        /**
         * timestamp indicating when the user was first associated with this game (this can differ significantly from when the user
         * first registered with PlayFab)
         */
        FDateTime Created;

        // [optional] name of the user, as it is displayed in-game
        FString DisplayName;

        /**
         * [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other
         * events, such as issuing a beta key to the user, can associate the title to the user)
         */
        Boxed<FDateTime> FirstLogin;

        // [optional] boolean indicating whether or not the user is currently banned for a title
        Boxed<bool> isBanned;

        // [optional] timestamp for the last user login for this title
        Boxed<FDateTime> LastLogin;

        // [optional] source by which the user first joined the game, if known
        Boxed<UserOrigination> Origination;

        // [optional] Title player account entity for this user
        TSharedPtr<FEntityKey> TitlePlayerAccount;

        FUserTitleInfo() :
            FPlayFabCppBaseModel(),
            AvatarUrl(),
            Created(0),
            DisplayName(),
            FirstLogin(),
            isBanned(),
            LastLogin(),
            Origination(),
            TitlePlayerAccount(nullptr)
            {}

        FUserTitleInfo(const FUserTitleInfo& src) = default;

        FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }

        ~FUserTitleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserTwitchInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Twitch ID
        FString TwitchId;

        // [optional] Twitch Username
        FString TwitchUserName;

        FUserTwitchInfo() :
            FPlayFabCppBaseModel(),
            TwitchId(),
            TwitchUserName()
            {}

        FUserTwitchInfo(const FUserTwitchInfo& src) = default;

        FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }

        ~FUserTwitchInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserXboxInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] XBox user ID
        FString XboxUserId;

        FUserXboxInfo() :
            FPlayFabCppBaseModel(),
            XboxUserId()
            {}

        FUserXboxInfo(const FUserXboxInfo& src) = default;

        FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }

        ~FUserXboxInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUserAccountInfo : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] User Android device information, if an Android device has been linked
        TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;

        // [optional] Sign in with Apple account information, if an Apple account has been linked
        TSharedPtr<FUserAppleIdInfo> AppleAccountInfo;

        // Timestamp indicating when the user account was created
        FDateTime Created;

        // [optional] Custom ID information, if a custom ID has been assigned
        TSharedPtr<FUserCustomIdInfo> CustomIdInfo;

        // [optional] User Facebook information, if a Facebook account has been linked
        TSharedPtr<FUserFacebookInfo> FacebookInfo;

        // [optional] Facebook Instant Games account information, if a Facebook Instant Games account has been linked
        TSharedPtr<FUserFacebookInstantGamesIdInfo> FacebookInstantGamesIdInfo;

        // [optional] User Gamecenter information, if a Gamecenter account has been linked
        TSharedPtr<FUserGameCenterInfo> GameCenterInfo;

        // [optional] User Google account information, if a Google account has been linked
        TSharedPtr<FUserGoogleInfo> GoogleInfo;

        // [optional] User iOS device information, if an iOS device has been linked
        TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;

        // [optional] User Kongregate account information, if a Kongregate account has been linked
        TSharedPtr<FUserKongregateInfo> KongregateInfo;

        // [optional] Nintendo Switch account information, if a Nintendo Switch account has been linked
        TSharedPtr<FUserNintendoSwitchAccountIdInfo> NintendoSwitchAccountInfo;

        // [optional] Nintendo Switch device information, if a Nintendo Switch device has been linked
        TSharedPtr<FUserNintendoSwitchDeviceIdInfo> NintendoSwitchDeviceIdInfo;

        // [optional] OpenID Connect information, if any OpenID Connect accounts have been linked
        TArray<FUserOpenIdInfo> OpenIdInfo;
        // [optional] Unique identifier for the user account
        FString PlayFabId;

        // [optional] Personal information for the user which is considered more sensitive
        TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;

        // [optional] User PSN account information, if a PSN account has been linked
        TSharedPtr<FUserPsnInfo> PsnInfo;

        // [optional] User Steam information, if a Steam account has been linked
        TSharedPtr<FUserSteamInfo> SteamInfo;

        // [optional] Title-specific information for the user account
        TSharedPtr<FUserTitleInfo> TitleInfo;

        // [optional] User Twitch account information, if a Twitch account has been linked
        TSharedPtr<FUserTwitchInfo> TwitchInfo;

        // [optional] User account name in the PlayFab service
        FString Username;

        // [optional] User XBox account information, if a XBox account has been linked
        TSharedPtr<FUserXboxInfo> XboxInfo;

        FUserAccountInfo() :
            FPlayFabCppBaseModel(),
            AndroidDeviceInfo(nullptr),
            AppleAccountInfo(nullptr),
            Created(0),
            CustomIdInfo(nullptr),
            FacebookInfo(nullptr),
            FacebookInstantGamesIdInfo(nullptr),
            GameCenterInfo(nullptr),
            GoogleInfo(nullptr),
            IosDeviceInfo(nullptr),
            KongregateInfo(nullptr),
            NintendoSwitchAccountInfo(nullptr),
            NintendoSwitchDeviceIdInfo(nullptr),
            OpenIdInfo(),
            PlayFabId(),
            PrivateInfo(nullptr),
            PsnInfo(nullptr),
            SteamInfo(nullptr),
            TitleInfo(nullptr),
            TwitchInfo(nullptr),
            Username(),
            XboxInfo(nullptr)
            {}

        FUserAccountInfo(const FUserAccountInfo& src) = default;

        FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLookupUserAccountInfoResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] User info for the user matching the request
        TSharedPtr<FUserAccountInfo> UserInfo;

        FLookupUserAccountInfoResult() :
            FPlayFabCppResultCommon(),
            UserInfo(nullptr)
            {}

        FLookupUserAccountInfoResult(const FLookupUserAccountInfoResult& src) = default;

        FLookupUserAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FLookupUserAccountInfoResult()
        {
            readFromValue(obj);
        }

        ~FLookupUserAccountInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FModifyMatchmakerGameModesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // previously uploaded build version for which game modes are being specified
        FString BuildVersion;

        // array of game modes (Note: this will replace all game modes for the indicated build version)
        TArray<FGameModeInfo> GameModes;
        FModifyMatchmakerGameModesRequest() :
            FPlayFabCppRequestCommon(),
            BuildVersion(),
            GameModes()
            {}

        FModifyMatchmakerGameModesRequest(const FModifyMatchmakerGameModesRequest& src) = default;

        FModifyMatchmakerGameModesRequest(const TSharedPtr<FJsonObject>& obj) : FModifyMatchmakerGameModesRequest()
        {
            readFromValue(obj);
        }

        ~FModifyMatchmakerGameModesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FModifyMatchmakerGameModesResult : public PlayFab::FPlayFabCppResultCommon
    {
        FModifyMatchmakerGameModesResult() :
            FPlayFabCppResultCommon()
            {}

        FModifyMatchmakerGameModesResult(const FModifyMatchmakerGameModesResult& src) = default;

        FModifyMatchmakerGameModesResult(const TSharedPtr<FJsonObject>& obj) : FModifyMatchmakerGameModesResult()
        {
            readFromValue(obj);
        }

        ~FModifyMatchmakerGameModesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FModifyServerBuildRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // unique identifier of the previously uploaded build executable to be updated
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] new timestamp
        Boxed<FDateTime> Timestamp;

        FModifyServerBuildRequest() :
            FPlayFabCppRequestCommon(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            CustomTags(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Timestamp()
            {}

        FModifyServerBuildRequest(const FModifyServerBuildRequest& src) = default;

        FModifyServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FModifyServerBuildRequest()
        {
            readFromValue(obj);
        }

        ~FModifyServerBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FModifyServerBuildResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // [optional] unique identifier for this build executable
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] the current status of the build validation and processing steps
        Boxed<GameBuildStatus> Status;

        // time this build was last modified (or uploaded, if this build has never been modified)
        FDateTime Timestamp;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FModifyServerBuildResult() :
            FPlayFabCppResultCommon(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Status(),
            Timestamp(0),
            TitleId()
            {}

        FModifyServerBuildResult(const FModifyServerBuildResult& src) = default;

        FModifyServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FModifyServerBuildResult()
        {
            readFromValue(obj);
        }

        ~FModifyServerBuildResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FModifyUserVirtualCurrencyResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Balance of the virtual currency after modification.
        int32 Balance;

        /**
         * Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase
         * over this value will be discarded.
         */
        int32 BalanceChange;

        // [optional] User currency was subtracted from.
        FString PlayFabId;

        // [optional] Name of the virtual currency which was modified.
        FString VirtualCurrency;

        FModifyUserVirtualCurrencyResult() :
            FPlayFabCppResultCommon(),
            Balance(0),
            BalanceChange(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) = default;

        FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }

        ~FModifyUserVirtualCurrencyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PushSetupPlatform
    {
        PushSetupPlatformGCM,
        PushSetupPlatformAPNS,
        PushSetupPlatformAPNS_SANDBOX
    };

    PLAYFABCPP_API void writePushSetupPlatformEnumJSON(PushSetupPlatform enumVal, JsonWriter& writer);
    PLAYFABCPP_API PushSetupPlatform readPushSetupPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API PushSetupPlatform readPushSetupPlatformFromValue(const FString& value);

    struct PLAYFABCPP_API FRandomResultTable : public PlayFab::FPlayFabCppBaseModel
    {
        // Child nodes that indicate what kind of drop table item this actually is.
        TArray<FResultTableNode> Nodes;
        // Unique name for this drop table
        FString TableId;

        FRandomResultTable() :
            FPlayFabCppBaseModel(),
            Nodes(),
            TableId()
            {}

        FRandomResultTable(const FRandomResultTable& src) = default;

        FRandomResultTable(const TSharedPtr<FJsonObject>& obj) : FRandomResultTable()
        {
            readFromValue(obj);
        }

        ~FRandomResultTable();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRefundPurchaseRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique order ID for the purchase in question.
        FString OrderId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] The Reason parameter should correspond with the payment providers reason field, if they require one such as Facebook. In
         * the case of Facebook this must match one of their refund or dispute resolution enums (See:
         * https://developers.facebook.com/docs/payments/implementation-guide/handling-disputes-refunds)
         */
        FString Reason;

        FRefundPurchaseRequest() :
            FPlayFabCppRequestCommon(),
            OrderId(),
            PlayFabId(),
            Reason()
            {}

        FRefundPurchaseRequest(const FRefundPurchaseRequest& src) = default;

        FRefundPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FRefundPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FRefundPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRefundPurchaseResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The order's updated purchase status.
        FString PurchaseStatus;

        FRefundPurchaseResponse() :
            FPlayFabCppResultCommon(),
            PurchaseStatus()
            {}

        FRefundPurchaseResponse(const FRefundPurchaseResponse& src) = default;

        FRefundPurchaseResponse(const TSharedPtr<FJsonObject>& obj) : FRefundPurchaseResponse()
        {
            readFromValue(obj);
        }

        ~FRefundPurchaseResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRemovePlayerTagRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique tag for player profile.
        FString TagName;

        FRemovePlayerTagRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PlayFabId(),
            TagName()
            {}

        FRemovePlayerTagRequest(const FRemovePlayerTagRequest& src) = default;

        FRemovePlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagRequest()
        {
            readFromValue(obj);
        }

        ~FRemovePlayerTagRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRemovePlayerTagResult : public PlayFab::FPlayFabCppResultCommon
    {
        FRemovePlayerTagResult() :
            FPlayFabCppResultCommon()
            {}

        FRemovePlayerTagResult(const FRemovePlayerTagResult& src) = default;

        FRemovePlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagResult()
        {
            readFromValue(obj);
        }

        ~FRemovePlayerTagResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRemoveServerBuildRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // unique identifier of the previously uploaded build executable to be removed
        FString BuildId;

        FRemoveServerBuildRequest() :
            FPlayFabCppRequestCommon(),
            BuildId()
            {}

        FRemoveServerBuildRequest(const FRemoveServerBuildRequest& src) = default;

        FRemoveServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveServerBuildRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveServerBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRemoveServerBuildResult : public PlayFab::FPlayFabCppResultCommon
    {
        FRemoveServerBuildResult() :
            FPlayFabCppResultCommon()
            {}

        FRemoveServerBuildResult(const FRemoveServerBuildResult& src) = default;

        FRemoveServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FRemoveServerBuildResult()
        {
            readFromValue(obj);
        }

        ~FRemoveServerBuildResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRemoveVirtualCurrencyTypesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // List of virtual currencies to delete
        TArray<FVirtualCurrencyData> VirtualCurrencies;
        FRemoveVirtualCurrencyTypesRequest() :
            FPlayFabCppRequestCommon(),
            VirtualCurrencies()
            {}

        FRemoveVirtualCurrencyTypesRequest(const FRemoveVirtualCurrencyTypesRequest& src) = default;

        FRemoveVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveVirtualCurrencyTypesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResetCharacterStatisticsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FResetCharacterStatisticsRequest() :
            FPlayFabCppRequestCommon(),
            CharacterId(),
            CustomTags(),
            PlayFabId()
            {}

        FResetCharacterStatisticsRequest(const FResetCharacterStatisticsRequest& src) = default;

        FResetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FResetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FResetCharacterStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResetCharacterStatisticsResult : public PlayFab::FPlayFabCppResultCommon
    {
        FResetCharacterStatisticsResult() :
            FPlayFabCppResultCommon()
            {}

        FResetCharacterStatisticsResult(const FResetCharacterStatisticsResult& src) = default;

        FResetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FResetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FResetCharacterStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResetPasswordRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The new password for the player.
        FString Password;

        // The token of the player requesting the password reset.
        FString Token;

        FResetPasswordRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Password(),
            Token()
            {}

        FResetPasswordRequest(const FResetPasswordRequest& src) = default;

        FResetPasswordRequest(const TSharedPtr<FJsonObject>& obj) : FResetPasswordRequest()
        {
            readFromValue(obj);
        }

        ~FResetPasswordRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResetPasswordResult : public PlayFab::FPlayFabCppResultCommon
    {
        FResetPasswordResult() :
            FPlayFabCppResultCommon()
            {}

        FResetPasswordResult(const FResetPasswordResult& src) = default;

        FResetPasswordResult(const TSharedPtr<FJsonObject>& obj) : FResetPasswordResult()
        {
            readFromValue(obj);
        }

        ~FResetPasswordResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResetUserStatisticsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FResetUserStatisticsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PlayFabId()
            {}

        FResetUserStatisticsRequest(const FResetUserStatisticsRequest& src) = default;

        FResetUserStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FResetUserStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FResetUserStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResetUserStatisticsResult : public PlayFab::FPlayFabCppResultCommon
    {
        FResetUserStatisticsResult() :
            FPlayFabCppResultCommon()
            {}

        FResetUserStatisticsResult(const FResetUserStatisticsResult& src) = default;

        FResetUserStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FResetUserStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FResetUserStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ResolutionOutcome
    {
        ResolutionOutcomeRevoke,
        ResolutionOutcomeReinstate,
        ResolutionOutcomeManual
    };

    PLAYFABCPP_API void writeResolutionOutcomeEnumJSON(ResolutionOutcome enumVal, JsonWriter& writer);
    PLAYFABCPP_API ResolutionOutcome readResolutionOutcomeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ResolutionOutcome readResolutionOutcomeFromValue(const FString& value);

    struct PLAYFABCPP_API FResolvePurchaseDisputeRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique order ID for the purchase in question.
        FString OrderId;

        /**
         * Enum for the desired purchase result state after notifying the payment provider. Valid values are Revoke, Reinstate and
         * Manual. Manual will cause no change to the order state.
         */
        ResolutionOutcome Outcome;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] The Reason parameter should correspond with the payment providers reason field, if they require one such as Facebook. In
         * the case of Facebook this must match one of their refund or dispute resolution enums (See:
         * https://developers.facebook.com/docs/payments/implementation-guide/handling-disputes-refunds)
         */
        FString Reason;

        FResolvePurchaseDisputeRequest() :
            FPlayFabCppRequestCommon(),
            OrderId(),
            Outcome(),
            PlayFabId(),
            Reason()
            {}

        FResolvePurchaseDisputeRequest(const FResolvePurchaseDisputeRequest& src) = default;

        FResolvePurchaseDisputeRequest(const TSharedPtr<FJsonObject>& obj) : FResolvePurchaseDisputeRequest()
        {
            readFromValue(obj);
        }

        ~FResolvePurchaseDisputeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FResolvePurchaseDisputeResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The order's updated purchase status.
        FString PurchaseStatus;

        FResolvePurchaseDisputeResponse() :
            FPlayFabCppResultCommon(),
            PurchaseStatus()
            {}

        FResolvePurchaseDisputeResponse(const FResolvePurchaseDisputeResponse& src) = default;

        FResolvePurchaseDisputeResponse(const TSharedPtr<FJsonObject>& obj) : FResolvePurchaseDisputeResponse()
        {
            readFromValue(obj);
        }

        ~FResolvePurchaseDisputeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeAllBansForUserRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeAllBansForUserRequest() :
            FPlayFabCppRequestCommon(),
            PlayFabId()
            {}

        FRevokeAllBansForUserRequest(const FRevokeAllBansForUserRequest& src) = default;

        FRevokeAllBansForUserRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeAllBansForUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeAllBansForUserResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Information on the bans that were revoked.
        TArray<FBanInfo> BanData;
        FRevokeAllBansForUserResult() :
            FPlayFabCppResultCommon(),
            BanData()
            {}

        FRevokeAllBansForUserResult(const FRevokeAllBansForUserResult& src) = default;

        FRevokeAllBansForUserResult(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserResult()
        {
            readFromValue(obj);
        }

        ~FRevokeAllBansForUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeBansRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Ids of the bans to be revoked. Maximum 100.
        TArray<FString> BanIds;
        FRevokeBansRequest() :
            FPlayFabCppRequestCommon(),
            BanIds()
            {}

        FRevokeBansRequest(const FRevokeBansRequest& src) = default;

        FRevokeBansRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeBansRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeBansResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Information on the bans that were revoked
        TArray<FBanInfo> BanData;
        FRevokeBansResult() :
            FPlayFabCppResultCommon(),
            BanData()
            {}

        FRevokeBansResult(const FRevokeBansResult& src) = default;

        FRevokeBansResult(const TSharedPtr<FJsonObject>& obj) : FRevokeBansResult()
        {
            readFromValue(obj);
        }

        ~FRevokeBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeInventoryItem : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeInventoryItem() :
            FPlayFabCppBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FRevokeInventoryItem(const FRevokeInventoryItem& src) = default;

        FRevokeInventoryItem(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItem()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeInventoryItemRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeInventoryItemRequest() :
            FPlayFabCppRequestCommon(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FRevokeInventoryItemRequest(const FRevokeInventoryItemRequest& src) = default;

        FRevokeInventoryItemRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeInventoryItemsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Array of player items to revoke, between 1 and 25 items.
        TArray<FRevokeInventoryItem> Items;
        FRevokeInventoryItemsRequest() :
            FPlayFabCppRequestCommon(),
            Items()
            {}

        FRevokeInventoryItemsRequest(const FRevokeInventoryItemsRequest& src) = default;

        FRevokeInventoryItemsRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemsRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeItemError : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Specific error that was encountered.
        FString Error;

        // [optional] Item information that failed to be revoked.
        TSharedPtr<FRevokeInventoryItem> Item;

        FRevokeItemError() :
            FPlayFabCppBaseModel(),
            Error(),
            Item(nullptr)
            {}

        FRevokeItemError(const FRevokeItemError& src) = default;

        FRevokeItemError(const TSharedPtr<FJsonObject>& obj) : FRevokeItemError()
        {
            readFromValue(obj);
        }

        ~FRevokeItemError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeInventoryItemsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Collection of any errors that occurred during processing.
        TArray<FRevokeItemError> Errors;
        FRevokeInventoryItemsResult() :
            FPlayFabCppResultCommon(),
            Errors()
            {}

        FRevokeInventoryItemsResult(const FRevokeInventoryItemsResult& src) = default;

        FRevokeInventoryItemsResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemsResult()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRevokeInventoryResult : public PlayFab::FPlayFabCppResultCommon
    {
        FRevokeInventoryResult() :
            FPlayFabCppResultCommon()
            {}

        FRevokeInventoryResult(const FRevokeInventoryResult& src) = default;

        FRevokeInventoryResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryResult()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRunTaskRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Provide either the task ID or the task name to run a task.
        TSharedPtr<FNameIdentifier> Identifier;

        FRunTaskRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Identifier(nullptr)
            {}

        FRunTaskRequest(const FRunTaskRequest& src) = default;

        FRunTaskRequest(const TSharedPtr<FJsonObject>& obj) : FRunTaskRequest()
        {
            readFromValue(obj);
        }

        ~FRunTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRunTaskResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] ID of the task instance that is started. This can be used in Get*TaskInstance (e.g. GetCloudScriptTaskInstance) API call
         * to retrieve status for the task instance.
         */
        FString TaskInstanceId;

        FRunTaskResult() :
            FPlayFabCppResultCommon(),
            TaskInstanceId()
            {}

        FRunTaskResult(const FRunTaskResult& src) = default;

        FRunTaskResult(const TSharedPtr<FJsonObject>& obj) : FRunTaskResult()
        {
            readFromValue(obj);
        }

        ~FRunTaskResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSendAccountRecoveryEmailRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // User email address attached to their account
        FString Email;

        // [optional] The email template id of the account recovery email template to send.
        FString EmailTemplateId;

        FSendAccountRecoveryEmailRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Email(),
            EmailTemplateId()
            {}

        FSendAccountRecoveryEmailRequest(const FSendAccountRecoveryEmailRequest& src) = default;

        FSendAccountRecoveryEmailRequest(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailRequest()
        {
            readFromValue(obj);
        }

        ~FSendAccountRecoveryEmailRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSendAccountRecoveryEmailResult : public PlayFab::FPlayFabCppResultCommon
    {
        FSendAccountRecoveryEmailResult() :
            FPlayFabCppResultCommon()
            {}

        FSendAccountRecoveryEmailResult(const FSendAccountRecoveryEmailResult& src) = default;

        FSendAccountRecoveryEmailResult(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailResult()
        {
            readFromValue(obj);
        }

        ~FSendAccountRecoveryEmailResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetPlayerSecretRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FSetPlayerSecretRequest() :
            FPlayFabCppRequestCommon(),
            PlayerSecret(),
            PlayFabId()
            {}

        FSetPlayerSecretRequest(const FSetPlayerSecretRequest& src) = default;

        FSetPlayerSecretRequest(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretRequest()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetPlayerSecretResult : public PlayFab::FPlayFabCppResultCommon
    {
        FSetPlayerSecretResult() :
            FPlayFabCppResultCommon()
            {}

        FSetPlayerSecretResult(const FSetPlayerSecretResult& src) = default;

        FSetPlayerSecretResult(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretResult()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetPublishedRevisionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Revision to make the current published revision
        int32 Revision;

        // Version number
        int32 Version;

        FSetPublishedRevisionRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Revision(0),
            Version(0)
            {}

        FSetPublishedRevisionRequest(const FSetPublishedRevisionRequest& src) = default;

        FSetPublishedRevisionRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublishedRevisionRequest()
        {
            readFromValue(obj);
        }

        ~FSetPublishedRevisionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetPublishedRevisionResult : public PlayFab::FPlayFabCppResultCommon
    {
        FSetPublishedRevisionResult() :
            FPlayFabCppResultCommon()
            {}

        FSetPublishedRevisionResult(const FSetPublishedRevisionResult& src) = default;

        FSetPublishedRevisionResult(const TSharedPtr<FJsonObject>& obj) : FSetPublishedRevisionResult()
        {
            readFromValue(obj);
        }

        ~FSetPublishedRevisionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetPublisherDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] new value to set. Set to null to remove a value
        FString Value;

        FSetPublisherDataRequest() :
            FPlayFabCppRequestCommon(),
            Key(),
            Value()
            {}

        FSetPublisherDataRequest(const FSetPublisherDataRequest& src) = default;

        FSetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetPublisherDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        FSetPublisherDataResult() :
            FPlayFabCppResultCommon()
            {}

        FSetPublisherDataResult(const FSetPublisherDataResult& src) = default;

        FSetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FSetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FTitleDataKeyValue : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] Key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] New value to set. Set to null to remove a value
        FString Value;

        FTitleDataKeyValue() :
            FPlayFabCppBaseModel(),
            Key(),
            Value()
            {}

        FTitleDataKeyValue(const FTitleDataKeyValue& src) = default;

        FTitleDataKeyValue(const TSharedPtr<FJsonObject>& obj) : FTitleDataKeyValue()
        {
            readFromValue(obj);
        }

        ~FTitleDataKeyValue();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetTitleDataAndOverridesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * List of titleData key-value pairs to set/delete. Use an empty value to delete an existing key; use a non-empty value to
         * create/update a key.
         */
        TArray<FTitleDataKeyValue> KeyValues;
        // [optional] Name of the override.
        FString OverrideLabel;

        FSetTitleDataAndOverridesRequest() :
            FPlayFabCppRequestCommon(),
            KeyValues(),
            OverrideLabel()
            {}

        FSetTitleDataAndOverridesRequest(const FSetTitleDataAndOverridesRequest& src) = default;

        FSetTitleDataAndOverridesRequest(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataAndOverridesRequest()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataAndOverridesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetTitleDataAndOverridesResult : public PlayFab::FPlayFabCppResultCommon
    {
        FSetTitleDataAndOverridesResult() :
            FPlayFabCppResultCommon()
            {}

        FSetTitleDataAndOverridesResult(const FSetTitleDataAndOverridesResult& src) = default;

        FSetTitleDataAndOverridesResult(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataAndOverridesResult()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataAndOverridesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetTitleDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] new value to set. Set to null to remove a value
        FString Value;

        FSetTitleDataRequest() :
            FPlayFabCppRequestCommon(),
            Key(),
            Value()
            {}

        FSetTitleDataRequest(const FSetTitleDataRequest& src) = default;

        FSetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetTitleDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        FSetTitleDataResult() :
            FPlayFabCppResultCommon()
            {}

        FSetTitleDataResult(const FSetTitleDataResult& src) = default;

        FSetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetupPushNotificationRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Credential is the Private Key for APNS/APNS_SANDBOX, and the API Key for GCM
        FString Credential;

        // [optional] for APNS, this is the PlatformPrincipal (SSL Certificate)
        FString Key;

        // [optional] This field is deprecated and any usage of this will cause the API to fail.
        FString Name;

        /**
         * replace any existing ARN with the newly generated one. If this is set to false, an error will be returned if
         * notifications have already setup for this platform.
         */
        bool OverwriteOldARN;

        /**
         * supported notification platforms are Apple Push Notification Service (APNS and APNS_SANDBOX) for iOS and Google Cloud
         * Messaging (GCM) for Android
         */
        PushSetupPlatform Platform;

        FSetupPushNotificationRequest() :
            FPlayFabCppRequestCommon(),
            Credential(),
            Key(),
            Name(),
            OverwriteOldARN(false),
            Platform()
            {}

        FSetupPushNotificationRequest(const FSetupPushNotificationRequest& src) = default;

        FSetupPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FSetupPushNotificationRequest()
        {
            readFromValue(obj);
        }

        ~FSetupPushNotificationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSetupPushNotificationResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Amazon Resource Name for the created notification topic.
        FString ARN;

        FSetupPushNotificationResult() :
            FPlayFabCppResultCommon(),
            ARN()
            {}

        FSetupPushNotificationResult(const FSetupPushNotificationResult& src) = default;

        FSetupPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FSetupPushNotificationResult()
        {
            readFromValue(obj);
        }

        ~FSetupPushNotificationResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum StatisticVersionArchivalStatus
    {
        StatisticVersionArchivalStatusNotScheduled,
        StatisticVersionArchivalStatusScheduled,
        StatisticVersionArchivalStatusQueued,
        StatisticVersionArchivalStatusInProgress,
        StatisticVersionArchivalStatusComplete
    };

    PLAYFABCPP_API void writeStatisticVersionArchivalStatusEnumJSON(StatisticVersionArchivalStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API StatisticVersionArchivalStatus readStatisticVersionArchivalStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API StatisticVersionArchivalStatus readStatisticVersionArchivalStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FSubtractUserVirtualCurrencyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Amount to be subtracted from the user balance of the specified virtual currency.
        int32 Amount;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // PlayFab unique identifier of the user whose virtual currency balance is to be decreased.
        FString PlayFabId;

        // Name of the virtual currency which is to be decremented.
        FString VirtualCurrency;

        FSubtractUserVirtualCurrencyRequest() :
            FPlayFabCppRequestCommon(),
            Amount(0),
            CustomTags(),
            PlayFabId(),
            VirtualCurrency()
            {}

        FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) = default;

        FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FSubtractUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBanRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The updated active state for the ban. Null for no change.
        Boxed<bool> Active;

        // The id of the ban to be updated.
        FString BanId;

        // [optional] The updated expiration date for the ban. Null for no change.
        Boxed<FDateTime> Expires;

        // [optional] The updated IP address for the ban. Null for no change.
        FString IPAddress;

        // [optional] The updated MAC address for the ban. Null for no change.
        FString MACAddress;

        // [optional] Whether to make this ban permanent. Set to true to make this ban permanent. This will not modify Active state.
        Boxed<bool> Permanent;

        // [optional] The updated reason for the ban to be updated. Maximum 140 characters. Null for no change.
        FString Reason;

        FUpdateBanRequest() :
            FPlayFabCppBaseModel(),
            Active(),
            BanId(),
            Expires(),
            IPAddress(),
            MACAddress(),
            Permanent(),
            Reason()
            {}

        FUpdateBanRequest(const FUpdateBanRequest& src) = default;

        FUpdateBanRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBanRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBanRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBansRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // List of bans to be updated. Maximum 100.
        TArray<FUpdateBanRequest> Bans;
        FUpdateBansRequest() :
            FPlayFabCppRequestCommon(),
            Bans()
            {}

        FUpdateBansRequest(const FUpdateBansRequest& src) = default;

        FUpdateBansRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBansRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBansResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Information on the bans that were updated
        TArray<FBanInfo> BanData;
        FUpdateBansResult() :
            FPlayFabCppResultCommon(),
            BanData()
            {}

        FUpdateBansResult(const FUpdateBansResult& src) = default;

        FUpdateBansResult(const TSharedPtr<FJsonObject>& obj) : FUpdateBansResult()
        {
            readFromValue(obj);
        }

        ~FUpdateBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateCatalogItemsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] Array of catalog items to be submitted. Note that while CatalogItem has a parameter for CatalogVersion, it is not
         * required and ignored in this call.
         */
        TArray<FCatalogItem> Catalog;
        // [optional] Which catalog is being updated. If null, uses the default catalog.
        FString CatalogVersion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] Should this catalog be set as the default catalog. Defaults to true. If there is currently no default catalog, this will
         * always set it.
         */
        Boxed<bool> SetAsDefaultCatalog;

        FUpdateCatalogItemsRequest() :
            FPlayFabCppRequestCommon(),
            Catalog(),
            CatalogVersion(),
            CustomTags(),
            SetAsDefaultCatalog()
            {}

        FUpdateCatalogItemsRequest(const FUpdateCatalogItemsRequest& src) = default;

        FUpdateCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCatalogItemsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCatalogItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateCatalogItemsResult : public PlayFab::FPlayFabCppResultCommon
    {
        FUpdateCatalogItemsResult() :
            FPlayFabCppResultCommon()
            {}

        FUpdateCatalogItemsResult(const FUpdateCatalogItemsResult& src) = default;

        FUpdateCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCatalogItemsResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCatalogItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateCloudScriptRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] PlayFab user ID of the developer initiating the request.
        FString DeveloperPlayFabId;

        // List of Cloud Script files to upload to create the new revision. Must have at least one file.
        TArray<FCloudScriptFile> Files;
        // Immediately publish the new revision
        bool Publish;

        FUpdateCloudScriptRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            DeveloperPlayFabId(),
            Files(),
            Publish(false)
            {}

        FUpdateCloudScriptRequest(const FUpdateCloudScriptRequest& src) = default;

        FUpdateCloudScriptRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCloudScriptRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCloudScriptRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateCloudScriptResult : public PlayFab::FPlayFabCppResultCommon
    {
        // New revision number created
        int32 Revision;

        // Cloud Script version updated
        int32 Version;

        FUpdateCloudScriptResult() :
            FPlayFabCppResultCommon(),
            Revision(0),
            Version(0)
            {}

        FUpdateCloudScriptResult(const FUpdateCloudScriptResult& src) = default;

        FUpdateCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCloudScriptResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCloudScriptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateOpenIdConnectionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The client ID given by the ID provider.
        FString ClientId;

        // [optional] The client secret given by the ID provider.
        FString ClientSecret;

        // A name for the connection that identifies it within the title.
        FString ConnectionId;

        // [optional] The issuer URL or discovery document URL to read issuer information from
        FString IssuerDiscoveryUrl;

        // [optional] Manually specified information for an OpenID Connect issuer.
        TSharedPtr<FOpenIdIssuerInformation> IssuerInformation;

        FUpdateOpenIdConnectionRequest() :
            FPlayFabCppRequestCommon(),
            ClientId(),
            ClientSecret(),
            ConnectionId(),
            IssuerDiscoveryUrl(),
            IssuerInformation(nullptr)
            {}

        FUpdateOpenIdConnectionRequest(const FUpdateOpenIdConnectionRequest& src) = default;

        FUpdateOpenIdConnectionRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateOpenIdConnectionRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateOpenIdConnectionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdatePlayerSharedSecretRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Disable or Enable this key
        bool Disabled;

        // [optional] Friendly name for this key
        FString FriendlyName;

        // [optional] The shared secret key to update
        FString SecretKey;

        FUpdatePlayerSharedSecretRequest() :
            FPlayFabCppRequestCommon(),
            Disabled(false),
            FriendlyName(),
            SecretKey()
            {}

        FUpdatePlayerSharedSecretRequest(const FUpdatePlayerSharedSecretRequest& src) = default;

        FUpdatePlayerSharedSecretRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerSharedSecretRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerSharedSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdatePlayerSharedSecretResult : public PlayFab::FPlayFabCppResultCommon
    {
        FUpdatePlayerSharedSecretResult() :
            FPlayFabCppResultCommon()
            {}

        FUpdatePlayerSharedSecretResult(const FUpdatePlayerSharedSecretResult& src) = default;

        FUpdatePlayerSharedSecretResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerSharedSecretResult()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerSharedSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdatePlayerStatisticDefinitionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] the aggregation method to use in updating the statistic (defaults to last)
        Boxed<StatisticAggregationMethod> AggregationMethod;

        // unique name of the statistic
        FString StatisticName;

        /**
         * [optional] interval at which the values of the statistic for all players are reset (changes are effective at the next occurance of
         * the new interval boundary)
         */
        Boxed<StatisticResetIntervalOption> VersionChangeInterval;

        FUpdatePlayerStatisticDefinitionRequest() :
            FPlayFabCppRequestCommon(),
            AggregationMethod(),
            StatisticName(),
            VersionChangeInterval()
            {}

        FUpdatePlayerStatisticDefinitionRequest(const FUpdatePlayerStatisticDefinitionRequest& src) = default;

        FUpdatePlayerStatisticDefinitionRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticDefinitionRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticDefinitionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdatePlayerStatisticDefinitionResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] updated statistic definition
        TSharedPtr<FPlayerStatisticDefinition> Statistic;

        FUpdatePlayerStatisticDefinitionResult() :
            FPlayFabCppResultCommon(),
            Statistic(nullptr)
            {}

        FUpdatePlayerStatisticDefinitionResult(const FUpdatePlayerStatisticDefinitionResult& src) = default;

        FUpdatePlayerStatisticDefinitionResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticDefinitionResult()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticDefinitionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdatePolicyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Whether to overwrite or append to the existing policy.
        bool OverwritePolicy;

        // The name of the policy being updated. Only supported name is 'ApiPolicy'
        FString PolicyName;

        // Version of the policy to update. Must be the latest (as returned by GetPolicy).
        int32 PolicyVersion;

        // The new statements to include in the policy.
        TArray<FPermissionStatement> Statements;
        FUpdatePolicyRequest() :
            FPlayFabCppRequestCommon(),
            OverwritePolicy(false),
            PolicyName(),
            PolicyVersion(0),
            Statements()
            {}

        FUpdatePolicyRequest(const FUpdatePolicyRequest& src) = default;

        FUpdatePolicyRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePolicyRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdatePolicyResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The name of the policy that was updated.
        FString PolicyName;

        // [optional] The statements included in the new version of the policy.
        TArray<FPermissionStatement> Statements;
        FUpdatePolicyResponse() :
            FPlayFabCppResultCommon(),
            PolicyName(),
            Statements()
            {}

        FUpdatePolicyResponse(const FUpdatePolicyResponse& src) = default;

        FUpdatePolicyResponse(const TSharedPtr<FJsonObject>& obj) : FUpdatePolicyResponse()
        {
            readFromValue(obj);
        }

        ~FUpdatePolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateRandomResultTablesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] which catalog is being updated. If null, update the current default catalog version
        FString CatalogVersion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] array of random result tables to make available (Note: specifying an existing TableId will result in overwriting that
         * table, while any others will be added to the available set)
         */
        TArray<FRandomResultTable> Tables;
        FUpdateRandomResultTablesRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion(),
            CustomTags(),
            Tables()
            {}

        FUpdateRandomResultTablesRequest(const FUpdateRandomResultTablesRequest& src) = default;

        FUpdateRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateRandomResultTablesRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateRandomResultTablesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateRandomResultTablesResult : public PlayFab::FPlayFabCppResultCommon
    {
        FUpdateRandomResultTablesResult() :
            FPlayFabCppResultCommon()
            {}

        FUpdateRandomResultTablesResult(const FUpdateRandomResultTablesResult& src) = default;

        FUpdateRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FUpdateRandomResultTablesResult()
        {
            readFromValue(obj);
        }

        ~FUpdateRandomResultTablesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateSegmentRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // Segment model with all of the segment properties data.
        FSegmentModel pfSegmentModel;

        FUpdateSegmentRequest() :
            FPlayFabCppRequestCommon(),
            pfSegmentModel()
            {}

        FUpdateSegmentRequest(const FUpdateSegmentRequest& src) = default;

        FUpdateSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateSegmentRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateSegmentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateSegmentResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Error message.
        FString ErrorMessage;

        // [optional] Segment id.
        FString SegmentId;

        FUpdateSegmentResponse() :
            FPlayFabCppResultCommon(),
            ErrorMessage(),
            SegmentId()
            {}

        FUpdateSegmentResponse(const FUpdateSegmentResponse& src) = default;

        FUpdateSegmentResponse(const TSharedPtr<FJsonObject>& obj) : FUpdateSegmentResponse()
        {
            readFromValue(obj);
        }

        ~FUpdateSegmentResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateStoreItemsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] Catalog version of the store to update. If null, uses the default catalog.
        FString CatalogVersion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Additional data about the store
        TSharedPtr<FStoreMarketingModel> MarketingData;

        // [optional] Array of store items - references to catalog items, with specific pricing - to be added
        TArray<FStoreItem> Store;
        // Unique identifier for the store which is to be updated
        FString StoreId;

        FUpdateStoreItemsRequest() :
            FPlayFabCppRequestCommon(),
            CatalogVersion(),
            CustomTags(),
            MarketingData(nullptr),
            Store(),
            StoreId()
            {}

        FUpdateStoreItemsRequest(const FUpdateStoreItemsRequest& src) = default;

        FUpdateStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateStoreItemsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateStoreItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateStoreItemsResult : public PlayFab::FPlayFabCppResultCommon
    {
        FUpdateStoreItemsResult() :
            FPlayFabCppResultCommon()
            {}

        FUpdateStoreItemsResult(const FUpdateStoreItemsResult& src) = default;

        FUpdateStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateStoreItemsResult()
        {
            readFromValue(obj);
        }

        ~FUpdateStoreItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateTaskRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Description the task
        FString Description;

        // [optional] Specify either the task ID or the name of the task to be updated.
        TSharedPtr<FNameIdentifier> Identifier;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // [optional] Parameter object specific to the task type. See each task type's create API documentation for details.
        FJsonKeeper Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        // Task type.
        ScheduledTaskType Type;

        FUpdateTaskRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Description(),
            Identifier(nullptr),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule(),
            Type()
            {}

        FUpdateTaskRequest(const FUpdateTaskRequest& src) = default;

        FUpdateTaskRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateTaskRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateUserDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
        Boxed<UserDataPermission> Permission;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserDataRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Data(),
            KeysToRemove(),
            Permission(),
            PlayFabId()
            {}

        FUpdateUserDataRequest(const FUpdateUserDataRequest& src) = default;

        FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateUserDataResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FUpdateUserDataResult() :
            FPlayFabCppResultCommon(),
            DataVersion(0)
            {}

        FUpdateUserDataResult(const FUpdateUserDataResult& src) = default;

        FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateUserInternalDataRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserInternalDataRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Data(),
            KeysToRemove(),
            PlayFabId()
            {}

        FUpdateUserInternalDataRequest(const FUpdateUserInternalDataRequest& src) = default;

        FUpdateUserInternalDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInternalDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserInternalDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateUserTitleDisplayNameRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // New title display name for the user - must be between 3 and 25 characters
        FString DisplayName;

        // PlayFab unique identifier of the user whose title specific display name is to be changed
        FString PlayFabId;

        FUpdateUserTitleDisplayNameRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            DisplayName(),
            PlayFabId()
            {}

        FUpdateUserTitleDisplayNameRequest(const FUpdateUserTitleDisplayNameRequest& src) = default;

        FUpdateUserTitleDisplayNameRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserTitleDisplayNameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateUserTitleDisplayNameResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] current title display name for the user (this will be the original display name if the rename attempt failed)
        FString DisplayName;

        FUpdateUserTitleDisplayNameResult() :
            FPlayFabCppResultCommon(),
            DisplayName()
            {}

        FUpdateUserTitleDisplayNameResult(const FUpdateUserTitleDisplayNameResult& src) = default;

        FUpdateUserTitleDisplayNameResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserTitleDisplayNameResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
