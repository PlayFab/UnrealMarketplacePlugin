//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!

#include "Core/PlayFabMultiplayerDataModels.h"
#include "Core/PlayFabJsonHelpers.h"

using namespace PlayFab;
using namespace PlayFab::MultiplayerModels;

PlayFab::MultiplayerModels::FAssetReference::~FAssetReference()
{

}

void PlayFab::MultiplayerModels::FAssetReference::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (FileName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    if (MountPath.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("MountPath"));
        writer->WriteValue(MountPath);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FAssetReference::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MountPathValue = obj->TryGetField(TEXT("MountPath"));
    if (MountPathValue.IsValid() && !MountPathValue->IsNull())
    {
        FString TmpValue;
        if (MountPathValue->TryGetString(TmpValue)) { MountPath = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FAssetReferenceParams::~FAssetReferenceParams()
{

}

void PlayFab::MultiplayerModels::FAssetReferenceParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!FileName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: AssetReferenceParams::FileName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    if (MountPath.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("MountPath"));
        writer->WriteValue(MountPath);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FAssetReferenceParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MountPathValue = obj->TryGetField(TEXT("MountPath"));
    if (MountPathValue.IsValid() && !MountPathValue->IsNull())
    {
        FString TmpValue;
        if (MountPathValue->TryGetString(TmpValue)) { MountPath = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FAssetSummary::~FAssetSummary()
{

}

void PlayFab::MultiplayerModels::FAssetSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (FileName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FAssetSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeAzureRegionEnumJSON(AzureRegion enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case AzureRegionAustraliaEast: writer->WriteValue(TEXT("AustraliaEast")); break;
    case AzureRegionAustraliaSoutheast: writer->WriteValue(TEXT("AustraliaSoutheast")); break;
    case AzureRegionBrazilSouth: writer->WriteValue(TEXT("BrazilSouth")); break;
    case AzureRegionCentralUs: writer->WriteValue(TEXT("CentralUs")); break;
    case AzureRegionEastAsia: writer->WriteValue(TEXT("EastAsia")); break;
    case AzureRegionEastUs: writer->WriteValue(TEXT("EastUs")); break;
    case AzureRegionEastUs2: writer->WriteValue(TEXT("EastUs2")); break;
    case AzureRegionJapanEast: writer->WriteValue(TEXT("JapanEast")); break;
    case AzureRegionJapanWest: writer->WriteValue(TEXT("JapanWest")); break;
    case AzureRegionNorthCentralUs: writer->WriteValue(TEXT("NorthCentralUs")); break;
    case AzureRegionNorthEurope: writer->WriteValue(TEXT("NorthEurope")); break;
    case AzureRegionSouthCentralUs: writer->WriteValue(TEXT("SouthCentralUs")); break;
    case AzureRegionSoutheastAsia: writer->WriteValue(TEXT("SoutheastAsia")); break;
    case AzureRegionWestEurope: writer->WriteValue(TEXT("WestEurope")); break;
    case AzureRegionWestUs: writer->WriteValue(TEXT("WestUs")); break;
    case AzureRegionSouthAfricaNorth: writer->WriteValue(TEXT("SouthAfricaNorth")); break;
    case AzureRegionWestCentralUs: writer->WriteValue(TEXT("WestCentralUs")); break;
    case AzureRegionKoreaCentral: writer->WriteValue(TEXT("KoreaCentral")); break;
    case AzureRegionFranceCentral: writer->WriteValue(TEXT("FranceCentral")); break;
    case AzureRegionWestUs2: writer->WriteValue(TEXT("WestUs2")); break;
    case AzureRegionCentralIndia: writer->WriteValue(TEXT("CentralIndia")); break;
    case AzureRegionUaeNorth: writer->WriteValue(TEXT("UaeNorth")); break;
    case AzureRegionUkSouth: writer->WriteValue(TEXT("UkSouth")); break;
    }
}

MultiplayerModels::AzureRegion PlayFab::MultiplayerModels::readAzureRegionFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readAzureRegionFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::AzureRegion PlayFab::MultiplayerModels::readAzureRegionFromValue(const FString& value)
{
    static TMap<FString, AzureRegion> _AzureRegionMap;
    if (_AzureRegionMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _AzureRegionMap.Add(TEXT("AustraliaEast"), AzureRegionAustraliaEast);
        _AzureRegionMap.Add(TEXT("AustraliaSoutheast"), AzureRegionAustraliaSoutheast);
        _AzureRegionMap.Add(TEXT("BrazilSouth"), AzureRegionBrazilSouth);
        _AzureRegionMap.Add(TEXT("CentralUs"), AzureRegionCentralUs);
        _AzureRegionMap.Add(TEXT("EastAsia"), AzureRegionEastAsia);
        _AzureRegionMap.Add(TEXT("EastUs"), AzureRegionEastUs);
        _AzureRegionMap.Add(TEXT("EastUs2"), AzureRegionEastUs2);
        _AzureRegionMap.Add(TEXT("JapanEast"), AzureRegionJapanEast);
        _AzureRegionMap.Add(TEXT("JapanWest"), AzureRegionJapanWest);
        _AzureRegionMap.Add(TEXT("NorthCentralUs"), AzureRegionNorthCentralUs);
        _AzureRegionMap.Add(TEXT("NorthEurope"), AzureRegionNorthEurope);
        _AzureRegionMap.Add(TEXT("SouthCentralUs"), AzureRegionSouthCentralUs);
        _AzureRegionMap.Add(TEXT("SoutheastAsia"), AzureRegionSoutheastAsia);
        _AzureRegionMap.Add(TEXT("WestEurope"), AzureRegionWestEurope);
        _AzureRegionMap.Add(TEXT("WestUs"), AzureRegionWestUs);
        _AzureRegionMap.Add(TEXT("SouthAfricaNorth"), AzureRegionSouthAfricaNorth);
        _AzureRegionMap.Add(TEXT("WestCentralUs"), AzureRegionWestCentralUs);
        _AzureRegionMap.Add(TEXT("KoreaCentral"), AzureRegionKoreaCentral);
        _AzureRegionMap.Add(TEXT("FranceCentral"), AzureRegionFranceCentral);
        _AzureRegionMap.Add(TEXT("WestUs2"), AzureRegionWestUs2);
        _AzureRegionMap.Add(TEXT("CentralIndia"), AzureRegionCentralIndia);
        _AzureRegionMap.Add(TEXT("UaeNorth"), AzureRegionUaeNorth);
        _AzureRegionMap.Add(TEXT("UkSouth"), AzureRegionUkSouth);

    }

    if (!value.IsEmpty())
    {
        auto output = _AzureRegionMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return AzureRegionAustraliaEast; // Basically critical fail
}

void PlayFab::MultiplayerModels::writeAzureVmFamilyEnumJSON(AzureVmFamily enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case AzureVmFamilyA: writer->WriteValue(TEXT("A")); break;
    case AzureVmFamilyAv2: writer->WriteValue(TEXT("Av2")); break;
    case AzureVmFamilyDv2: writer->WriteValue(TEXT("Dv2")); break;
    case AzureVmFamilyDv3: writer->WriteValue(TEXT("Dv3")); break;
    case AzureVmFamilyF: writer->WriteValue(TEXT("F")); break;
    case AzureVmFamilyFsv2: writer->WriteValue(TEXT("Fsv2")); break;
    case AzureVmFamilyDasv4: writer->WriteValue(TEXT("Dasv4")); break;
    case AzureVmFamilyDav4: writer->WriteValue(TEXT("Dav4")); break;
    case AzureVmFamilyEav4: writer->WriteValue(TEXT("Eav4")); break;
    case AzureVmFamilyEasv4: writer->WriteValue(TEXT("Easv4")); break;
    case AzureVmFamilyEv4: writer->WriteValue(TEXT("Ev4")); break;
    case AzureVmFamilyEsv4: writer->WriteValue(TEXT("Esv4")); break;
    case AzureVmFamilyDsv3: writer->WriteValue(TEXT("Dsv3")); break;
    case AzureVmFamilyDsv2: writer->WriteValue(TEXT("Dsv2")); break;
    case AzureVmFamilyNCasT4_v3: writer->WriteValue(TEXT("NCasT4_v3")); break;
    case AzureVmFamilyDdv4: writer->WriteValue(TEXT("Ddv4")); break;
    case AzureVmFamilyDdsv4: writer->WriteValue(TEXT("Ddsv4")); break;
    case AzureVmFamilyHBv3: writer->WriteValue(TEXT("HBv3")); break;
    }
}

MultiplayerModels::AzureVmFamily PlayFab::MultiplayerModels::readAzureVmFamilyFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readAzureVmFamilyFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::AzureVmFamily PlayFab::MultiplayerModels::readAzureVmFamilyFromValue(const FString& value)
{
    static TMap<FString, AzureVmFamily> _AzureVmFamilyMap;
    if (_AzureVmFamilyMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _AzureVmFamilyMap.Add(TEXT("A"), AzureVmFamilyA);
        _AzureVmFamilyMap.Add(TEXT("Av2"), AzureVmFamilyAv2);
        _AzureVmFamilyMap.Add(TEXT("Dv2"), AzureVmFamilyDv2);
        _AzureVmFamilyMap.Add(TEXT("Dv3"), AzureVmFamilyDv3);
        _AzureVmFamilyMap.Add(TEXT("F"), AzureVmFamilyF);
        _AzureVmFamilyMap.Add(TEXT("Fsv2"), AzureVmFamilyFsv2);
        _AzureVmFamilyMap.Add(TEXT("Dasv4"), AzureVmFamilyDasv4);
        _AzureVmFamilyMap.Add(TEXT("Dav4"), AzureVmFamilyDav4);
        _AzureVmFamilyMap.Add(TEXT("Eav4"), AzureVmFamilyEav4);
        _AzureVmFamilyMap.Add(TEXT("Easv4"), AzureVmFamilyEasv4);
        _AzureVmFamilyMap.Add(TEXT("Ev4"), AzureVmFamilyEv4);
        _AzureVmFamilyMap.Add(TEXT("Esv4"), AzureVmFamilyEsv4);
        _AzureVmFamilyMap.Add(TEXT("Dsv3"), AzureVmFamilyDsv3);
        _AzureVmFamilyMap.Add(TEXT("Dsv2"), AzureVmFamilyDsv2);
        _AzureVmFamilyMap.Add(TEXT("NCasT4_v3"), AzureVmFamilyNCasT4_v3);
        _AzureVmFamilyMap.Add(TEXT("Ddv4"), AzureVmFamilyDdv4);
        _AzureVmFamilyMap.Add(TEXT("Ddsv4"), AzureVmFamilyDdsv4);
        _AzureVmFamilyMap.Add(TEXT("HBv3"), AzureVmFamilyHBv3);

    }

    if (!value.IsEmpty())
    {
        auto output = _AzureVmFamilyMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return AzureVmFamilyA; // Basically critical fail
}

void PlayFab::MultiplayerModels::writeAzureVmSizeEnumJSON(AzureVmSize enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case AzureVmSizeStandard_A1: writer->WriteValue(TEXT("Standard_A1")); break;
    case AzureVmSizeStandard_A2: writer->WriteValue(TEXT("Standard_A2")); break;
    case AzureVmSizeStandard_A3: writer->WriteValue(TEXT("Standard_A3")); break;
    case AzureVmSizeStandard_A4: writer->WriteValue(TEXT("Standard_A4")); break;
    case AzureVmSizeStandard_A1_v2: writer->WriteValue(TEXT("Standard_A1_v2")); break;
    case AzureVmSizeStandard_A2_v2: writer->WriteValue(TEXT("Standard_A2_v2")); break;
    case AzureVmSizeStandard_A4_v2: writer->WriteValue(TEXT("Standard_A4_v2")); break;
    case AzureVmSizeStandard_A8_v2: writer->WriteValue(TEXT("Standard_A8_v2")); break;
    case AzureVmSizeStandard_D1_v2: writer->WriteValue(TEXT("Standard_D1_v2")); break;
    case AzureVmSizeStandard_D2_v2: writer->WriteValue(TEXT("Standard_D2_v2")); break;
    case AzureVmSizeStandard_D3_v2: writer->WriteValue(TEXT("Standard_D3_v2")); break;
    case AzureVmSizeStandard_D4_v2: writer->WriteValue(TEXT("Standard_D4_v2")); break;
    case AzureVmSizeStandard_D5_v2: writer->WriteValue(TEXT("Standard_D5_v2")); break;
    case AzureVmSizeStandard_D2_v3: writer->WriteValue(TEXT("Standard_D2_v3")); break;
    case AzureVmSizeStandard_D4_v3: writer->WriteValue(TEXT("Standard_D4_v3")); break;
    case AzureVmSizeStandard_D8_v3: writer->WriteValue(TEXT("Standard_D8_v3")); break;
    case AzureVmSizeStandard_D16_v3: writer->WriteValue(TEXT("Standard_D16_v3")); break;
    case AzureVmSizeStandard_F1: writer->WriteValue(TEXT("Standard_F1")); break;
    case AzureVmSizeStandard_F2: writer->WriteValue(TEXT("Standard_F2")); break;
    case AzureVmSizeStandard_F4: writer->WriteValue(TEXT("Standard_F4")); break;
    case AzureVmSizeStandard_F8: writer->WriteValue(TEXT("Standard_F8")); break;
    case AzureVmSizeStandard_F16: writer->WriteValue(TEXT("Standard_F16")); break;
    case AzureVmSizeStandard_F2s_v2: writer->WriteValue(TEXT("Standard_F2s_v2")); break;
    case AzureVmSizeStandard_F4s_v2: writer->WriteValue(TEXT("Standard_F4s_v2")); break;
    case AzureVmSizeStandard_F8s_v2: writer->WriteValue(TEXT("Standard_F8s_v2")); break;
    case AzureVmSizeStandard_F16s_v2: writer->WriteValue(TEXT("Standard_F16s_v2")); break;
    case AzureVmSizeStandard_D2as_v4: writer->WriteValue(TEXT("Standard_D2as_v4")); break;
    case AzureVmSizeStandard_D4as_v4: writer->WriteValue(TEXT("Standard_D4as_v4")); break;
    case AzureVmSizeStandard_D8as_v4: writer->WriteValue(TEXT("Standard_D8as_v4")); break;
    case AzureVmSizeStandard_D16as_v4: writer->WriteValue(TEXT("Standard_D16as_v4")); break;
    case AzureVmSizeStandard_D2a_v4: writer->WriteValue(TEXT("Standard_D2a_v4")); break;
    case AzureVmSizeStandard_D4a_v4: writer->WriteValue(TEXT("Standard_D4a_v4")); break;
    case AzureVmSizeStandard_D8a_v4: writer->WriteValue(TEXT("Standard_D8a_v4")); break;
    case AzureVmSizeStandard_D16a_v4: writer->WriteValue(TEXT("Standard_D16a_v4")); break;
    case AzureVmSizeStandard_E2a_v4: writer->WriteValue(TEXT("Standard_E2a_v4")); break;
    case AzureVmSizeStandard_E4a_v4: writer->WriteValue(TEXT("Standard_E4a_v4")); break;
    case AzureVmSizeStandard_E8a_v4: writer->WriteValue(TEXT("Standard_E8a_v4")); break;
    case AzureVmSizeStandard_E16a_v4: writer->WriteValue(TEXT("Standard_E16a_v4")); break;
    case AzureVmSizeStandard_E2as_v4: writer->WriteValue(TEXT("Standard_E2as_v4")); break;
    case AzureVmSizeStandard_E4as_v4: writer->WriteValue(TEXT("Standard_E4as_v4")); break;
    case AzureVmSizeStandard_E8as_v4: writer->WriteValue(TEXT("Standard_E8as_v4")); break;
    case AzureVmSizeStandard_E16as_v4: writer->WriteValue(TEXT("Standard_E16as_v4")); break;
    case AzureVmSizeStandard_D2s_v3: writer->WriteValue(TEXT("Standard_D2s_v3")); break;
    case AzureVmSizeStandard_D4s_v3: writer->WriteValue(TEXT("Standard_D4s_v3")); break;
    case AzureVmSizeStandard_D8s_v3: writer->WriteValue(TEXT("Standard_D8s_v3")); break;
    case AzureVmSizeStandard_D16s_v3: writer->WriteValue(TEXT("Standard_D16s_v3")); break;
    case AzureVmSizeStandard_DS1_v2: writer->WriteValue(TEXT("Standard_DS1_v2")); break;
    case AzureVmSizeStandard_DS2_v2: writer->WriteValue(TEXT("Standard_DS2_v2")); break;
    case AzureVmSizeStandard_DS3_v2: writer->WriteValue(TEXT("Standard_DS3_v2")); break;
    case AzureVmSizeStandard_DS4_v2: writer->WriteValue(TEXT("Standard_DS4_v2")); break;
    case AzureVmSizeStandard_DS5_v2: writer->WriteValue(TEXT("Standard_DS5_v2")); break;
    case AzureVmSizeStandard_NC4as_T4_v3: writer->WriteValue(TEXT("Standard_NC4as_T4_v3")); break;
    case AzureVmSizeStandard_D2d_v4: writer->WriteValue(TEXT("Standard_D2d_v4")); break;
    case AzureVmSizeStandard_D4d_v4: writer->WriteValue(TEXT("Standard_D4d_v4")); break;
    case AzureVmSizeStandard_D8d_v4: writer->WriteValue(TEXT("Standard_D8d_v4")); break;
    case AzureVmSizeStandard_D16d_v4: writer->WriteValue(TEXT("Standard_D16d_v4")); break;
    case AzureVmSizeStandard_D2ds_v4: writer->WriteValue(TEXT("Standard_D2ds_v4")); break;
    case AzureVmSizeStandard_D4ds_v4: writer->WriteValue(TEXT("Standard_D4ds_v4")); break;
    case AzureVmSizeStandard_D8ds_v4: writer->WriteValue(TEXT("Standard_D8ds_v4")); break;
    case AzureVmSizeStandard_D16ds_v4: writer->WriteValue(TEXT("Standard_D16ds_v4")); break;
    case AzureVmSizeStandard_HB120_16rs_v3: writer->WriteValue(TEXT("Standard_HB120_16rs_v3")); break;
    case AzureVmSizeStandard_HB120_32rs_v3: writer->WriteValue(TEXT("Standard_HB120_32rs_v3")); break;
    case AzureVmSizeStandard_HB120_64rs_v3: writer->WriteValue(TEXT("Standard_HB120_64rs_v3")); break;
    case AzureVmSizeStandard_HB120_96rs_v3: writer->WriteValue(TEXT("Standard_HB120_96rs_v3")); break;
    case AzureVmSizeStandard_HB120rs_v3: writer->WriteValue(TEXT("Standard_HB120rs_v3")); break;
    }
}

MultiplayerModels::AzureVmSize PlayFab::MultiplayerModels::readAzureVmSizeFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readAzureVmSizeFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::AzureVmSize PlayFab::MultiplayerModels::readAzureVmSizeFromValue(const FString& value)
{
    static TMap<FString, AzureVmSize> _AzureVmSizeMap;
    if (_AzureVmSizeMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _AzureVmSizeMap.Add(TEXT("Standard_A1"), AzureVmSizeStandard_A1);
        _AzureVmSizeMap.Add(TEXT("Standard_A2"), AzureVmSizeStandard_A2);
        _AzureVmSizeMap.Add(TEXT("Standard_A3"), AzureVmSizeStandard_A3);
        _AzureVmSizeMap.Add(TEXT("Standard_A4"), AzureVmSizeStandard_A4);
        _AzureVmSizeMap.Add(TEXT("Standard_A1_v2"), AzureVmSizeStandard_A1_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A2_v2"), AzureVmSizeStandard_A2_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A4_v2"), AzureVmSizeStandard_A4_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_A8_v2"), AzureVmSizeStandard_A8_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D1_v2"), AzureVmSizeStandard_D1_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D2_v2"), AzureVmSizeStandard_D2_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D3_v2"), AzureVmSizeStandard_D3_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D4_v2"), AzureVmSizeStandard_D4_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D5_v2"), AzureVmSizeStandard_D5_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D2_v3"), AzureVmSizeStandard_D2_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D4_v3"), AzureVmSizeStandard_D4_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D8_v3"), AzureVmSizeStandard_D8_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D16_v3"), AzureVmSizeStandard_D16_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_F1"), AzureVmSizeStandard_F1);
        _AzureVmSizeMap.Add(TEXT("Standard_F2"), AzureVmSizeStandard_F2);
        _AzureVmSizeMap.Add(TEXT("Standard_F4"), AzureVmSizeStandard_F4);
        _AzureVmSizeMap.Add(TEXT("Standard_F8"), AzureVmSizeStandard_F8);
        _AzureVmSizeMap.Add(TEXT("Standard_F16"), AzureVmSizeStandard_F16);
        _AzureVmSizeMap.Add(TEXT("Standard_F2s_v2"), AzureVmSizeStandard_F2s_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_F4s_v2"), AzureVmSizeStandard_F4s_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_F8s_v2"), AzureVmSizeStandard_F8s_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_F16s_v2"), AzureVmSizeStandard_F16s_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_D2as_v4"), AzureVmSizeStandard_D2as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D4as_v4"), AzureVmSizeStandard_D4as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D8as_v4"), AzureVmSizeStandard_D8as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D16as_v4"), AzureVmSizeStandard_D16as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D2a_v4"), AzureVmSizeStandard_D2a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D4a_v4"), AzureVmSizeStandard_D4a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D8a_v4"), AzureVmSizeStandard_D8a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D16a_v4"), AzureVmSizeStandard_D16a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E2a_v4"), AzureVmSizeStandard_E2a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E4a_v4"), AzureVmSizeStandard_E4a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E8a_v4"), AzureVmSizeStandard_E8a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E16a_v4"), AzureVmSizeStandard_E16a_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E2as_v4"), AzureVmSizeStandard_E2as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E4as_v4"), AzureVmSizeStandard_E4as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E8as_v4"), AzureVmSizeStandard_E8as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_E16as_v4"), AzureVmSizeStandard_E16as_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D2s_v3"), AzureVmSizeStandard_D2s_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D4s_v3"), AzureVmSizeStandard_D4s_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D8s_v3"), AzureVmSizeStandard_D8s_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D16s_v3"), AzureVmSizeStandard_D16s_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_DS1_v2"), AzureVmSizeStandard_DS1_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_DS2_v2"), AzureVmSizeStandard_DS2_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_DS3_v2"), AzureVmSizeStandard_DS3_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_DS4_v2"), AzureVmSizeStandard_DS4_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_DS5_v2"), AzureVmSizeStandard_DS5_v2);
        _AzureVmSizeMap.Add(TEXT("Standard_NC4as_T4_v3"), AzureVmSizeStandard_NC4as_T4_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_D2d_v4"), AzureVmSizeStandard_D2d_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D4d_v4"), AzureVmSizeStandard_D4d_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D8d_v4"), AzureVmSizeStandard_D8d_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D16d_v4"), AzureVmSizeStandard_D16d_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D2ds_v4"), AzureVmSizeStandard_D2ds_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D4ds_v4"), AzureVmSizeStandard_D4ds_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D8ds_v4"), AzureVmSizeStandard_D8ds_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_D16ds_v4"), AzureVmSizeStandard_D16ds_v4);
        _AzureVmSizeMap.Add(TEXT("Standard_HB120_16rs_v3"), AzureVmSizeStandard_HB120_16rs_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_HB120_32rs_v3"), AzureVmSizeStandard_HB120_32rs_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_HB120_64rs_v3"), AzureVmSizeStandard_HB120_64rs_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_HB120_96rs_v3"), AzureVmSizeStandard_HB120_96rs_v3);
        _AzureVmSizeMap.Add(TEXT("Standard_HB120rs_v3"), AzureVmSizeStandard_HB120rs_v3);

    }

    if (!value.IsEmpty())
    {
        auto output = _AzureVmSizeMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return AzureVmSizeStandard_A1; // Basically critical fail
}

PlayFab::MultiplayerModels::FBuildSelectionCriterion::~FBuildSelectionCriterion()
{

}

void PlayFab::MultiplayerModels::FBuildSelectionCriterion::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildWeightDistribution.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("BuildWeightDistribution"));
        for (TMap<FString, uint32>::TConstIterator It(BuildWeightDistribution); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue(static_cast<int64>((*It).Value));
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildSelectionCriterion::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* BuildWeightDistributionObject;
    if (obj->TryGetObjectField(TEXT("BuildWeightDistribution"), BuildWeightDistributionObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*BuildWeightDistributionObject)->Values); It; ++It)
        {
            uint32 TmpValue; It.Value()->TryGetNumber(TmpValue);
            BuildWeightDistribution.Add(It.Key(), TmpValue);
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildAliasDetailsResponse::~FBuildAliasDetailsResponse()
{

}

void PlayFab::MultiplayerModels::FBuildAliasDetailsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AliasId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("AliasId"));
        writer->WriteValue(AliasId);
    }

    if (AliasName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("AliasName"));
        writer->WriteValue(AliasName);
    }

    if (BuildSelectionCriteria.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BuildSelectionCriteria"));
        for (const FBuildSelectionCriterion& item : BuildSelectionCriteria)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildAliasDetailsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AliasIdValue = obj->TryGetField(TEXT("AliasId"));
    if (AliasIdValue.IsValid() && !AliasIdValue->IsNull())
    {
        FString TmpValue;
        if (AliasIdValue->TryGetString(TmpValue)) { AliasId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> AliasNameValue = obj->TryGetField(TEXT("AliasName"));
    if (AliasNameValue.IsValid() && !AliasNameValue->IsNull())
    {
        FString TmpValue;
        if (AliasNameValue->TryGetString(TmpValue)) { AliasName = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&BuildSelectionCriteriaArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildSelectionCriteria"));
    for (int32 Idx = 0; Idx < BuildSelectionCriteriaArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildSelectionCriteriaArray[Idx];
        BuildSelectionCriteria.Add(FBuildSelectionCriterion(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildAliasParams::~FBuildAliasParams()
{

}

void PlayFab::MultiplayerModels::FBuildAliasParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!AliasId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: BuildAliasParams::AliasId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("AliasId"));
        writer->WriteValue(AliasId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildAliasParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AliasIdValue = obj->TryGetField(TEXT("AliasId"));
    if (AliasIdValue.IsValid() && !AliasIdValue->IsNull())
    {
        FString TmpValue;
        if (AliasIdValue->TryGetString(TmpValue)) { AliasId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCurrentServerStats::~FCurrentServerStats()
{

}

void PlayFab::MultiplayerModels::FCurrentServerStats::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Active"));
    writer->WriteValue(Active);

    writer->WriteIdentifierPrefix(TEXT("Propping"));
    writer->WriteValue(Propping);

    writer->WriteIdentifierPrefix(TEXT("StandingBy"));
    writer->WriteValue(StandingBy);

    writer->WriteIdentifierPrefix(TEXT("Total"));
    writer->WriteValue(Total);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCurrentServerStats::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ActiveValue = obj->TryGetField(TEXT("Active"));
    if (ActiveValue.IsValid() && !ActiveValue->IsNull())
    {
        int32 TmpValue;
        if (ActiveValue->TryGetNumber(TmpValue)) { Active = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ProppingValue = obj->TryGetField(TEXT("Propping"));
    if (ProppingValue.IsValid() && !ProppingValue->IsNull())
    {
        int32 TmpValue;
        if (ProppingValue->TryGetNumber(TmpValue)) { Propping = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StandingByValue = obj->TryGetField(TEXT("StandingBy"));
    if (StandingByValue.IsValid() && !StandingByValue->IsNull())
    {
        int32 TmpValue;
        if (StandingByValue->TryGetNumber(TmpValue)) { StandingBy = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TotalValue = obj->TryGetField(TEXT("Total"));
    if (TotalValue.IsValid() && !TotalValue->IsNull())
    {
        int32 TmpValue;
        if (TotalValue->TryGetNumber(TmpValue)) { Total = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDynamicStandbyThreshold::~FDynamicStandbyThreshold()
{

}

void PlayFab::MultiplayerModels::FDynamicStandbyThreshold::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Multiplier"));
    writer->WriteValue(Multiplier);

    writer->WriteIdentifierPrefix(TEXT("TriggerThresholdPercentage"));
    writer->WriteValue(TriggerThresholdPercentage);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDynamicStandbyThreshold::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MultiplierValue = obj->TryGetField(TEXT("Multiplier"));
    if (MultiplierValue.IsValid() && !MultiplierValue->IsNull())
    {
        double TmpValue;
        if (MultiplierValue->TryGetNumber(TmpValue)) { Multiplier = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TriggerThresholdPercentageValue = obj->TryGetField(TEXT("TriggerThresholdPercentage"));
    if (TriggerThresholdPercentageValue.IsValid() && !TriggerThresholdPercentageValue->IsNull())
    {
        double TmpValue;
        if (TriggerThresholdPercentageValue->TryGetNumber(TmpValue)) { TriggerThresholdPercentage = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDynamicStandbySettings::~FDynamicStandbySettings()
{

}

void PlayFab::MultiplayerModels::FDynamicStandbySettings::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DynamicFloorMultiplierThresholds.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("DynamicFloorMultiplierThresholds"));
        for (const FDynamicStandbyThreshold& item : DynamicFloorMultiplierThresholds)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("IsEnabled"));
    writer->WriteValue(IsEnabled);

    if (RampDownSeconds.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("RampDownSeconds"));
        writer->WriteValue(RampDownSeconds);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDynamicStandbySettings::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&DynamicFloorMultiplierThresholdsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("DynamicFloorMultiplierThresholds"));
    for (int32 Idx = 0; Idx < DynamicFloorMultiplierThresholdsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = DynamicFloorMultiplierThresholdsArray[Idx];
        DynamicFloorMultiplierThresholds.Add(FDynamicStandbyThreshold(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> IsEnabledValue = obj->TryGetField(TEXT("IsEnabled"));
    if (IsEnabledValue.IsValid() && !IsEnabledValue->IsNull())
    {
        bool TmpValue;
        if (IsEnabledValue->TryGetBool(TmpValue)) { IsEnabled = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RampDownSecondsValue = obj->TryGetField(TEXT("RampDownSeconds"));
    if (RampDownSecondsValue.IsValid() && !RampDownSecondsValue->IsNull())
    {
        int32 TmpValue;
        if (RampDownSecondsValue->TryGetNumber(TmpValue)) { RampDownSeconds = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FSchedule::~FSchedule()
{

}

void PlayFab::MultiplayerModels::FSchedule::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Description.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Description"));
        writer->WriteValue(Description);
    }

    writer->WriteIdentifierPrefix(TEXT("EndTime"));
    writeDatetime(EndTime, writer);

    writer->WriteIdentifierPrefix(TEXT("IsDisabled"));
    writer->WriteValue(IsDisabled);

    writer->WriteIdentifierPrefix(TEXT("IsRecurringWeekly"));
    writer->WriteValue(IsRecurringWeekly);

    writer->WriteIdentifierPrefix(TEXT("StartTime"));
    writeDatetime(StartTime, writer);

    writer->WriteIdentifierPrefix(TEXT("TargetStandby"));
    writer->WriteValue(TargetStandby);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FSchedule::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DescriptionValue = obj->TryGetField(TEXT("Description"));
    if (DescriptionValue.IsValid() && !DescriptionValue->IsNull())
    {
        FString TmpValue;
        if (DescriptionValue->TryGetString(TmpValue)) { Description = TmpValue; }
    }

    const TSharedPtr<FJsonValue> EndTimeValue = obj->TryGetField(TEXT("EndTime"));
    if (EndTimeValue.IsValid())
        EndTime = readDatetime(EndTimeValue);


    const TSharedPtr<FJsonValue> IsDisabledValue = obj->TryGetField(TEXT("IsDisabled"));
    if (IsDisabledValue.IsValid() && !IsDisabledValue->IsNull())
    {
        bool TmpValue;
        if (IsDisabledValue->TryGetBool(TmpValue)) { IsDisabled = TmpValue; }
    }

    const TSharedPtr<FJsonValue> IsRecurringWeeklyValue = obj->TryGetField(TEXT("IsRecurringWeekly"));
    if (IsRecurringWeeklyValue.IsValid() && !IsRecurringWeeklyValue->IsNull())
    {
        bool TmpValue;
        if (IsRecurringWeeklyValue->TryGetBool(TmpValue)) { IsRecurringWeekly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StartTimeValue = obj->TryGetField(TEXT("StartTime"));
    if (StartTimeValue.IsValid())
        StartTime = readDatetime(StartTimeValue);


    const TSharedPtr<FJsonValue> TargetStandbyValue = obj->TryGetField(TEXT("TargetStandby"));
    if (TargetStandbyValue.IsValid() && !TargetStandbyValue->IsNull())
    {
        int32 TmpValue;
        if (TargetStandbyValue->TryGetNumber(TmpValue)) { TargetStandby = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FScheduledStandbySettings::~FScheduledStandbySettings()
{

}

void PlayFab::MultiplayerModels::FScheduledStandbySettings::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("IsEnabled"));
    writer->WriteValue(IsEnabled);

    if (ScheduleList.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ScheduleList"));
        for (const FSchedule& item : ScheduleList)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FScheduledStandbySettings::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IsEnabledValue = obj->TryGetField(TEXT("IsEnabled"));
    if (IsEnabledValue.IsValid() && !IsEnabledValue->IsNull())
    {
        bool TmpValue;
        if (IsEnabledValue->TryGetBool(TmpValue)) { IsEnabled = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&ScheduleListArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ScheduleList"));
    for (int32 Idx = 0; Idx < ScheduleListArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ScheduleListArray[Idx];
        ScheduleList.Add(FSchedule(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildRegion::~FBuildRegion()
{
    //if (CurrentServerStats != nullptr) delete CurrentServerStats;
    //if (DynamicStandbySettings != nullptr) delete DynamicStandbySettings;
    //if (ScheduledStandbySettings != nullptr) delete ScheduledStandbySettings;

}

void PlayFab::MultiplayerModels::FBuildRegion::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (pfCurrentServerStats.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("CurrentServerStats"));
        pfCurrentServerStats->writeJSON(writer);
    }

    if (pfDynamicStandbySettings.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("DynamicStandbySettings"));
        pfDynamicStandbySettings->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("MaxServers"));
    writer->WriteValue(MaxServers);

    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (pfScheduledStandbySettings.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("ScheduledStandbySettings"));
        pfScheduledStandbySettings->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("StandbyServers"));
    writer->WriteValue(StandbyServers);

    if (Status.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Status"));
        writer->WriteValue(Status);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildRegion::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> CurrentServerStatsValue = obj->TryGetField(TEXT("CurrentServerStats"));
    if (CurrentServerStatsValue.IsValid() && !CurrentServerStatsValue->IsNull())
    {
        pfCurrentServerStats = MakeShareable(new FCurrentServerStats(CurrentServerStatsValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> DynamicStandbySettingsValue = obj->TryGetField(TEXT("DynamicStandbySettings"));
    if (DynamicStandbySettingsValue.IsValid() && !DynamicStandbySettingsValue->IsNull())
    {
        pfDynamicStandbySettings = MakeShareable(new FDynamicStandbySettings(DynamicStandbySettingsValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> MaxServersValue = obj->TryGetField(TEXT("MaxServers"));
    if (MaxServersValue.IsValid() && !MaxServersValue->IsNull())
    {
        int32 TmpValue;
        if (MaxServersValue->TryGetNumber(TmpValue)) { MaxServers = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ScheduledStandbySettingsValue = obj->TryGetField(TEXT("ScheduledStandbySettings"));
    if (ScheduledStandbySettingsValue.IsValid() && !ScheduledStandbySettingsValue->IsNull())
    {
        pfScheduledStandbySettings = MakeShareable(new FScheduledStandbySettings(ScheduledStandbySettingsValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> StandbyServersValue = obj->TryGetField(TEXT("StandbyServers"));
    if (StandbyServersValue.IsValid() && !StandbyServersValue->IsNull())
    {
        int32 TmpValue;
        if (StandbyServersValue->TryGetNumber(TmpValue)) { StandbyServers = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StatusValue = obj->TryGetField(TEXT("Status"));
    if (StatusValue.IsValid() && !StatusValue->IsNull())
    {
        FString TmpValue;
        if (StatusValue->TryGetString(TmpValue)) { Status = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildRegionParams::~FBuildRegionParams()
{
    //if (DynamicStandbySettings != nullptr) delete DynamicStandbySettings;
    //if (ScheduledStandbySettings != nullptr) delete ScheduledStandbySettings;

}

void PlayFab::MultiplayerModels::FBuildRegionParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (pfDynamicStandbySettings.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("DynamicStandbySettings"));
        pfDynamicStandbySettings->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("MaxServers"));
    writer->WriteValue(MaxServers);

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: BuildRegionParams::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (pfScheduledStandbySettings.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("ScheduledStandbySettings"));
        pfScheduledStandbySettings->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("StandbyServers"));
    writer->WriteValue(StandbyServers);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildRegionParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DynamicStandbySettingsValue = obj->TryGetField(TEXT("DynamicStandbySettings"));
    if (DynamicStandbySettingsValue.IsValid() && !DynamicStandbySettingsValue->IsNull())
    {
        pfDynamicStandbySettings = MakeShareable(new FDynamicStandbySettings(DynamicStandbySettingsValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> MaxServersValue = obj->TryGetField(TEXT("MaxServers"));
    if (MaxServersValue.IsValid() && !MaxServersValue->IsNull())
    {
        int32 TmpValue;
        if (MaxServersValue->TryGetNumber(TmpValue)) { MaxServers = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ScheduledStandbySettingsValue = obj->TryGetField(TEXT("ScheduledStandbySettings"));
    if (ScheduledStandbySettingsValue.IsValid() && !ScheduledStandbySettingsValue->IsNull())
    {
        pfScheduledStandbySettings = MakeShareable(new FScheduledStandbySettings(ScheduledStandbySettingsValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> StandbyServersValue = obj->TryGetField(TEXT("StandbyServers"));
    if (StandbyServersValue.IsValid() && !StandbyServersValue->IsNull())
    {
        int32 TmpValue;
        if (StandbyServersValue->TryGetNumber(TmpValue)) { StandbyServers = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FBuildSummary::~FBuildSummary()
{

}

void PlayFab::MultiplayerModels::FBuildSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (BuildName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (CreationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("CreationTime"));
        writeDatetime(CreationTime, writer);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FBuildSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FEntityKey::~FEntityKey()
{

}

void PlayFab::MultiplayerModels::FEntityKey::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!Id.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: EntityKey::Id, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Id"));
        writer->WriteValue(Id);
    }

    if (Type.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Type"));
        writer->WriteValue(Type);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEntityKey::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IdValue = obj->TryGetField(TEXT("Id"));
    if (IdValue.IsValid() && !IdValue->IsNull())
    {
        FString TmpValue;
        if (IdValue->TryGetString(TmpValue)) { Id = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TypeValue = obj->TryGetField(TEXT("Type"));
    if (TypeValue.IsValid() && !TypeValue->IsNull())
    {
        FString TmpValue;
        if (TypeValue->TryGetString(TmpValue)) { Type = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelAllMatchmakingTicketsForPlayerRequest::~FCancelAllMatchmakingTicketsForPlayerRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::MultiplayerModels::FCancelAllMatchmakingTicketsForPlayerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CancelAllMatchmakingTicketsForPlayerRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelAllMatchmakingTicketsForPlayerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelAllMatchmakingTicketsForPlayerResult::~FCancelAllMatchmakingTicketsForPlayerResult()
{

}

void PlayFab::MultiplayerModels::FCancelAllMatchmakingTicketsForPlayerResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelAllMatchmakingTicketsForPlayerResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelAllServerBackfillTicketsForPlayerRequest::~FCancelAllServerBackfillTicketsForPlayerRequest()
{

}

void PlayFab::MultiplayerModels::FCancelAllServerBackfillTicketsForPlayerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("Entity"));
    Entity.writeJSON(writer);

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CancelAllServerBackfillTicketsForPlayerRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelAllServerBackfillTicketsForPlayerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = FEntityKey(EntityValue->AsObject());
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelAllServerBackfillTicketsForPlayerResult::~FCancelAllServerBackfillTicketsForPlayerResult()
{

}

void PlayFab::MultiplayerModels::FCancelAllServerBackfillTicketsForPlayerResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelAllServerBackfillTicketsForPlayerResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeCancellationReasonEnumJSON(CancellationReason enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case CancellationReasonRequested: writer->WriteValue(TEXT("Requested")); break;
    case CancellationReasonInternal: writer->WriteValue(TEXT("Internal")); break;
    case CancellationReasonTimeout: writer->WriteValue(TEXT("Timeout")); break;
    }
}

MultiplayerModels::CancellationReason PlayFab::MultiplayerModels::readCancellationReasonFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readCancellationReasonFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::CancellationReason PlayFab::MultiplayerModels::readCancellationReasonFromValue(const FString& value)
{
    static TMap<FString, CancellationReason> _CancellationReasonMap;
    if (_CancellationReasonMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _CancellationReasonMap.Add(TEXT("Requested"), CancellationReasonRequested);
        _CancellationReasonMap.Add(TEXT("Internal"), CancellationReasonInternal);
        _CancellationReasonMap.Add(TEXT("Timeout"), CancellationReasonTimeout);

    }

    if (!value.IsEmpty())
    {
        auto output = _CancellationReasonMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return CancellationReasonRequested; // Basically critical fail
}

PlayFab::MultiplayerModels::FCancelMatchmakingTicketRequest::~FCancelMatchmakingTicketRequest()
{

}

void PlayFab::MultiplayerModels::FCancelMatchmakingTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CancelMatchmakingTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CancelMatchmakingTicketRequest::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelMatchmakingTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelMatchmakingTicketResult::~FCancelMatchmakingTicketResult()
{

}

void PlayFab::MultiplayerModels::FCancelMatchmakingTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelMatchmakingTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelServerBackfillTicketRequest::~FCancelServerBackfillTicketRequest()
{

}

void PlayFab::MultiplayerModels::FCancelServerBackfillTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CancelServerBackfillTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CancelServerBackfillTicketRequest::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelServerBackfillTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCancelServerBackfillTicketResult::~FCancelServerBackfillTicketResult()
{

}

void PlayFab::MultiplayerModels::FCancelServerBackfillTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCancelServerBackfillTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCertificate::~FCertificate()
{

}

void PlayFab::MultiplayerModels::FCertificate::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!Base64EncodedValue.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: Certificate::Base64EncodedValue, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Base64EncodedValue"));
        writer->WriteValue(Base64EncodedValue);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: Certificate::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (Password.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Password"));
        writer->WriteValue(Password);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCertificate::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> Base64EncodedValueValue = obj->TryGetField(TEXT("Base64EncodedValue"));
    if (Base64EncodedValueValue.IsValid() && !Base64EncodedValueValue->IsNull())
    {
        FString TmpValue;
        if (Base64EncodedValueValue->TryGetString(TmpValue)) { Base64EncodedValue = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCertificateSummary::~FCertificateSummary()
{

}

void PlayFab::MultiplayerModels::FCertificateSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Name.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    if (Thumbprint.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Thumbprint"));
        writer->WriteValue(Thumbprint);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCertificateSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ThumbprintValue = obj->TryGetField(TEXT("Thumbprint"));
    if (ThumbprintValue.IsValid() && !ThumbprintValue->IsNull())
    {
        FString TmpValue;
        if (ThumbprintValue->TryGetString(TmpValue)) { Thumbprint = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FConnectedPlayer::~FConnectedPlayer()
{

}

void PlayFab::MultiplayerModels::FConnectedPlayer::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (PlayerId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("PlayerId"));
        writer->WriteValue(PlayerId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FConnectedPlayer::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PlayerIdValue = obj->TryGetField(TEXT("PlayerId"));
    if (PlayerIdValue.IsValid() && !PlayerIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayerIdValue->TryGetString(TmpValue)) { PlayerId = TmpValue; }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeContainerFlavorEnumJSON(ContainerFlavor enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ContainerFlavorManagedWindowsServerCore: writer->WriteValue(TEXT("ManagedWindowsServerCore")); break;
    case ContainerFlavorCustomLinux: writer->WriteValue(TEXT("CustomLinux")); break;
    case ContainerFlavorManagedWindowsServerCorePreview: writer->WriteValue(TEXT("ManagedWindowsServerCorePreview")); break;
    case ContainerFlavorInvalid: writer->WriteValue(TEXT("Invalid")); break;
    }
}

MultiplayerModels::ContainerFlavor PlayFab::MultiplayerModels::readContainerFlavorFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readContainerFlavorFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::ContainerFlavor PlayFab::MultiplayerModels::readContainerFlavorFromValue(const FString& value)
{
    static TMap<FString, ContainerFlavor> _ContainerFlavorMap;
    if (_ContainerFlavorMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ContainerFlavorMap.Add(TEXT("ManagedWindowsServerCore"), ContainerFlavorManagedWindowsServerCore);
        _ContainerFlavorMap.Add(TEXT("CustomLinux"), ContainerFlavorCustomLinux);
        _ContainerFlavorMap.Add(TEXT("ManagedWindowsServerCorePreview"), ContainerFlavorManagedWindowsServerCorePreview);
        _ContainerFlavorMap.Add(TEXT("Invalid"), ContainerFlavorInvalid);

    }

    if (!value.IsEmpty())
    {
        auto output = _ContainerFlavorMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ContainerFlavorManagedWindowsServerCore; // Basically critical fail
}

PlayFab::MultiplayerModels::FContainerImageReference::~FContainerImageReference()
{

}

void PlayFab::MultiplayerModels::FContainerImageReference::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!ImageName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ContainerImageReference::ImageName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("ImageName"));
        writer->WriteValue(ImageName);
    }

    if (Tag.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Tag"));
        writer->WriteValue(Tag);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FContainerImageReference::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ImageNameValue = obj->TryGetField(TEXT("ImageName"));
    if (ImageNameValue.IsValid() && !ImageNameValue->IsNull())
    {
        FString TmpValue;
        if (ImageNameValue->TryGetString(TmpValue)) { ImageName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TagValue = obj->TryGetField(TEXT("Tag"));
    if (TagValue.IsValid() && !TagValue->IsNull())
    {
        FString TmpValue;
        if (TagValue->TryGetString(TmpValue)) { Tag = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCoreCapacity::~FCoreCapacity()
{

}

void PlayFab::MultiplayerModels::FCoreCapacity::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Available"));
    writer->WriteValue(Available);

    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    writer->WriteIdentifierPrefix(TEXT("Total"));
    writer->WriteValue(Total);

    if (VmFamily.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmFamily"));
        writeAzureVmFamilyEnumJSON(VmFamily, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCoreCapacity::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AvailableValue = obj->TryGetField(TEXT("Available"));
    if (AvailableValue.IsValid() && !AvailableValue->IsNull())
    {
        int32 TmpValue;
        if (AvailableValue->TryGetNumber(TmpValue)) { Available = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TotalValue = obj->TryGetField(TEXT("Total"));
    if (TotalValue.IsValid() && !TotalValue->IsNull())
    {
        int32 TmpValue;
        if (TotalValue->TryGetNumber(TmpValue)) { Total = TmpValue; }
    }

    VmFamily = readAzureVmFamilyFromValue(obj->TryGetField(TEXT("VmFamily")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCoreCapacityChange::~FCoreCapacityChange()
{

}

void PlayFab::MultiplayerModels::FCoreCapacityChange::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("NewCoreLimit"));
    writer->WriteValue(NewCoreLimit);

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CoreCapacityChange::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    writer->WriteIdentifierPrefix(TEXT("VmFamily"));
    writeAzureVmFamilyEnumJSON(VmFamily, writer);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCoreCapacityChange::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NewCoreLimitValue = obj->TryGetField(TEXT("NewCoreLimit"));
    if (NewCoreLimitValue.IsValid() && !NewCoreLimitValue->IsNull())
    {
        int32 TmpValue;
        if (NewCoreLimitValue->TryGetNumber(TmpValue)) { NewCoreLimit = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    VmFamily = readAzureVmFamilyFromValue(obj->TryGetField(TEXT("VmFamily")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildAliasRequest::~FCreateBuildAliasRequest()
{

}

void PlayFab::MultiplayerModels::FCreateBuildAliasRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!AliasName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateBuildAliasRequest::AliasName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("AliasName"));
        writer->WriteValue(AliasName);
    }

    if (BuildSelectionCriteria.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BuildSelectionCriteria"));
        for (const FBuildSelectionCriterion& item : BuildSelectionCriteria)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildAliasRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AliasNameValue = obj->TryGetField(TEXT("AliasName"));
    if (AliasNameValue.IsValid() && !AliasNameValue->IsNull())
    {
        FString TmpValue;
        if (AliasNameValue->TryGetString(TmpValue)) { AliasName = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&BuildSelectionCriteriaArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildSelectionCriteria"));
    for (int32 Idx = 0; Idx < BuildSelectionCriteriaArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildSelectionCriteriaArray[Idx];
        BuildSelectionCriteria.Add(FBuildSelectionCriterion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGameCertificateReferenceParams::~FGameCertificateReferenceParams()
{

}

void PlayFab::MultiplayerModels::FGameCertificateReferenceParams::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!GsdkAlias.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GameCertificateReferenceParams::GsdkAlias, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("GsdkAlias"));
        writer->WriteValue(GsdkAlias);
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GameCertificateReferenceParams::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGameCertificateReferenceParams::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> GsdkAliasValue = obj->TryGetField(TEXT("GsdkAlias"));
    if (GsdkAliasValue.IsValid() && !GsdkAliasValue->IsNull())
    {
        FString TmpValue;
        if (GsdkAliasValue->TryGetString(TmpValue)) { GsdkAlias = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FLinuxInstrumentationConfiguration::~FLinuxInstrumentationConfiguration()
{

}

void PlayFab::MultiplayerModels::FLinuxInstrumentationConfiguration::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("IsEnabled"));
    writer->WriteValue(IsEnabled);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FLinuxInstrumentationConfiguration::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IsEnabledValue = obj->TryGetField(TEXT("IsEnabled"));
    if (IsEnabledValue.IsValid() && !IsEnabledValue->IsNull())
    {
        bool TmpValue;
        if (IsEnabledValue->TryGetBool(TmpValue)) { IsEnabled = TmpValue; }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeProtocolTypeEnumJSON(ProtocolType enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ProtocolTypeTCP: writer->WriteValue(TEXT("TCP")); break;
    case ProtocolTypeUDP: writer->WriteValue(TEXT("UDP")); break;
    }
}

MultiplayerModels::ProtocolType PlayFab::MultiplayerModels::readProtocolTypeFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readProtocolTypeFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::ProtocolType PlayFab::MultiplayerModels::readProtocolTypeFromValue(const FString& value)
{
    static TMap<FString, ProtocolType> _ProtocolTypeMap;
    if (_ProtocolTypeMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ProtocolTypeMap.Add(TEXT("TCP"), ProtocolTypeTCP);
        _ProtocolTypeMap.Add(TEXT("UDP"), ProtocolTypeUDP);

    }

    if (!value.IsEmpty())
    {
        auto output = _ProtocolTypeMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ProtocolTypeTCP; // Basically critical fail
}

PlayFab::MultiplayerModels::FPort::~FPort()
{

}

void PlayFab::MultiplayerModels::FPort::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: Port::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteIdentifierPrefix(TEXT("Num"));
    writer->WriteValue(Num);

    writer->WriteIdentifierPrefix(TEXT("Protocol"));
    writeProtocolTypeEnumJSON(Protocol, writer);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FPort::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NumValue = obj->TryGetField(TEXT("Num"));
    if (NumValue.IsValid() && !NumValue->IsNull())
    {
        int32 TmpValue;
        if (NumValue->TryGetNumber(TmpValue)) { Num = TmpValue; }
    }

    Protocol = readProtocolTypeFromValue(obj->TryGetField(TEXT("Protocol")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerRequest::~FCreateBuildWithCustomContainerRequest()
{
    //if (ContainerImageReference != nullptr) delete ContainerImageReference;
    //if (LinuxInstrumentationConfiguration != nullptr) delete LinuxInstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (!BuildName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateBuildWithCustomContainerRequest::BuildName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (pfContainerFlavor.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerFlavor"));
        writeContainerFlavorEnumJSON(pfContainerFlavor, writer);
    }

    if (pfContainerImageReference.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerImageReference"));
        pfContainerImageReference->writeJSON(writer);
    }

    if (ContainerRunCommand.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerRunCommand"));
        writer->WriteValue(ContainerRunCommand);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReferenceParams& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReferenceParams& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (pfLinuxInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("LinuxInstrumentationConfiguration"));
        pfLinuxInstrumentationConfiguration->writeJSON(writer);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    writer->WriteArrayStart(TEXT("Ports"));
    for (const FPort& item : Ports)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteArrayStart(TEXT("RegionConfigurations"));
    for (const FBuildRegionParams& item : RegionConfigurations)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> ContainerImageReferenceValue = obj->TryGetField(TEXT("ContainerImageReference"));
    if (ContainerImageReferenceValue.IsValid() && !ContainerImageReferenceValue->IsNull())
    {
        pfContainerImageReference = MakeShareable(new FContainerImageReference(ContainerImageReferenceValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> ContainerRunCommandValue = obj->TryGetField(TEXT("ContainerRunCommand"));
    if (ContainerRunCommandValue.IsValid() && !ContainerRunCommandValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRunCommandValue->TryGetString(TmpValue)) { ContainerRunCommand = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReferenceParams(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReferenceParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> LinuxInstrumentationConfigurationValue = obj->TryGetField(TEXT("LinuxInstrumentationConfiguration"));
    if (LinuxInstrumentationConfigurationValue.IsValid() && !LinuxInstrumentationConfigurationValue->IsNull())
    {
        pfLinuxInstrumentationConfiguration = MakeShareable(new FLinuxInstrumentationConfiguration(LinuxInstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGameCertificateReference::~FGameCertificateReference()
{

}

void PlayFab::MultiplayerModels::FGameCertificateReference::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (GsdkAlias.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("GsdkAlias"));
        writer->WriteValue(GsdkAlias);
    }

    if (Name.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGameCertificateReference::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> GsdkAliasValue = obj->TryGetField(TEXT("GsdkAlias"));
    if (GsdkAliasValue.IsValid() && !GsdkAliasValue->IsNull())
    {
        FString TmpValue;
        if (GsdkAliasValue->TryGetString(TmpValue)) { GsdkAlias = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerResponse::~FCreateBuildWithCustomContainerResponse()
{
    //if (CustomGameContainerImage != nullptr) delete CustomGameContainerImage;
    //if (LinuxInstrumentationConfiguration != nullptr) delete LinuxInstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (BuildName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (pfContainerFlavor.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerFlavor"));
        writeContainerFlavorEnumJSON(pfContainerFlavor, writer);
    }

    if (ContainerRunCommand.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerRunCommand"));
        writer->WriteValue(ContainerRunCommand);
    }

    if (CreationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("CreationTime"));
        writeDatetime(CreationTime, writer);
    }

    if (CustomGameContainerImage.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("CustomGameContainerImage"));
        CustomGameContainerImage->writeJSON(writer);
    }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (pfLinuxInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("LinuxInstrumentationConfiguration"));
        pfLinuxInstrumentationConfiguration->writeJSON(writer);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    if (OsPlatform.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("OsPlatform"));
        writer->WriteValue(OsPlatform);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (ServerType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerType"));
        writer->WriteValue(ServerType);
    }

    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithCustomContainerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> ContainerRunCommandValue = obj->TryGetField(TEXT("ContainerRunCommand"));
    if (ContainerRunCommandValue.IsValid() && !ContainerRunCommandValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRunCommandValue->TryGetString(TmpValue)) { ContainerRunCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TSharedPtr<FJsonValue> CustomGameContainerImageValue = obj->TryGetField(TEXT("CustomGameContainerImage"));
    if (CustomGameContainerImageValue.IsValid() && !CustomGameContainerImageValue->IsNull())
    {
        CustomGameContainerImage = MakeShareable(new FContainerImageReference(CustomGameContainerImageValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> LinuxInstrumentationConfigurationValue = obj->TryGetField(TEXT("LinuxInstrumentationConfiguration"));
    if (LinuxInstrumentationConfigurationValue.IsValid() && !LinuxInstrumentationConfigurationValue->IsNull())
    {
        pfLinuxInstrumentationConfiguration = MakeShareable(new FLinuxInstrumentationConfiguration(LinuxInstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TSharedPtr<FJsonValue> OsPlatformValue = obj->TryGetField(TEXT("OsPlatform"));
    if (OsPlatformValue.IsValid() && !OsPlatformValue->IsNull())
    {
        FString TmpValue;
        if (OsPlatformValue->TryGetString(TmpValue)) { OsPlatform = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> ServerTypeValue = obj->TryGetField(TEXT("ServerType"));
    if (ServerTypeValue.IsValid() && !ServerTypeValue->IsNull())
    {
        FString TmpValue;
        if (ServerTypeValue->TryGetString(TmpValue)) { ServerType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FInstrumentationConfiguration::~FInstrumentationConfiguration()
{

}

void PlayFab::MultiplayerModels::FInstrumentationConfiguration::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (IsEnabled.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("IsEnabled"));
        writer->WriteValue(IsEnabled);
    }

    if (ProcessesToMonitor.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ProcessesToMonitor"));
        for (const FString& item : ProcessesToMonitor)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FInstrumentationConfiguration::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IsEnabledValue = obj->TryGetField(TEXT("IsEnabled"));
    if (IsEnabledValue.IsValid() && !IsEnabledValue->IsNull())
    {
        bool TmpValue;
        if (IsEnabledValue->TryGetBool(TmpValue)) { IsEnabled = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("ProcessesToMonitor"), ProcessesToMonitor);

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerRequest::~FCreateBuildWithManagedContainerRequest()
{
    //if (InstrumentationConfiguration != nullptr) delete InstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (!BuildName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateBuildWithManagedContainerRequest::BuildName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (pfContainerFlavor.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerFlavor"));
        writeContainerFlavorEnumJSON(pfContainerFlavor, writer);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteArrayStart(TEXT("GameAssetReferences"));
    for (const FAssetReferenceParams& item : GameAssetReferences)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReferenceParams& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameWorkingDirectory.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("GameWorkingDirectory"));
        writer->WriteValue(GameWorkingDirectory);
    }

    if (pfInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("InstrumentationConfiguration"));
        pfInstrumentationConfiguration->writeJSON(writer);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    writer->WriteArrayStart(TEXT("Ports"));
    for (const FPort& item : Ports)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteArrayStart(TEXT("RegionConfigurations"));
    for (const FBuildRegionParams& item : RegionConfigurations)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (!StartMultiplayerServerCommand.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateBuildWithManagedContainerRequest::StartMultiplayerServerCommand, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand"));
        writer->WriteValue(StartMultiplayerServerCommand);
    }

    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReferenceParams(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReferenceParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> GameWorkingDirectoryValue = obj->TryGetField(TEXT("GameWorkingDirectory"));
    if (GameWorkingDirectoryValue.IsValid() && !GameWorkingDirectoryValue->IsNull())
    {
        FString TmpValue;
        if (GameWorkingDirectoryValue->TryGetString(TmpValue)) { GameWorkingDirectory = TmpValue; }
    }

    const TSharedPtr<FJsonValue> InstrumentationConfigurationValue = obj->TryGetField(TEXT("InstrumentationConfiguration"));
    if (InstrumentationConfigurationValue.IsValid() && !InstrumentationConfigurationValue->IsNull())
    {
        pfInstrumentationConfiguration = MakeShareable(new FInstrumentationConfiguration(InstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerResponse::~FCreateBuildWithManagedContainerResponse()
{
    //if (InstrumentationConfiguration != nullptr) delete InstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (BuildName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (pfContainerFlavor.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerFlavor"));
        writeContainerFlavorEnumJSON(pfContainerFlavor, writer);
    }

    if (CreationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("CreationTime"));
        writeDatetime(CreationTime, writer);
    }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameWorkingDirectory.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("GameWorkingDirectory"));
        writer->WriteValue(GameWorkingDirectory);
    }

    if (pfInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("InstrumentationConfiguration"));
        pfInstrumentationConfiguration->writeJSON(writer);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    if (OsPlatform.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("OsPlatform"));
        writer->WriteValue(OsPlatform);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (ServerType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerType"));
        writer->WriteValue(ServerType);
    }

    if (StartMultiplayerServerCommand.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand"));
        writer->WriteValue(StartMultiplayerServerCommand);
    }

    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithManagedContainerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> GameWorkingDirectoryValue = obj->TryGetField(TEXT("GameWorkingDirectory"));
    if (GameWorkingDirectoryValue.IsValid() && !GameWorkingDirectoryValue->IsNull())
    {
        FString TmpValue;
        if (GameWorkingDirectoryValue->TryGetString(TmpValue)) { GameWorkingDirectory = TmpValue; }
    }

    const TSharedPtr<FJsonValue> InstrumentationConfigurationValue = obj->TryGetField(TEXT("InstrumentationConfiguration"));
    if (InstrumentationConfigurationValue.IsValid() && !InstrumentationConfigurationValue->IsNull())
    {
        pfInstrumentationConfiguration = MakeShareable(new FInstrumentationConfiguration(InstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TSharedPtr<FJsonValue> OsPlatformValue = obj->TryGetField(TEXT("OsPlatform"));
    if (OsPlatformValue.IsValid() && !OsPlatformValue->IsNull())
    {
        FString TmpValue;
        if (OsPlatformValue->TryGetString(TmpValue)) { OsPlatform = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> ServerTypeValue = obj->TryGetField(TEXT("ServerType"));
    if (ServerTypeValue.IsValid() && !ServerTypeValue->IsNull())
    {
        FString TmpValue;
        if (ServerTypeValue->TryGetString(TmpValue)) { ServerType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithProcessBasedServerRequest::~FCreateBuildWithProcessBasedServerRequest()
{
    //if (InstrumentationConfiguration != nullptr) delete InstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FCreateBuildWithProcessBasedServerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (!BuildName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateBuildWithProcessBasedServerRequest::BuildName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteArrayStart(TEXT("GameAssetReferences"));
    for (const FAssetReferenceParams& item : GameAssetReferences)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReferenceParams& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameWorkingDirectory.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("GameWorkingDirectory"));
        writer->WriteValue(GameWorkingDirectory);
    }

    if (pfInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("InstrumentationConfiguration"));
        pfInstrumentationConfiguration->writeJSON(writer);
    }

    if (IsOSPreview.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("IsOSPreview"));
        writer->WriteValue(IsOSPreview);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    if (OsPlatform.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("OsPlatform"));
        writer->WriteValue(OsPlatform);
    }

    writer->WriteArrayStart(TEXT("Ports"));
    for (const FPort& item : Ports)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    writer->WriteArrayStart(TEXT("RegionConfigurations"));
    for (const FBuildRegionParams& item : RegionConfigurations)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (!StartMultiplayerServerCommand.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateBuildWithProcessBasedServerRequest::StartMultiplayerServerCommand, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand"));
        writer->WriteValue(StartMultiplayerServerCommand);
    }

    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithProcessBasedServerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReferenceParams(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReferenceParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> GameWorkingDirectoryValue = obj->TryGetField(TEXT("GameWorkingDirectory"));
    if (GameWorkingDirectoryValue.IsValid() && !GameWorkingDirectoryValue->IsNull())
    {
        FString TmpValue;
        if (GameWorkingDirectoryValue->TryGetString(TmpValue)) { GameWorkingDirectory = TmpValue; }
    }

    const TSharedPtr<FJsonValue> InstrumentationConfigurationValue = obj->TryGetField(TEXT("InstrumentationConfiguration"));
    if (InstrumentationConfigurationValue.IsValid() && !InstrumentationConfigurationValue->IsNull())
    {
        pfInstrumentationConfiguration = MakeShareable(new FInstrumentationConfiguration(InstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> IsOSPreviewValue = obj->TryGetField(TEXT("IsOSPreview"));
    if (IsOSPreviewValue.IsValid() && !IsOSPreviewValue->IsNull())
    {
        bool TmpValue;
        if (IsOSPreviewValue->TryGetBool(TmpValue)) { IsOSPreview = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TSharedPtr<FJsonValue> OsPlatformValue = obj->TryGetField(TEXT("OsPlatform"));
    if (OsPlatformValue.IsValid() && !OsPlatformValue->IsNull())
    {
        FString TmpValue;
        if (OsPlatformValue->TryGetString(TmpValue)) { OsPlatform = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateBuildWithProcessBasedServerResponse::~FCreateBuildWithProcessBasedServerResponse()
{
    //if (InstrumentationConfiguration != nullptr) delete InstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FCreateBuildWithProcessBasedServerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (BuildName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (pfContainerFlavor.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerFlavor"));
        writeContainerFlavorEnumJSON(pfContainerFlavor, writer);
    }

    if (CreationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("CreationTime"));
        writeDatetime(CreationTime, writer);
    }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameWorkingDirectory.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("GameWorkingDirectory"));
        writer->WriteValue(GameWorkingDirectory);
    }

    if (pfInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("InstrumentationConfiguration"));
        pfInstrumentationConfiguration->writeJSON(writer);
    }

    if (IsOSPreview.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("IsOSPreview"));
        writer->WriteValue(IsOSPreview);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    if (OsPlatform.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("OsPlatform"));
        writer->WriteValue(OsPlatform);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (ServerType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerType"));
        writer->WriteValue(ServerType);
    }

    if (StartMultiplayerServerCommand.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand"));
        writer->WriteValue(StartMultiplayerServerCommand);
    }

    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateBuildWithProcessBasedServerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> GameWorkingDirectoryValue = obj->TryGetField(TEXT("GameWorkingDirectory"));
    if (GameWorkingDirectoryValue.IsValid() && !GameWorkingDirectoryValue->IsNull())
    {
        FString TmpValue;
        if (GameWorkingDirectoryValue->TryGetString(TmpValue)) { GameWorkingDirectory = TmpValue; }
    }

    const TSharedPtr<FJsonValue> InstrumentationConfigurationValue = obj->TryGetField(TEXT("InstrumentationConfiguration"));
    if (InstrumentationConfigurationValue.IsValid() && !InstrumentationConfigurationValue->IsNull())
    {
        pfInstrumentationConfiguration = MakeShareable(new FInstrumentationConfiguration(InstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> IsOSPreviewValue = obj->TryGetField(TEXT("IsOSPreview"));
    if (IsOSPreviewValue.IsValid() && !IsOSPreviewValue->IsNull())
    {
        bool TmpValue;
        if (IsOSPreviewValue->TryGetBool(TmpValue)) { IsOSPreview = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TSharedPtr<FJsonValue> OsPlatformValue = obj->TryGetField(TEXT("OsPlatform"));
    if (OsPlatformValue.IsValid() && !OsPlatformValue->IsNull())
    {
        FString TmpValue;
        if (OsPlatformValue->TryGetString(TmpValue)) { OsPlatform = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> ServerTypeValue = obj->TryGetField(TEXT("ServerType"));
    if (ServerTypeValue.IsValid() && !ServerTypeValue->IsNull())
    {
        FString TmpValue;
        if (ServerTypeValue->TryGetString(TmpValue)) { ServerType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FMatchmakingPlayerAttributes::~FMatchmakingPlayerAttributes()
{

}

void PlayFab::MultiplayerModels::FMatchmakingPlayerAttributes::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DataObject.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("DataObject"));
        DataObject.writeJSON(writer);
    }

    if (EscapedDataObject.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("EscapedDataObject"));
        writer->WriteValue(EscapedDataObject);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FMatchmakingPlayerAttributes::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DataObjectValue = obj->TryGetField(TEXT("DataObject"));
    if (DataObjectValue.IsValid() && !DataObjectValue->IsNull())
    {
        DataObject = FJsonKeeper(DataObjectValue);
    }

    const TSharedPtr<FJsonValue> EscapedDataObjectValue = obj->TryGetField(TEXT("EscapedDataObject"));
    if (EscapedDataObjectValue.IsValid() && !EscapedDataObjectValue->IsNull())
    {
        FString TmpValue;
        if (EscapedDataObjectValue->TryGetString(TmpValue)) { EscapedDataObject = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FMatchmakingPlayer::~FMatchmakingPlayer()
{
    //if (Attributes != nullptr) delete Attributes;

}

void PlayFab::MultiplayerModels::FMatchmakingPlayer::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Attributes.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Attributes"));
        Attributes->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("Entity"));
    Entity.writeJSON(writer);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FMatchmakingPlayer::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AttributesValue = obj->TryGetField(TEXT("Attributes"));
    if (AttributesValue.IsValid() && !AttributesValue->IsNull())
    {
        Attributes = MakeShareable(new FMatchmakingPlayerAttributes(AttributesValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = FEntityKey(EntityValue->AsObject());
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateMatchmakingTicketRequest::~FCreateMatchmakingTicketRequest()
{

}

void PlayFab::MultiplayerModels::FCreateMatchmakingTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Creator"));
    Creator.writeJSON(writer);

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("GiveUpAfterSeconds"));
    writer->WriteValue(GiveUpAfterSeconds);

    if (MembersToMatchWith.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("MembersToMatchWith"));
        for (const FEntityKey& item : MembersToMatchWith)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateMatchmakingTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateMatchmakingTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> CreatorValue = obj->TryGetField(TEXT("Creator"));
    if (CreatorValue.IsValid() && !CreatorValue->IsNull())
    {
        Creator = FMatchmakingPlayer(CreatorValue->AsObject());
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> GiveUpAfterSecondsValue = obj->TryGetField(TEXT("GiveUpAfterSeconds"));
    if (GiveUpAfterSecondsValue.IsValid() && !GiveUpAfterSecondsValue->IsNull())
    {
        int32 TmpValue;
        if (GiveUpAfterSecondsValue->TryGetNumber(TmpValue)) { GiveUpAfterSeconds = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&MembersToMatchWithArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("MembersToMatchWith"));
    for (int32 Idx = 0; Idx < MembersToMatchWithArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersToMatchWithArray[Idx];
        MembersToMatchWith.Add(FEntityKey(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateMatchmakingTicketResult::~FCreateMatchmakingTicketResult()
{

}

void PlayFab::MultiplayerModels::FCreateMatchmakingTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateMatchmakingTicketResult::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateMatchmakingTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateRemoteUserRequest::~FCreateRemoteUserRequest()
{

}

void PlayFab::MultiplayerModels::FCreateRemoteUserRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateRemoteUserRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (ExpirationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ExpirationTime"));
        writeDatetime(ExpirationTime, writer);
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateRemoteUserRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (!Username.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateRemoteUserRequest::Username, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Username"));
        writer->WriteValue(Username);
    }

    if (!VmId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateRemoteUserRequest::VmId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateRemoteUserRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> ExpirationTimeValue = obj->TryGetField(TEXT("ExpirationTime"));
    if (ExpirationTimeValue.IsValid())
        ExpirationTime = readDatetime(ExpirationTimeValue);


    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateRemoteUserResponse::~FCreateRemoteUserResponse()
{

}

void PlayFab::MultiplayerModels::FCreateRemoteUserResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ExpirationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ExpirationTime"));
        writeDatetime(ExpirationTime, writer);
    }

    if (Password.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Password"));
        writer->WriteValue(Password);
    }

    if (Username.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Username"));
        writer->WriteValue(Username);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateRemoteUserResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ExpirationTimeValue = obj->TryGetField(TEXT("ExpirationTime"));
    if (ExpirationTimeValue.IsValid())
        ExpirationTime = readDatetime(ExpirationTimeValue);


    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FMatchmakingPlayerWithTeamAssignment::~FMatchmakingPlayerWithTeamAssignment()
{
    //if (Attributes != nullptr) delete Attributes;

}

void PlayFab::MultiplayerModels::FMatchmakingPlayerWithTeamAssignment::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Attributes.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Attributes"));
        Attributes->writeJSON(writer);
    }

    writer->WriteIdentifierPrefix(TEXT("Entity"));
    Entity.writeJSON(writer);

    if (TeamId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("TeamId"));
        writer->WriteValue(TeamId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FMatchmakingPlayerWithTeamAssignment::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AttributesValue = obj->TryGetField(TEXT("Attributes"));
    if (AttributesValue.IsValid() && !AttributesValue->IsNull())
    {
        Attributes = MakeShareable(new FMatchmakingPlayerAttributes(AttributesValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = FEntityKey(EntityValue->AsObject());
    }

    const TSharedPtr<FJsonValue> TeamIdValue = obj->TryGetField(TEXT("TeamId"));
    if (TeamIdValue.IsValid() && !TeamIdValue->IsNull())
    {
        FString TmpValue;
        if (TeamIdValue->TryGetString(TmpValue)) { TeamId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FServerDetails::~FServerDetails()
{

}

void PlayFab::MultiplayerModels::FServerDetails::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Fqdn.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Fqdn"));
        writer->WriteValue(Fqdn);
    }

    if (IPV4Address.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("IPV4Address"));
        writer->WriteValue(IPV4Address);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FServerDetails::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> FqdnValue = obj->TryGetField(TEXT("Fqdn"));
    if (FqdnValue.IsValid() && !FqdnValue->IsNull())
    {
        FString TmpValue;
        if (FqdnValue->TryGetString(TmpValue)) { Fqdn = TmpValue; }
    }

    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateServerBackfillTicketRequest::~FCreateServerBackfillTicketRequest()
{
    //if (ServerDetails != nullptr) delete ServerDetails;

}

void PlayFab::MultiplayerModels::FCreateServerBackfillTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("GiveUpAfterSeconds"));
    writer->WriteValue(GiveUpAfterSeconds);

    writer->WriteArrayStart(TEXT("Members"));
    for (const FMatchmakingPlayerWithTeamAssignment& item : Members)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateServerBackfillTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (pfServerDetails.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("ServerDetails"));
        pfServerDetails->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateServerBackfillTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> GiveUpAfterSecondsValue = obj->TryGetField(TEXT("GiveUpAfterSeconds"));
    if (GiveUpAfterSecondsValue.IsValid() && !GiveUpAfterSecondsValue->IsNull())
    {
        int32 TmpValue;
        if (GiveUpAfterSecondsValue->TryGetNumber(TmpValue)) { GiveUpAfterSeconds = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&MembersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Members"));
    for (int32 Idx = 0; Idx < MembersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersArray[Idx];
        Members.Add(FMatchmakingPlayerWithTeamAssignment(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ServerDetailsValue = obj->TryGetField(TEXT("ServerDetails"));
    if (ServerDetailsValue.IsValid() && !ServerDetailsValue->IsNull())
    {
        pfServerDetails = MakeShareable(new FServerDetails(ServerDetailsValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateServerBackfillTicketResult::~FCreateServerBackfillTicketResult()
{

}

void PlayFab::MultiplayerModels::FCreateServerBackfillTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateServerBackfillTicketResult::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateServerBackfillTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateServerMatchmakingTicketRequest::~FCreateServerMatchmakingTicketRequest()
{

}

void PlayFab::MultiplayerModels::FCreateServerMatchmakingTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("GiveUpAfterSeconds"));
    writer->WriteValue(GiveUpAfterSeconds);

    writer->WriteArrayStart(TEXT("Members"));
    for (const FMatchmakingPlayer& item : Members)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: CreateServerMatchmakingTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateServerMatchmakingTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> GiveUpAfterSecondsValue = obj->TryGetField(TEXT("GiveUpAfterSeconds"));
    if (GiveUpAfterSecondsValue.IsValid() && !GiveUpAfterSecondsValue->IsNull())
    {
        int32 TmpValue;
        if (GiveUpAfterSecondsValue->TryGetNumber(TmpValue)) { GiveUpAfterSeconds = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&MembersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Members"));
    for (int32 Idx = 0; Idx < MembersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersArray[Idx];
        Members.Add(FMatchmakingPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateTitleMultiplayerServersQuotaChangeRequest::~FCreateTitleMultiplayerServersQuotaChangeRequest()
{

}

void PlayFab::MultiplayerModels::FCreateTitleMultiplayerServersQuotaChangeRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ChangeDescription.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ChangeDescription"));
        writer->WriteValue(ChangeDescription);
    }

    writer->WriteArrayStart(TEXT("Changes"));
    for (const FCoreCapacityChange& item : Changes)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (ContactEmail.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ContactEmail"));
        writer->WriteValue(ContactEmail);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Notes.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Notes"));
        writer->WriteValue(Notes);
    }

    if (StartDate.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("StartDate"));
        writeDatetime(StartDate, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateTitleMultiplayerServersQuotaChangeRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ChangeDescriptionValue = obj->TryGetField(TEXT("ChangeDescription"));
    if (ChangeDescriptionValue.IsValid() && !ChangeDescriptionValue->IsNull())
    {
        FString TmpValue;
        if (ChangeDescriptionValue->TryGetString(TmpValue)) { ChangeDescription = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&ChangesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Changes"));
    for (int32 Idx = 0; Idx < ChangesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ChangesArray[Idx];
        Changes.Add(FCoreCapacityChange(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> ContactEmailValue = obj->TryGetField(TEXT("ContactEmail"));
    if (ContactEmailValue.IsValid() && !ContactEmailValue->IsNull())
    {
        FString TmpValue;
        if (ContactEmailValue->TryGetString(TmpValue)) { ContactEmail = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NotesValue = obj->TryGetField(TEXT("Notes"));
    if (NotesValue.IsValid() && !NotesValue->IsNull())
    {
        FString TmpValue;
        if (NotesValue->TryGetString(TmpValue)) { Notes = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StartDateValue = obj->TryGetField(TEXT("StartDate"));
    if (StartDateValue.IsValid())
        StartDate = readDatetime(StartDateValue);


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FCreateTitleMultiplayerServersQuotaChangeResponse::~FCreateTitleMultiplayerServersQuotaChangeResponse()
{

}

void PlayFab::MultiplayerModels::FCreateTitleMultiplayerServersQuotaChangeResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (RequestId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("RequestId"));
        writer->WriteValue(RequestId);
    }

    writer->WriteIdentifierPrefix(TEXT("WasApproved"));
    writer->WriteValue(WasApproved);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FCreateTitleMultiplayerServersQuotaChangeResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> RequestIdValue = obj->TryGetField(TEXT("RequestId"));
    if (RequestIdValue.IsValid() && !RequestIdValue->IsNull())
    {
        FString TmpValue;
        if (RequestIdValue->TryGetString(TmpValue)) { RequestId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> WasApprovedValue = obj->TryGetField(TEXT("WasApproved"));
    if (WasApprovedValue.IsValid() && !WasApprovedValue->IsNull())
    {
        bool TmpValue;
        if (WasApprovedValue->TryGetBool(TmpValue)) { WasApproved = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteAssetRequest::~FDeleteAssetRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteAssetRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!FileName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteAssetRequest::FileName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteAssetRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteBuildAliasRequest::~FDeleteBuildAliasRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteBuildAliasRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!AliasId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteBuildAliasRequest::AliasId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("AliasId"));
        writer->WriteValue(AliasId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteBuildAliasRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AliasIdValue = obj->TryGetField(TEXT("AliasId"));
    if (AliasIdValue.IsValid() && !AliasIdValue->IsNull())
    {
        FString TmpValue;
        if (AliasIdValue->TryGetString(TmpValue)) { AliasId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteBuildRegionRequest::~FDeleteBuildRegionRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteBuildRegionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteBuildRegionRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteBuildRegionRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteBuildRegionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteBuildRequest::~FDeleteBuildRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteBuildRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteBuildRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteBuildRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteCertificateRequest::~FDeleteCertificateRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteCertificateRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Name.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteCertificateRequest::Name, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Name"));
        writer->WriteValue(Name);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteCertificateRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> NameValue = obj->TryGetField(TEXT("Name"));
    if (NameValue.IsValid() && !NameValue->IsNull())
    {
        FString TmpValue;
        if (NameValue->TryGetString(TmpValue)) { Name = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteContainerImageRequest::~FDeleteContainerImageRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteContainerImageRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (ImageName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ImageName"));
        writer->WriteValue(ImageName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteContainerImageRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> ImageNameValue = obj->TryGetField(TEXT("ImageName"));
    if (ImageNameValue.IsValid() && !ImageNameValue->IsNull())
    {
        FString TmpValue;
        if (ImageNameValue->TryGetString(TmpValue)) { ImageName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FDeleteRemoteUserRequest::~FDeleteRemoteUserRequest()
{

}

void PlayFab::MultiplayerModels::FDeleteRemoteUserRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteRemoteUserRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteRemoteUserRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (!Username.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteRemoteUserRequest::Username, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Username"));
        writer->WriteValue(Username);
    }

    if (!VmId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: DeleteRemoteUserRequest::VmId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FDeleteRemoteUserRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FEmptyResponse::~FEmptyResponse()
{

}

void PlayFab::MultiplayerModels::FEmptyResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEmptyResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleRequest::~FEnableMultiplayerServersForTitleRequest()
{

}

void PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeTitleMultiplayerServerEnabledStatusEnumJSON(TitleMultiplayerServerEnabledStatus enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case TitleMultiplayerServerEnabledStatusInitializing: writer->WriteValue(TEXT("Initializing")); break;
    case TitleMultiplayerServerEnabledStatusEnabled: writer->WriteValue(TEXT("Enabled")); break;
    case TitleMultiplayerServerEnabledStatusDisabled: writer->WriteValue(TEXT("Disabled")); break;
    }
}

MultiplayerModels::TitleMultiplayerServerEnabledStatus PlayFab::MultiplayerModels::readTitleMultiplayerServerEnabledStatusFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readTitleMultiplayerServerEnabledStatusFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::TitleMultiplayerServerEnabledStatus PlayFab::MultiplayerModels::readTitleMultiplayerServerEnabledStatusFromValue(const FString& value)
{
    static TMap<FString, TitleMultiplayerServerEnabledStatus> _TitleMultiplayerServerEnabledStatusMap;
    if (_TitleMultiplayerServerEnabledStatusMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _TitleMultiplayerServerEnabledStatusMap.Add(TEXT("Initializing"), TitleMultiplayerServerEnabledStatusInitializing);
        _TitleMultiplayerServerEnabledStatusMap.Add(TEXT("Enabled"), TitleMultiplayerServerEnabledStatusEnabled);
        _TitleMultiplayerServerEnabledStatusMap.Add(TEXT("Disabled"), TitleMultiplayerServerEnabledStatusDisabled);

    }

    if (!value.IsEmpty())
    {
        auto output = _TitleMultiplayerServerEnabledStatusMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return TitleMultiplayerServerEnabledStatusInitializing; // Basically critical fail
}

PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleResponse::~FEnableMultiplayerServersForTitleResponse()
{

}

void PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Status.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Status"));
        writeTitleMultiplayerServerEnabledStatusEnumJSON(Status, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FEnableMultiplayerServersForTitleResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    Status = readTitleMultiplayerServerEnabledStatusFromValue(obj->TryGetField(TEXT("Status")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetAssetDownloadUrlRequest::~FGetAssetDownloadUrlRequest()
{

}

void PlayFab::MultiplayerModels::FGetAssetDownloadUrlRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!FileName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetAssetDownloadUrlRequest::FileName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetAssetDownloadUrlRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetAssetDownloadUrlResponse::~FGetAssetDownloadUrlResponse()
{

}

void PlayFab::MultiplayerModels::FGetAssetDownloadUrlResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AssetDownloadUrl.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("AssetDownloadUrl"));
        writer->WriteValue(AssetDownloadUrl);
    }

    if (FileName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetAssetDownloadUrlResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AssetDownloadUrlValue = obj->TryGetField(TEXT("AssetDownloadUrl"));
    if (AssetDownloadUrlValue.IsValid() && !AssetDownloadUrlValue->IsNull())
    {
        FString TmpValue;
        if (AssetDownloadUrlValue->TryGetString(TmpValue)) { AssetDownloadUrl = TmpValue; }
    }

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetAssetUploadUrlRequest::~FGetAssetUploadUrlRequest()
{

}

void PlayFab::MultiplayerModels::FGetAssetUploadUrlRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!FileName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetAssetUploadUrlRequest::FileName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetAssetUploadUrlRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetAssetUploadUrlResponse::~FGetAssetUploadUrlResponse()
{

}

void PlayFab::MultiplayerModels::FGetAssetUploadUrlResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AssetUploadUrl.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("AssetUploadUrl"));
        writer->WriteValue(AssetUploadUrl);
    }

    if (FileName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("FileName"));
        writer->WriteValue(FileName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetAssetUploadUrlResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AssetUploadUrlValue = obj->TryGetField(TEXT("AssetUploadUrl"));
    if (AssetUploadUrlValue.IsValid() && !AssetUploadUrlValue->IsNull())
    {
        FString TmpValue;
        if (AssetUploadUrlValue->TryGetString(TmpValue)) { AssetUploadUrl = TmpValue; }
    }

    const TSharedPtr<FJsonValue> FileNameValue = obj->TryGetField(TEXT("FileName"));
    if (FileNameValue.IsValid() && !FileNameValue->IsNull())
    {
        FString TmpValue;
        if (FileNameValue->TryGetString(TmpValue)) { FileName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetBuildAliasRequest::~FGetBuildAliasRequest()
{

}

void PlayFab::MultiplayerModels::FGetBuildAliasRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!AliasId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetBuildAliasRequest::AliasId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("AliasId"));
        writer->WriteValue(AliasId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetBuildAliasRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AliasIdValue = obj->TryGetField(TEXT("AliasId"));
    if (AliasIdValue.IsValid() && !AliasIdValue->IsNull())
    {
        FString TmpValue;
        if (AliasIdValue->TryGetString(TmpValue)) { AliasId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetBuildRequest::~FGetBuildRequest()
{

}

void PlayFab::MultiplayerModels::FGetBuildRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetBuildRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetBuildRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetBuildResponse::~FGetBuildResponse()
{
    //if (CustomGameContainerImage != nullptr) delete CustomGameContainerImage;
    //if (InstrumentationConfiguration != nullptr) delete InstrumentationConfiguration;

}

void PlayFab::MultiplayerModels::FGetBuildResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AreAssetsReadonly.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("AreAssetsReadonly"));
        writer->WriteValue(AreAssetsReadonly);
    }

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (BuildName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (BuildStatus.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildStatus"));
        writer->WriteValue(BuildStatus);
    }

    if (pfContainerFlavor.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerFlavor"));
        writeContainerFlavorEnumJSON(pfContainerFlavor, writer);
    }

    if (ContainerRunCommand.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ContainerRunCommand"));
        writer->WriteValue(ContainerRunCommand);
    }

    if (CreationTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("CreationTime"));
        writeDatetime(CreationTime, writer);
    }

    if (CustomGameContainerImage.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("CustomGameContainerImage"));
        CustomGameContainerImage->writeJSON(writer);
    }

    if (GameAssetReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameAssetReferences"));
        for (const FAssetReference& item : GameAssetReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (GameCertificateReferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("GameCertificateReferences"));
        for (const FGameCertificateReference& item : GameCertificateReferences)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (pfInstrumentationConfiguration.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("InstrumentationConfiguration"));
        pfInstrumentationConfiguration->writeJSON(writer);
    }

    if (Metadata.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("Metadata"));
        for (TMap<FString, FString>::TConstIterator It(Metadata); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MultiplayerServerCountPerVm"));
    writer->WriteValue(MultiplayerServerCountPerVm);

    if (OsPlatform.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("OsPlatform"));
        writer->WriteValue(OsPlatform);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (RegionConfigurations.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionConfigurations"));
        for (const FBuildRegion& item : RegionConfigurations)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (ServerType.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerType"));
        writer->WriteValue(ServerType);
    }

    if (StartMultiplayerServerCommand.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("StartMultiplayerServerCommand"));
        writer->WriteValue(StartMultiplayerServerCommand);
    }

    if (UseStreamingForAssetDownloads.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UseStreamingForAssetDownloads"));
        writer->WriteValue(UseStreamingForAssetDownloads);
    }

    if (VmSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("VmSize"));
        writeAzureVmSizeEnumJSON(VmSize, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetBuildResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AreAssetsReadonlyValue = obj->TryGetField(TEXT("AreAssetsReadonly"));
    if (AreAssetsReadonlyValue.IsValid() && !AreAssetsReadonlyValue->IsNull())
    {
        bool TmpValue;
        if (AreAssetsReadonlyValue->TryGetBool(TmpValue)) { AreAssetsReadonly = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildStatusValue = obj->TryGetField(TEXT("BuildStatus"));
    if (BuildStatusValue.IsValid() && !BuildStatusValue->IsNull())
    {
        FString TmpValue;
        if (BuildStatusValue->TryGetString(TmpValue)) { BuildStatus = TmpValue; }
    }

    pfContainerFlavor = readContainerFlavorFromValue(obj->TryGetField(TEXT("ContainerFlavor")));

    const TSharedPtr<FJsonValue> ContainerRunCommandValue = obj->TryGetField(TEXT("ContainerRunCommand"));
    if (ContainerRunCommandValue.IsValid() && !ContainerRunCommandValue->IsNull())
    {
        FString TmpValue;
        if (ContainerRunCommandValue->TryGetString(TmpValue)) { ContainerRunCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreationTimeValue = obj->TryGetField(TEXT("CreationTime"));
    if (CreationTimeValue.IsValid())
        CreationTime = readDatetime(CreationTimeValue);


    const TSharedPtr<FJsonValue> CustomGameContainerImageValue = obj->TryGetField(TEXT("CustomGameContainerImage"));
    if (CustomGameContainerImageValue.IsValid() && !CustomGameContainerImageValue->IsNull())
    {
        CustomGameContainerImage = MakeShareable(new FContainerImageReference(CustomGameContainerImageValue->AsObject()));
    }

    const TArray<TSharedPtr<FJsonValue>>&GameAssetReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameAssetReferences"));
    for (int32 Idx = 0; Idx < GameAssetReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameAssetReferencesArray[Idx];
        GameAssetReferences.Add(FAssetReference(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&GameCertificateReferencesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("GameCertificateReferences"));
    for (int32 Idx = 0; Idx < GameCertificateReferencesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = GameCertificateReferencesArray[Idx];
        GameCertificateReferences.Add(FGameCertificateReference(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> InstrumentationConfigurationValue = obj->TryGetField(TEXT("InstrumentationConfiguration"));
    if (InstrumentationConfigurationValue.IsValid() && !InstrumentationConfigurationValue->IsNull())
    {
        pfInstrumentationConfiguration = MakeShareable(new FInstrumentationConfiguration(InstrumentationConfigurationValue->AsObject()));
    }

    const TSharedPtr<FJsonObject>* MetadataObject;
    if (obj->TryGetObjectField(TEXT("Metadata"), MetadataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*MetadataObject)->Values); It; ++It)
        {
            Metadata.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MultiplayerServerCountPerVmValue = obj->TryGetField(TEXT("MultiplayerServerCountPerVm"));
    if (MultiplayerServerCountPerVmValue.IsValid() && !MultiplayerServerCountPerVmValue->IsNull())
    {
        int32 TmpValue;
        if (MultiplayerServerCountPerVmValue->TryGetNumber(TmpValue)) { MultiplayerServerCountPerVm = TmpValue; }
    }

    const TSharedPtr<FJsonValue> OsPlatformValue = obj->TryGetField(TEXT("OsPlatform"));
    if (OsPlatformValue.IsValid() && !OsPlatformValue->IsNull())
    {
        FString TmpValue;
        if (OsPlatformValue->TryGetString(TmpValue)) { OsPlatform = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&RegionConfigurationsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("RegionConfigurations"));
    for (int32 Idx = 0; Idx < RegionConfigurationsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = RegionConfigurationsArray[Idx];
        RegionConfigurations.Add(FBuildRegion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> ServerTypeValue = obj->TryGetField(TEXT("ServerType"));
    if (ServerTypeValue.IsValid() && !ServerTypeValue->IsNull())
    {
        FString TmpValue;
        if (ServerTypeValue->TryGetString(TmpValue)) { ServerType = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StartMultiplayerServerCommandValue = obj->TryGetField(TEXT("StartMultiplayerServerCommand"));
    if (StartMultiplayerServerCommandValue.IsValid() && !StartMultiplayerServerCommandValue->IsNull())
    {
        FString TmpValue;
        if (StartMultiplayerServerCommandValue->TryGetString(TmpValue)) { StartMultiplayerServerCommand = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UseStreamingForAssetDownloadsValue = obj->TryGetField(TEXT("UseStreamingForAssetDownloads"));
    if (UseStreamingForAssetDownloadsValue.IsValid() && !UseStreamingForAssetDownloadsValue->IsNull())
    {
        bool TmpValue;
        if (UseStreamingForAssetDownloadsValue->TryGetBool(TmpValue)) { UseStreamingForAssetDownloads = TmpValue; }
    }

    VmSize = readAzureVmSizeFromValue(obj->TryGetField(TEXT("VmSize")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsRequest::~FGetContainerRegistryCredentialsRequest()
{

}

void PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsResponse::~FGetContainerRegistryCredentialsResponse()
{

}

void PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DnsName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("DnsName"));
        writer->WriteValue(DnsName);
    }

    if (Password.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Password"));
        writer->WriteValue(Password);
    }

    if (Username.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Username"));
        writer->WriteValue(Username);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetContainerRegistryCredentialsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DnsNameValue = obj->TryGetField(TEXT("DnsName"));
    if (DnsNameValue.IsValid() && !DnsNameValue->IsNull())
    {
        FString TmpValue;
        if (DnsNameValue->TryGetString(TmpValue)) { DnsName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMatchmakingTicketRequest::~FGetMatchmakingTicketRequest()
{

}

void PlayFab::MultiplayerModels::FGetMatchmakingTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("EscapeObject"));
    writer->WriteValue(EscapeObject);

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchmakingTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchmakingTicketRequest::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMatchmakingTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EscapeObjectValue = obj->TryGetField(TEXT("EscapeObject"));
    if (EscapeObjectValue.IsValid() && !EscapeObjectValue->IsNull())
    {
        bool TmpValue;
        if (EscapeObjectValue->TryGetBool(TmpValue)) { EscapeObject = TmpValue; }
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMatchmakingTicketResult::~FGetMatchmakingTicketResult()
{

}

void PlayFab::MultiplayerModels::FGetMatchmakingTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CancellationReasonString.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("CancellationReasonString"));
        writer->WriteValue(CancellationReasonString);
    }

    writer->WriteIdentifierPrefix(TEXT("Created"));
    writeDatetime(Created, writer);

    writer->WriteIdentifierPrefix(TEXT("Creator"));
    Creator.writeJSON(writer);

    writer->WriteIdentifierPrefix(TEXT("GiveUpAfterSeconds"));
    writer->WriteValue(GiveUpAfterSeconds);

    if (MatchId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("MatchId"));
        writer->WriteValue(MatchId);
    }

    writer->WriteArrayStart(TEXT("Members"));
    for (const FMatchmakingPlayer& item : Members)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (MembersToMatchWith.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("MembersToMatchWith"));
        for (const FEntityKey& item : MembersToMatchWith)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchmakingTicketResult::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (!Status.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchmakingTicketResult::Status, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Status"));
        writer->WriteValue(Status);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchmakingTicketResult::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMatchmakingTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> CancellationReasonStringValue = obj->TryGetField(TEXT("CancellationReasonString"));
    if (CancellationReasonStringValue.IsValid() && !CancellationReasonStringValue->IsNull())
    {
        FString TmpValue;
        if (CancellationReasonStringValue->TryGetString(TmpValue)) { CancellationReasonString = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreatedValue = obj->TryGetField(TEXT("Created"));
    if (CreatedValue.IsValid())
        Created = readDatetime(CreatedValue);


    const TSharedPtr<FJsonValue> CreatorValue = obj->TryGetField(TEXT("Creator"));
    if (CreatorValue.IsValid() && !CreatorValue->IsNull())
    {
        Creator = FEntityKey(CreatorValue->AsObject());
    }

    const TSharedPtr<FJsonValue> GiveUpAfterSecondsValue = obj->TryGetField(TEXT("GiveUpAfterSeconds"));
    if (GiveUpAfterSecondsValue.IsValid() && !GiveUpAfterSecondsValue->IsNull())
    {
        int32 TmpValue;
        if (GiveUpAfterSecondsValue->TryGetNumber(TmpValue)) { GiveUpAfterSeconds = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MatchIdValue = obj->TryGetField(TEXT("MatchId"));
    if (MatchIdValue.IsValid() && !MatchIdValue->IsNull())
    {
        FString TmpValue;
        if (MatchIdValue->TryGetString(TmpValue)) { MatchId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&MembersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Members"));
    for (int32 Idx = 0; Idx < MembersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersArray[Idx];
        Members.Add(FMatchmakingPlayer(CurrentItem->AsObject()));
    }


    const TArray<TSharedPtr<FJsonValue>>&MembersToMatchWithArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("MembersToMatchWith"));
    for (int32 Idx = 0; Idx < MembersToMatchWithArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersToMatchWithArray[Idx];
        MembersToMatchWith.Add(FEntityKey(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StatusValue = obj->TryGetField(TEXT("Status"));
    if (StatusValue.IsValid() && !StatusValue->IsNull())
    {
        FString TmpValue;
        if (StatusValue->TryGetString(TmpValue)) { Status = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMatchRequest::~FGetMatchRequest()
{

}

void PlayFab::MultiplayerModels::FGetMatchRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("EscapeObject"));
    writer->WriteValue(EscapeObject);

    if (!MatchId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchRequest::MatchId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("MatchId"));
        writer->WriteValue(MatchId);
    }

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteIdentifierPrefix(TEXT("ReturnMemberAttributes"));
    writer->WriteValue(ReturnMemberAttributes);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMatchRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EscapeObjectValue = obj->TryGetField(TEXT("EscapeObject"));
    if (EscapeObjectValue.IsValid() && !EscapeObjectValue->IsNull())
    {
        bool TmpValue;
        if (EscapeObjectValue->TryGetBool(TmpValue)) { EscapeObject = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MatchIdValue = obj->TryGetField(TEXT("MatchId"));
    if (MatchIdValue.IsValid() && !MatchIdValue->IsNull())
    {
        FString TmpValue;
        if (MatchIdValue->TryGetString(TmpValue)) { MatchId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ReturnMemberAttributesValue = obj->TryGetField(TEXT("ReturnMemberAttributes"));
    if (ReturnMemberAttributesValue.IsValid() && !ReturnMemberAttributesValue->IsNull())
    {
        bool TmpValue;
        if (ReturnMemberAttributesValue->TryGetBool(TmpValue)) { ReturnMemberAttributes = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMatchResult::~FGetMatchResult()
{
    //if (ServerDetails != nullptr) delete ServerDetails;

}

void PlayFab::MultiplayerModels::FGetMatchResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!MatchId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMatchResult::MatchId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("MatchId"));
        writer->WriteValue(MatchId);
    }

    writer->WriteArrayStart(TEXT("Members"));
    for (const FMatchmakingPlayerWithTeamAssignment& item : Members)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (RegionPreferences.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("RegionPreferences"));
        for (const FString& item : RegionPreferences)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (pfServerDetails.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("ServerDetails"));
        pfServerDetails->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMatchResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> MatchIdValue = obj->TryGetField(TEXT("MatchId"));
    if (MatchIdValue.IsValid() && !MatchIdValue->IsNull())
    {
        FString TmpValue;
        if (MatchIdValue->TryGetString(TmpValue)) { MatchId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&MembersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Members"));
    for (int32 Idx = 0; Idx < MembersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersArray[Idx];
        Members.Add(FMatchmakingPlayerWithTeamAssignment(CurrentItem->AsObject()));
    }


    obj->TryGetStringArrayField(TEXT("RegionPreferences"), RegionPreferences);

    const TSharedPtr<FJsonValue> ServerDetailsValue = obj->TryGetField(TEXT("ServerDetails"));
    if (ServerDetailsValue.IsValid() && !ServerDetailsValue->IsNull())
    {
        pfServerDetails = MakeShareable(new FServerDetails(ServerDetailsValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsRequest::~FGetMultiplayerServerDetailsRequest()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMultiplayerServerDetailsRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMultiplayerServerDetailsRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (!SessionId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMultiplayerServerDetailsRequest::SessionId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsResponse::~FGetMultiplayerServerDetailsResponse()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (ConnectedPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ConnectedPlayers"));
        for (const FConnectedPlayer& item : ConnectedPlayers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (FQDN.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("FQDN"));
        writer->WriteValue(FQDN);
    }

    if (IPV4Address.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("IPV4Address"));
        writer->WriteValue(IPV4Address);
    }

    if (LastStateTransitionTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastStateTransitionTime"));
        writeDatetime(LastStateTransitionTime, writer);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (ServerId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerId"));
        writer->WriteValue(ServerId);
    }

    if (SessionId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    if (State.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("State"));
        writer->WriteValue(State);
    }

    if (VmId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerServerDetailsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&ConnectedPlayersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ConnectedPlayers"));
    for (int32 Idx = 0; Idx < ConnectedPlayersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ConnectedPlayersArray[Idx];
        ConnectedPlayers.Add(FConnectedPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> FQDNValue = obj->TryGetField(TEXT("FQDN"));
    if (FQDNValue.IsValid() && !FQDNValue->IsNull())
    {
        FString TmpValue;
        if (FQDNValue->TryGetString(TmpValue)) { FQDN = TmpValue; }
    }

    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastStateTransitionTimeValue = obj->TryGetField(TEXT("LastStateTransitionTime"));
    if (LastStateTransitionTimeValue.IsValid())
        LastStateTransitionTime = readDatetime(LastStateTransitionTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerServerLogsRequest::~FGetMultiplayerServerLogsRequest()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerServerLogsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!ServerId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMultiplayerServerLogsRequest::ServerId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("ServerId"));
        writer->WriteValue(ServerId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerServerLogsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerServerLogsResponse::~FGetMultiplayerServerLogsResponse()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerServerLogsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (LogDownloadUrl.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("LogDownloadUrl"));
        writer->WriteValue(LogDownloadUrl);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerServerLogsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> LogDownloadUrlValue = obj->TryGetField(TEXT("LogDownloadUrl"));
    if (LogDownloadUrlValue.IsValid() && !LogDownloadUrlValue->IsNull())
    {
        FString TmpValue;
        if (LogDownloadUrlValue->TryGetString(TmpValue)) { LogDownloadUrl = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetMultiplayerSessionLogsBySessionIdRequest::~FGetMultiplayerSessionLogsBySessionIdRequest()
{

}

void PlayFab::MultiplayerModels::FGetMultiplayerSessionLogsBySessionIdRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!SessionId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetMultiplayerSessionLogsBySessionIdRequest::SessionId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetMultiplayerSessionLogsBySessionIdRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetQueueStatisticsRequest::~FGetQueueStatisticsRequest()
{

}

void PlayFab::MultiplayerModels::FGetQueueStatisticsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetQueueStatisticsRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetQueueStatisticsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FStatistics::~FStatistics()
{

}

void PlayFab::MultiplayerModels::FStatistics::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Average"));
    writer->WriteValue(Average);

    writer->WriteIdentifierPrefix(TEXT("Percentile50"));
    writer->WriteValue(Percentile50);

    writer->WriteIdentifierPrefix(TEXT("Percentile90"));
    writer->WriteValue(Percentile90);

    writer->WriteIdentifierPrefix(TEXT("Percentile99"));
    writer->WriteValue(Percentile99);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FStatistics::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AverageValue = obj->TryGetField(TEXT("Average"));
    if (AverageValue.IsValid() && !AverageValue->IsNull())
    {
        double TmpValue;
        if (AverageValue->TryGetNumber(TmpValue)) { Average = TmpValue; }
    }

    const TSharedPtr<FJsonValue> Percentile50Value = obj->TryGetField(TEXT("Percentile50"));
    if (Percentile50Value.IsValid() && !Percentile50Value->IsNull())
    {
        double TmpValue;
        if (Percentile50Value->TryGetNumber(TmpValue)) { Percentile50 = TmpValue; }
    }

    const TSharedPtr<FJsonValue> Percentile90Value = obj->TryGetField(TEXT("Percentile90"));
    if (Percentile90Value.IsValid() && !Percentile90Value->IsNull())
    {
        double TmpValue;
        if (Percentile90Value->TryGetNumber(TmpValue)) { Percentile90 = TmpValue; }
    }

    const TSharedPtr<FJsonValue> Percentile99Value = obj->TryGetField(TEXT("Percentile99"));
    if (Percentile99Value.IsValid() && !Percentile99Value->IsNull())
    {
        double TmpValue;
        if (Percentile99Value->TryGetNumber(TmpValue)) { Percentile99 = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetQueueStatisticsResult::~FGetQueueStatisticsResult()
{
    //if (TimeToMatchStatisticsInSeconds != nullptr) delete TimeToMatchStatisticsInSeconds;

}

void PlayFab::MultiplayerModels::FGetQueueStatisticsResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (NumberOfPlayersMatching.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("NumberOfPlayersMatching"));
        writer->WriteValue(static_cast<int64>(NumberOfPlayersMatching));
    }

    if (TimeToMatchStatisticsInSeconds.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("TimeToMatchStatisticsInSeconds"));
        TimeToMatchStatisticsInSeconds->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetQueueStatisticsResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> NumberOfPlayersMatchingValue = obj->TryGetField(TEXT("NumberOfPlayersMatching"));
    if (NumberOfPlayersMatchingValue.IsValid() && !NumberOfPlayersMatchingValue->IsNull())
    {
        uint32 TmpValue;
        if (NumberOfPlayersMatchingValue->TryGetNumber(TmpValue)) { NumberOfPlayersMatching = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TimeToMatchStatisticsInSecondsValue = obj->TryGetField(TEXT("TimeToMatchStatisticsInSeconds"));
    if (TimeToMatchStatisticsInSecondsValue.IsValid() && !TimeToMatchStatisticsInSecondsValue->IsNull())
    {
        TimeToMatchStatisticsInSeconds = MakeShareable(new FStatistics(TimeToMatchStatisticsInSecondsValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetRemoteLoginEndpointRequest::~FGetRemoteLoginEndpointRequest()
{

}

void PlayFab::MultiplayerModels::FGetRemoteLoginEndpointRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetRemoteLoginEndpointRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetRemoteLoginEndpointRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (!VmId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetRemoteLoginEndpointRequest::VmId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetRemoteLoginEndpointRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetRemoteLoginEndpointResponse::~FGetRemoteLoginEndpointResponse()
{

}

void PlayFab::MultiplayerModels::FGetRemoteLoginEndpointResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (IPV4Address.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("IPV4Address"));
        writer->WriteValue(IPV4Address);
    }

    writer->WriteIdentifierPrefix(TEXT("Port"));
    writer->WriteValue(Port);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetRemoteLoginEndpointResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PortValue = obj->TryGetField(TEXT("Port"));
    if (PortValue.IsValid() && !PortValue->IsNull())
    {
        int32 TmpValue;
        if (PortValue->TryGetNumber(TmpValue)) { Port = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetServerBackfillTicketRequest::~FGetServerBackfillTicketRequest()
{

}

void PlayFab::MultiplayerModels::FGetServerBackfillTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("EscapeObject"));
    writer->WriteValue(EscapeObject);

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetServerBackfillTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetServerBackfillTicketRequest::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetServerBackfillTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EscapeObjectValue = obj->TryGetField(TEXT("EscapeObject"));
    if (EscapeObjectValue.IsValid() && !EscapeObjectValue->IsNull())
    {
        bool TmpValue;
        if (EscapeObjectValue->TryGetBool(TmpValue)) { EscapeObject = TmpValue; }
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetServerBackfillTicketResult::~FGetServerBackfillTicketResult()
{

}

void PlayFab::MultiplayerModels::FGetServerBackfillTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CancellationReasonString.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("CancellationReasonString"));
        writer->WriteValue(CancellationReasonString);
    }

    writer->WriteIdentifierPrefix(TEXT("Created"));
    writeDatetime(Created, writer);

    writer->WriteIdentifierPrefix(TEXT("GiveUpAfterSeconds"));
    writer->WriteValue(GiveUpAfterSeconds);

    if (MatchId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("MatchId"));
        writer->WriteValue(MatchId);
    }

    writer->WriteArrayStart(TEXT("Members"));
    for (const FMatchmakingPlayerWithTeamAssignment& item : Members)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetServerBackfillTicketResult::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteIdentifierPrefix(TEXT("ServerDetails"));
    pfServerDetails.writeJSON(writer);

    if (!Status.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetServerBackfillTicketResult::Status, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Status"));
        writer->WriteValue(Status);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetServerBackfillTicketResult::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetServerBackfillTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> CancellationReasonStringValue = obj->TryGetField(TEXT("CancellationReasonString"));
    if (CancellationReasonStringValue.IsValid() && !CancellationReasonStringValue->IsNull())
    {
        FString TmpValue;
        if (CancellationReasonStringValue->TryGetString(TmpValue)) { CancellationReasonString = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CreatedValue = obj->TryGetField(TEXT("Created"));
    if (CreatedValue.IsValid())
        Created = readDatetime(CreatedValue);


    const TSharedPtr<FJsonValue> GiveUpAfterSecondsValue = obj->TryGetField(TEXT("GiveUpAfterSeconds"));
    if (GiveUpAfterSecondsValue.IsValid() && !GiveUpAfterSecondsValue->IsNull())
    {
        int32 TmpValue;
        if (GiveUpAfterSecondsValue->TryGetNumber(TmpValue)) { GiveUpAfterSeconds = TmpValue; }
    }

    const TSharedPtr<FJsonValue> MatchIdValue = obj->TryGetField(TEXT("MatchId"));
    if (MatchIdValue.IsValid() && !MatchIdValue->IsNull())
    {
        FString TmpValue;
        if (MatchIdValue->TryGetString(TmpValue)) { MatchId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&MembersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Members"));
    for (int32 Idx = 0; Idx < MembersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MembersArray[Idx];
        Members.Add(FMatchmakingPlayerWithTeamAssignment(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ServerDetailsValue = obj->TryGetField(TEXT("ServerDetails"));
    if (ServerDetailsValue.IsValid() && !ServerDetailsValue->IsNull())
    {
        pfServerDetails = FServerDetails(ServerDetailsValue->AsObject());
    }

    const TSharedPtr<FJsonValue> StatusValue = obj->TryGetField(TEXT("Status"));
    if (StatusValue.IsValid() && !StatusValue->IsNull())
    {
        FString TmpValue;
        if (StatusValue->TryGetString(TmpValue)) { Status = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusRequest::~FGetTitleEnabledForMultiplayerServersStatusRequest()
{

}

void PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusResponse::~FGetTitleEnabledForMultiplayerServersStatusResponse()
{

}

void PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Status.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Status"));
        writeTitleMultiplayerServerEnabledStatusEnumJSON(Status, writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleEnabledForMultiplayerServersStatusResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    Status = readTitleMultiplayerServerEnabledStatusFromValue(obj->TryGetField(TEXT("Status")));

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotaChangeRequest::~FGetTitleMultiplayerServersQuotaChangeRequest()
{

}

void PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotaChangeRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!RequestId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: GetTitleMultiplayerServersQuotaChangeRequest::RequestId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("RequestId"));
        writer->WriteValue(RequestId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotaChangeRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> RequestIdValue = obj->TryGetField(TEXT("RequestId"));
    if (RequestIdValue.IsValid() && !RequestIdValue->IsNull())
    {
        FString TmpValue;
        if (RequestIdValue->TryGetString(TmpValue)) { RequestId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FQuotaChange::~FQuotaChange()
{

}

void PlayFab::MultiplayerModels::FQuotaChange::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ChangeDescription.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ChangeDescription"));
        writer->WriteValue(ChangeDescription);
    }

    if (Changes.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Changes"));
        for (const FCoreCapacityChange& item : Changes)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("IsPendingReview"));
    writer->WriteValue(IsPendingReview);

    if (Notes.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Notes"));
        writer->WriteValue(Notes);
    }

    if (RequestId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("RequestId"));
        writer->WriteValue(RequestId);
    }

    if (ReviewComments.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ReviewComments"));
        writer->WriteValue(ReviewComments);
    }

    writer->WriteIdentifierPrefix(TEXT("WasApproved"));
    writer->WriteValue(WasApproved);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FQuotaChange::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ChangeDescriptionValue = obj->TryGetField(TEXT("ChangeDescription"));
    if (ChangeDescriptionValue.IsValid() && !ChangeDescriptionValue->IsNull())
    {
        FString TmpValue;
        if (ChangeDescriptionValue->TryGetString(TmpValue)) { ChangeDescription = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&ChangesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Changes"));
    for (int32 Idx = 0; Idx < ChangesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ChangesArray[Idx];
        Changes.Add(FCoreCapacityChange(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> IsPendingReviewValue = obj->TryGetField(TEXT("IsPendingReview"));
    if (IsPendingReviewValue.IsValid() && !IsPendingReviewValue->IsNull())
    {
        bool TmpValue;
        if (IsPendingReviewValue->TryGetBool(TmpValue)) { IsPendingReview = TmpValue; }
    }

    const TSharedPtr<FJsonValue> NotesValue = obj->TryGetField(TEXT("Notes"));
    if (NotesValue.IsValid() && !NotesValue->IsNull())
    {
        FString TmpValue;
        if (NotesValue->TryGetString(TmpValue)) { Notes = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RequestIdValue = obj->TryGetField(TEXT("RequestId"));
    if (RequestIdValue.IsValid() && !RequestIdValue->IsNull())
    {
        FString TmpValue;
        if (RequestIdValue->TryGetString(TmpValue)) { RequestId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ReviewCommentsValue = obj->TryGetField(TEXT("ReviewComments"));
    if (ReviewCommentsValue.IsValid() && !ReviewCommentsValue->IsNull())
    {
        FString TmpValue;
        if (ReviewCommentsValue->TryGetString(TmpValue)) { ReviewComments = TmpValue; }
    }

    const TSharedPtr<FJsonValue> WasApprovedValue = obj->TryGetField(TEXT("WasApproved"));
    if (WasApprovedValue.IsValid() && !WasApprovedValue->IsNull())
    {
        bool TmpValue;
        if (WasApprovedValue->TryGetBool(TmpValue)) { WasApproved = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotaChangeResponse::~FGetTitleMultiplayerServersQuotaChangeResponse()
{
    //if (Change != nullptr) delete Change;

}

void PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotaChangeResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Change.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Change"));
        Change->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotaChangeResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> ChangeValue = obj->TryGetField(TEXT("Change"));
    if (ChangeValue.IsValid() && !ChangeValue->IsNull())
    {
        Change = MakeShareable(new FQuotaChange(ChangeValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotasRequest::~FGetTitleMultiplayerServersQuotasRequest()
{

}

void PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotasRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotasRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FTitleMultiplayerServersQuotas::~FTitleMultiplayerServersQuotas()
{

}

void PlayFab::MultiplayerModels::FTitleMultiplayerServersQuotas::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CoreCapacities.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("CoreCapacities"));
        for (const FCoreCapacity& item : CoreCapacities)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FTitleMultiplayerServersQuotas::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&CoreCapacitiesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("CoreCapacities"));
    for (int32 Idx = 0; Idx < CoreCapacitiesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = CoreCapacitiesArray[Idx];
        CoreCapacities.Add(FCoreCapacity(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotasResponse::~FGetTitleMultiplayerServersQuotasResponse()
{
    //if (Quotas != nullptr) delete Quotas;

}

void PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotasResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Quotas.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Quotas"));
        Quotas->writeJSON(writer);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FGetTitleMultiplayerServersQuotasResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> QuotasValue = obj->TryGetField(TEXT("Quotas"));
    if (QuotasValue.IsValid() && !QuotasValue->IsNull())
    {
        Quotas = MakeShareable(new FTitleMultiplayerServersQuotas(QuotasValue->AsObject()));
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FJoinMatchmakingTicketRequest::~FJoinMatchmakingTicketRequest()
{

}

void PlayFab::MultiplayerModels::FJoinMatchmakingTicketRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("Member"));
    Member.writeJSON(writer);

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: JoinMatchmakingTicketRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    if (!TicketId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: JoinMatchmakingTicketRequest::TicketId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("TicketId"));
        writer->WriteValue(TicketId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FJoinMatchmakingTicketRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MemberValue = obj->TryGetField(TEXT("Member"));
    if (MemberValue.IsValid() && !MemberValue->IsNull())
    {
        Member = FMatchmakingPlayer(MemberValue->AsObject());
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TicketIdValue = obj->TryGetField(TEXT("TicketId"));
    if (TicketIdValue.IsValid() && !TicketIdValue->IsNull())
    {
        FString TmpValue;
        if (TicketIdValue->TryGetString(TmpValue)) { TicketId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FJoinMatchmakingTicketResult::~FJoinMatchmakingTicketResult()
{

}

void PlayFab::MultiplayerModels::FJoinMatchmakingTicketResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FJoinMatchmakingTicketResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListAssetSummariesRequest::~FListAssetSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListAssetSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListAssetSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListAssetSummariesResponse::~FListAssetSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListAssetSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (AssetSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("AssetSummaries"));
        for (const FAssetSummary& item : AssetSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListAssetSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&AssetSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("AssetSummaries"));
    for (int32 Idx = 0; Idx < AssetSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = AssetSummariesArray[Idx];
        AssetSummaries.Add(FAssetSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListBuildAliasesRequest::~FListBuildAliasesRequest()
{

}

void PlayFab::MultiplayerModels::FListBuildAliasesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListBuildAliasesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListBuildAliasesResponse::~FListBuildAliasesResponse()
{

}

void PlayFab::MultiplayerModels::FListBuildAliasesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildAliases.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BuildAliases"));
        for (const FBuildAliasDetailsResponse& item : BuildAliases)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListBuildAliasesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&BuildAliasesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildAliases"));
    for (int32 Idx = 0; Idx < BuildAliasesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildAliasesArray[Idx];
        BuildAliases.Add(FBuildAliasDetailsResponse(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListBuildSummariesRequest::~FListBuildSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListBuildSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListBuildSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListBuildSummariesResponse::~FListBuildSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListBuildSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BuildSummaries"));
        for (const FBuildSummary& item : BuildSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListBuildSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&BuildSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildSummaries"));
    for (int32 Idx = 0; Idx < BuildSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildSummariesArray[Idx];
        BuildSummaries.Add(FBuildSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListCertificateSummariesRequest::~FListCertificateSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListCertificateSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListCertificateSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListCertificateSummariesResponse::~FListCertificateSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListCertificateSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CertificateSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("CertificateSummaries"));
        for (const FCertificateSummary& item : CertificateSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListCertificateSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&CertificateSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("CertificateSummaries"));
    for (int32 Idx = 0; Idx < CertificateSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = CertificateSummariesArray[Idx];
        CertificateSummaries.Add(FCertificateSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImagesRequest::~FListContainerImagesRequest()
{

}

void PlayFab::MultiplayerModels::FListContainerImagesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImagesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImagesResponse::~FListContainerImagesResponse()
{

}

void PlayFab::MultiplayerModels::FListContainerImagesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Images.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Images"));
        for (const FString& item : Images)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImagesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("Images"), Images);

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImageTagsRequest::~FListContainerImageTagsRequest()
{

}

void PlayFab::MultiplayerModels::FListContainerImageTagsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (ImageName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ImageName"));
        writer->WriteValue(ImageName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImageTagsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> ImageNameValue = obj->TryGetField(TEXT("ImageName"));
    if (ImageNameValue.IsValid() && !ImageNameValue->IsNull())
    {
        FString TmpValue;
        if (ImageNameValue->TryGetString(TmpValue)) { ImageName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListContainerImageTagsResponse::~FListContainerImageTagsResponse()
{

}

void PlayFab::MultiplayerModels::FListContainerImageTagsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Tags.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Tags"));
        for (const FString& item : Tags)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListContainerImageTagsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    obj->TryGetStringArrayField(TEXT("Tags"), Tags);

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListMatchmakingTicketsForPlayerRequest::~FListMatchmakingTicketsForPlayerRequest()
{
    //if (Entity != nullptr) delete Entity;

}

void PlayFab::MultiplayerModels::FListMatchmakingTicketsForPlayerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Entity.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("Entity"));
        Entity->writeJSON(writer);
    }

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ListMatchmakingTicketsForPlayerRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListMatchmakingTicketsForPlayerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = MakeShareable(new FEntityKey(EntityValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListMatchmakingTicketsForPlayerResult::~FListMatchmakingTicketsForPlayerResult()
{

}

void PlayFab::MultiplayerModels::FListMatchmakingTicketsForPlayerResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteArrayStart(TEXT("TicketIds"));
    for (const FString& item : TicketIds)
        writer->WriteValue(item);
    writer->WriteArrayEnd();


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListMatchmakingTicketsForPlayerResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    HasSucceeded &= obj->TryGetStringArrayField(TEXT("TicketIds"), TicketIds);

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListMultiplayerServersRequest::~FListMultiplayerServersRequest()
{

}

void PlayFab::MultiplayerModels::FListMultiplayerServersRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ListMultiplayerServersRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ListMultiplayerServersRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListMultiplayerServersRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FMultiplayerServerSummary::~FMultiplayerServerSummary()
{

}

void PlayFab::MultiplayerModels::FMultiplayerServerSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (ConnectedPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ConnectedPlayers"));
        for (const FConnectedPlayer& item : ConnectedPlayers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (LastStateTransitionTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastStateTransitionTime"));
        writeDatetime(LastStateTransitionTime, writer);
    }

    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (ServerId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerId"));
        writer->WriteValue(ServerId);
    }

    if (SessionId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    if (State.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("State"));
        writer->WriteValue(State);
    }

    if (VmId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FMultiplayerServerSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ConnectedPlayersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ConnectedPlayers"));
    for (int32 Idx = 0; Idx < ConnectedPlayersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ConnectedPlayersArray[Idx];
        ConnectedPlayers.Add(FConnectedPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> LastStateTransitionTimeValue = obj->TryGetField(TEXT("LastStateTransitionTime"));
    if (LastStateTransitionTimeValue.IsValid())
        LastStateTransitionTime = readDatetime(LastStateTransitionTimeValue);


    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListMultiplayerServersResponse::~FListMultiplayerServersResponse()
{

}

void PlayFab::MultiplayerModels::FListMultiplayerServersResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (MultiplayerServerSummaries.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("MultiplayerServerSummaries"));
        for (const FMultiplayerServerSummary& item : MultiplayerServerSummaries)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListMultiplayerServersResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&MultiplayerServerSummariesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("MultiplayerServerSummaries"));
    for (int32 Idx = 0; Idx < MultiplayerServerSummariesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = MultiplayerServerSummariesArray[Idx];
        MultiplayerServerSummaries.Add(FMultiplayerServerSummary(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListPartyQosServersRequest::~FListPartyQosServersRequest()
{

}

void PlayFab::MultiplayerModels::FListPartyQosServersRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListPartyQosServersRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FQosServer::~FQosServer()
{

}

void PlayFab::MultiplayerModels::FQosServer::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (ServerUrl.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerUrl"));
        writer->WriteValue(ServerUrl);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FQosServer::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ServerUrlValue = obj->TryGetField(TEXT("ServerUrl"));
    if (ServerUrlValue.IsValid() && !ServerUrlValue->IsNull())
    {
        FString TmpValue;
        if (ServerUrlValue->TryGetString(TmpValue)) { ServerUrl = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListPartyQosServersResponse::~FListPartyQosServersResponse()
{

}

void PlayFab::MultiplayerModels::FListPartyQosServersResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (QosServers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("QosServers"));
        for (const FQosServer& item : QosServers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListPartyQosServersResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&QosServersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("QosServers"));
    for (int32 Idx = 0; Idx < QosServersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = QosServersArray[Idx];
        QosServers.Add(FQosServer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListQosServersForTitleRequest::~FListQosServersForTitleRequest()
{

}

void PlayFab::MultiplayerModels::FListQosServersForTitleRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (IncludeAllRegions.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("IncludeAllRegions"));
        writer->WriteValue(IncludeAllRegions);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListQosServersForTitleRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> IncludeAllRegionsValue = obj->TryGetField(TEXT("IncludeAllRegions"));
    if (IncludeAllRegionsValue.IsValid() && !IncludeAllRegionsValue->IsNull())
    {
        bool TmpValue;
        if (IncludeAllRegionsValue->TryGetBool(TmpValue)) { IncludeAllRegions = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListQosServersForTitleResponse::~FListQosServersForTitleResponse()
{

}

void PlayFab::MultiplayerModels::FListQosServersForTitleResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (QosServers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("QosServers"));
        for (const FQosServer& item : QosServers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListQosServersForTitleResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&QosServersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("QosServers"));
    for (int32 Idx = 0; Idx < QosServersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = QosServersArray[Idx];
        QosServers.Add(FQosServer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListServerBackfillTicketsForPlayerRequest::~FListServerBackfillTicketsForPlayerRequest()
{

}

void PlayFab::MultiplayerModels::FListServerBackfillTicketsForPlayerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("Entity"));
    Entity.writeJSON(writer);

    if (!QueueName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ListServerBackfillTicketsForPlayerRequest::QueueName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("QueueName"));
        writer->WriteValue(QueueName);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListServerBackfillTicketsForPlayerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> EntityValue = obj->TryGetField(TEXT("Entity"));
    if (EntityValue.IsValid() && !EntityValue->IsNull())
    {
        Entity = FEntityKey(EntityValue->AsObject());
    }

    const TSharedPtr<FJsonValue> QueueNameValue = obj->TryGetField(TEXT("QueueName"));
    if (QueueNameValue.IsValid() && !QueueNameValue->IsNull())
    {
        FString TmpValue;
        if (QueueNameValue->TryGetString(TmpValue)) { QueueName = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListServerBackfillTicketsForPlayerResult::~FListServerBackfillTicketsForPlayerResult()
{

}

void PlayFab::MultiplayerModels::FListServerBackfillTicketsForPlayerResult::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteArrayStart(TEXT("TicketIds"));
    for (const FString& item : TicketIds)
        writer->WriteValue(item);
    writer->WriteArrayEnd();


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListServerBackfillTicketsForPlayerResult::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    HasSucceeded &= obj->TryGetStringArrayField(TEXT("TicketIds"), TicketIds);

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListTitleMultiplayerServersQuotaChangesRequest::~FListTitleMultiplayerServersQuotaChangesRequest()
{

}

void PlayFab::MultiplayerModels::FListTitleMultiplayerServersQuotaChangesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListTitleMultiplayerServersQuotaChangesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListTitleMultiplayerServersQuotaChangesResponse::~FListTitleMultiplayerServersQuotaChangesResponse()
{

}

void PlayFab::MultiplayerModels::FListTitleMultiplayerServersQuotaChangesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Changes.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Changes"));
        for (const FQuotaChange& item : Changes)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListTitleMultiplayerServersQuotaChangesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&ChangesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Changes"));
    for (int32 Idx = 0; Idx < ChangesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ChangesArray[Idx];
        Changes.Add(FQuotaChange(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListVirtualMachineSummariesRequest::~FListVirtualMachineSummariesRequest()
{

}

void PlayFab::MultiplayerModels::FListVirtualMachineSummariesRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ListVirtualMachineSummariesRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (PageSize.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PageSize"));
        writer->WriteValue(PageSize);
    }

    if (!Region.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ListVirtualMachineSummariesRequest::Region, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListVirtualMachineSummariesRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FVirtualMachineSummary::~FVirtualMachineSummary()
{

}

void PlayFab::MultiplayerModels::FVirtualMachineSummary::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (HealthStatus.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("HealthStatus"));
        writer->WriteValue(HealthStatus);
    }

    if (State.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("State"));
        writer->WriteValue(State);
    }

    if (VmId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FVirtualMachineSummary::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> HealthStatusValue = obj->TryGetField(TEXT("HealthStatus"));
    if (HealthStatusValue.IsValid() && !HealthStatusValue->IsNull())
    {
        FString TmpValue;
        if (HealthStatusValue->TryGetString(TmpValue)) { HealthStatus = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FListVirtualMachineSummariesResponse::~FListVirtualMachineSummariesResponse()
{

}

void PlayFab::MultiplayerModels::FListVirtualMachineSummariesResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("PageSize"));
    writer->WriteValue(PageSize);

    if (SkipToken.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SkipToken"));
        writer->WriteValue(SkipToken);
    }

    if (VirtualMachines.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("VirtualMachines"));
        for (const FVirtualMachineSummary& item : VirtualMachines)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FListVirtualMachineSummariesResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> PageSizeValue = obj->TryGetField(TEXT("PageSize"));
    if (PageSizeValue.IsValid() && !PageSizeValue->IsNull())
    {
        int32 TmpValue;
        if (PageSizeValue->TryGetNumber(TmpValue)) { PageSize = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SkipTokenValue = obj->TryGetField(TEXT("SkipToken"));
    if (SkipTokenValue.IsValid() && !SkipTokenValue->IsNull())
    {
        FString TmpValue;
        if (SkipTokenValue->TryGetString(TmpValue)) { SkipToken = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&VirtualMachinesArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("VirtualMachines"));
    for (int32 Idx = 0; Idx < VirtualMachinesArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = VirtualMachinesArray[Idx];
        VirtualMachines.Add(FVirtualMachineSummary(CurrentItem->AsObject()));
    }


    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeOsPlatformEnumJSON(OsPlatform enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case OsPlatformWindows: writer->WriteValue(TEXT("Windows")); break;
    case OsPlatformLinux: writer->WriteValue(TEXT("Linux")); break;
    }
}

MultiplayerModels::OsPlatform PlayFab::MultiplayerModels::readOsPlatformFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readOsPlatformFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::OsPlatform PlayFab::MultiplayerModels::readOsPlatformFromValue(const FString& value)
{
    static TMap<FString, OsPlatform> _OsPlatformMap;
    if (_OsPlatformMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _OsPlatformMap.Add(TEXT("Windows"), OsPlatformWindows);
        _OsPlatformMap.Add(TEXT("Linux"), OsPlatformLinux);

    }

    if (!value.IsEmpty())
    {
        auto output = _OsPlatformMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return OsPlatformWindows; // Basically critical fail
}

PlayFab::MultiplayerModels::FRequestMultiplayerServerRequest::~FRequestMultiplayerServerRequest()
{
    //if (BuildAliasParams != nullptr) delete BuildAliasParams;

}

void PlayFab::MultiplayerModels::FRequestMultiplayerServerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (pfBuildAliasParams.IsValid())
    {
        writer->WriteIdentifierPrefix(TEXT("BuildAliasParams"));
        pfBuildAliasParams->writeJSON(writer);
    }

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (InitialPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("InitialPlayers"));
        for (const FString& item : InitialPlayers)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    writer->WriteArrayStart(TEXT("PreferredRegions"));
    for (const FString& item : PreferredRegions)
        writer->WriteValue(item);
    writer->WriteArrayEnd();


    if (SessionCookie.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SessionCookie"));
        writer->WriteValue(SessionCookie);
    }

    if (!SessionId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: RequestMultiplayerServerRequest::SessionId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRequestMultiplayerServerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildAliasParamsValue = obj->TryGetField(TEXT("BuildAliasParams"));
    if (BuildAliasParamsValue.IsValid() && !BuildAliasParamsValue->IsNull())
    {
        pfBuildAliasParams = MakeShareable(new FBuildAliasParams(BuildAliasParamsValue->AsObject()));
    }

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    obj->TryGetStringArrayField(TEXT("InitialPlayers"), InitialPlayers);

    HasSucceeded &= obj->TryGetStringArrayField(TEXT("PreferredRegions"), PreferredRegions);

    const TSharedPtr<FJsonValue> SessionCookieValue = obj->TryGetField(TEXT("SessionCookie"));
    if (SessionCookieValue.IsValid() && !SessionCookieValue->IsNull())
    {
        FString TmpValue;
        if (SessionCookieValue->TryGetString(TmpValue)) { SessionCookie = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRequestMultiplayerServerResponse::~FRequestMultiplayerServerResponse()
{

}

void PlayFab::MultiplayerModels::FRequestMultiplayerServerResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (ConnectedPlayers.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("ConnectedPlayers"));
        for (const FConnectedPlayer& item : ConnectedPlayers)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (FQDN.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("FQDN"));
        writer->WriteValue(FQDN);
    }

    if (IPV4Address.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("IPV4Address"));
        writer->WriteValue(IPV4Address);
    }

    if (LastStateTransitionTime.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("LastStateTransitionTime"));
        writeDatetime(LastStateTransitionTime, writer);
    }

    if (Ports.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Ports"));
        for (const FPort& item : Ports)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (ServerId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ServerId"));
        writer->WriteValue(ServerId);
    }

    if (SessionId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    if (State.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("State"));
        writer->WriteValue(State);
    }

    if (VmId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("VmId"));
        writer->WriteValue(VmId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRequestMultiplayerServerResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&ConnectedPlayersArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("ConnectedPlayers"));
    for (int32 Idx = 0; Idx < ConnectedPlayersArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = ConnectedPlayersArray[Idx];
        ConnectedPlayers.Add(FConnectedPlayer(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> FQDNValue = obj->TryGetField(TEXT("FQDN"));
    if (FQDNValue.IsValid() && !FQDNValue->IsNull())
    {
        FString TmpValue;
        if (FQDNValue->TryGetString(TmpValue)) { FQDN = TmpValue; }
    }

    const TSharedPtr<FJsonValue> IPV4AddressValue = obj->TryGetField(TEXT("IPV4Address"));
    if (IPV4AddressValue.IsValid() && !IPV4AddressValue->IsNull())
    {
        FString TmpValue;
        if (IPV4AddressValue->TryGetString(TmpValue)) { IPV4Address = TmpValue; }
    }

    const TSharedPtr<FJsonValue> LastStateTransitionTimeValue = obj->TryGetField(TEXT("LastStateTransitionTime"));
    if (LastStateTransitionTimeValue.IsValid())
        LastStateTransitionTime = readDatetime(LastStateTransitionTimeValue);


    const TArray<TSharedPtr<FJsonValue>>&PortsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Ports"));
    for (int32 Idx = 0; Idx < PortsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = PortsArray[Idx];
        Ports.Add(FPort(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ServerIdValue = obj->TryGetField(TEXT("ServerId"));
    if (ServerIdValue.IsValid() && !ServerIdValue->IsNull())
    {
        FString TmpValue;
        if (ServerIdValue->TryGetString(TmpValue)) { ServerId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> StateValue = obj->TryGetField(TEXT("State"));
    if (StateValue.IsValid() && !StateValue->IsNull())
    {
        FString TmpValue;
        if (StateValue->TryGetString(TmpValue)) { State = TmpValue; }
    }

    const TSharedPtr<FJsonValue> VmIdValue = obj->TryGetField(TEXT("VmId"));
    if (VmIdValue.IsValid() && !VmIdValue->IsNull())
    {
        FString TmpValue;
        if (VmIdValue->TryGetString(TmpValue)) { VmId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsRequest::~FRolloverContainerRegistryCredentialsRequest()
{

}

void PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsResponse::~FRolloverContainerRegistryCredentialsResponse()
{

}

void PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (DnsName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("DnsName"));
        writer->WriteValue(DnsName);
    }

    if (Password.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Password"));
        writer->WriteValue(Password);
    }

    if (Username.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Username"));
        writer->WriteValue(Username);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FRolloverContainerRegistryCredentialsResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> DnsNameValue = obj->TryGetField(TEXT("DnsName"));
    if (DnsNameValue.IsValid() && !DnsNameValue->IsNull())
    {
        FString TmpValue;
        if (DnsNameValue->TryGetString(TmpValue)) { DnsName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PasswordValue = obj->TryGetField(TEXT("Password"));
    if (PasswordValue.IsValid() && !PasswordValue->IsNull())
    {
        FString TmpValue;
        if (PasswordValue->TryGetString(TmpValue)) { Password = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    return HasSucceeded;
}

void PlayFab::MultiplayerModels::writeServerTypeEnumJSON(ServerType enumVal, JsonWriter& writer)
{
    switch (enumVal)
    {

    case ServerTypeContainer: writer->WriteValue(TEXT("Container")); break;
    case ServerTypeProcess: writer->WriteValue(TEXT("Process")); break;
    }
}

MultiplayerModels::ServerType PlayFab::MultiplayerModels::readServerTypeFromValue(const TSharedPtr<FJsonValue>& value)
{
    return readServerTypeFromValue(value.IsValid() ? value->AsString() : "");
}

MultiplayerModels::ServerType PlayFab::MultiplayerModels::readServerTypeFromValue(const FString& value)
{
    static TMap<FString, ServerType> _ServerTypeMap;
    if (_ServerTypeMap.Num() == 0)
    {
        // Auto-generate the map on the first use
        _ServerTypeMap.Add(TEXT("Container"), ServerTypeContainer);
        _ServerTypeMap.Add(TEXT("Process"), ServerTypeProcess);

    }

    if (!value.IsEmpty())
    {
        auto output = _ServerTypeMap.Find(value);
        if (output != nullptr)
            return *output;
    }

    return ServerTypeContainer; // Basically critical fail
}

PlayFab::MultiplayerModels::FShutdownMultiplayerServerRequest::~FShutdownMultiplayerServerRequest()
{

}

void PlayFab::MultiplayerModels::FShutdownMultiplayerServerRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (BuildId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (Region.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Region"));
        writer->WriteValue(Region);
    }

    if (!SessionId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: ShutdownMultiplayerServerRequest::SessionId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("SessionId"));
        writer->WriteValue(SessionId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FShutdownMultiplayerServerRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> RegionValue = obj->TryGetField(TEXT("Region"));
    if (RegionValue.IsValid() && !RegionValue->IsNull())
    {
        FString TmpValue;
        if (RegionValue->TryGetString(TmpValue)) { Region = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SessionIdValue = obj->TryGetField(TEXT("SessionId"));
    if (SessionIdValue.IsValid() && !SessionIdValue->IsNull())
    {
        FString TmpValue;
        if (SessionIdValue->TryGetString(TmpValue)) { SessionId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUntagContainerImageRequest::~FUntagContainerImageRequest()
{

}

void PlayFab::MultiplayerModels::FUntagContainerImageRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (ImageName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ImageName"));
        writer->WriteValue(ImageName);
    }

    if (Tag.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Tag"));
        writer->WriteValue(Tag);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUntagContainerImageRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> ImageNameValue = obj->TryGetField(TEXT("ImageName"));
    if (ImageNameValue.IsValid() && !ImageNameValue->IsNull())
    {
        FString TmpValue;
        if (ImageNameValue->TryGetString(TmpValue)) { ImageName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TagValue = obj->TryGetField(TEXT("Tag"));
    if (TagValue.IsValid() && !TagValue->IsNull())
    {
        FString TmpValue;
        if (TagValue->TryGetString(TmpValue)) { Tag = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUpdateBuildAliasRequest::~FUpdateBuildAliasRequest()
{

}

void PlayFab::MultiplayerModels::FUpdateBuildAliasRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!AliasId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateBuildAliasRequest::AliasId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("AliasId"));
        writer->WriteValue(AliasId);
    }

    if (AliasName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("AliasName"));
        writer->WriteValue(AliasName);
    }

    if (BuildSelectionCriteria.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BuildSelectionCriteria"));
        for (const FBuildSelectionCriterion& item : BuildSelectionCriteria)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUpdateBuildAliasRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AliasIdValue = obj->TryGetField(TEXT("AliasId"));
    if (AliasIdValue.IsValid() && !AliasIdValue->IsNull())
    {
        FString TmpValue;
        if (AliasIdValue->TryGetString(TmpValue)) { AliasId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> AliasNameValue = obj->TryGetField(TEXT("AliasName"));
    if (AliasNameValue.IsValid() && !AliasNameValue->IsNull())
    {
        FString TmpValue;
        if (AliasNameValue->TryGetString(TmpValue)) { AliasName = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&BuildSelectionCriteriaArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildSelectionCriteria"));
    for (int32 Idx = 0; Idx < BuildSelectionCriteriaArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildSelectionCriteriaArray[Idx];
        BuildSelectionCriteria.Add(FBuildSelectionCriterion(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUpdateBuildNameRequest::~FUpdateBuildNameRequest()
{

}

void PlayFab::MultiplayerModels::FUpdateBuildNameRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateBuildNameRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    if (!BuildName.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateBuildNameRequest::BuildName, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildName"));
        writer->WriteValue(BuildName);
    }

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUpdateBuildNameRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildNameValue = obj->TryGetField(TEXT("BuildName"));
    if (BuildNameValue.IsValid() && !BuildNameValue->IsNull())
    {
        FString TmpValue;
        if (BuildNameValue->TryGetString(TmpValue)) { BuildName = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUpdateBuildRegionRequest::~FUpdateBuildRegionRequest()
{

}

void PlayFab::MultiplayerModels::FUpdateBuildRegionRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateBuildRegionRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    writer->WriteIdentifierPrefix(TEXT("BuildRegion"));
    BuildRegion.writeJSON(writer);

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUpdateBuildRegionRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> BuildRegionValue = obj->TryGetField(TEXT("BuildRegion"));
    if (BuildRegionValue.IsValid() && !BuildRegionValue->IsNull())
    {
        BuildRegion = FBuildRegionParams(BuildRegionValue->AsObject());
    }

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUpdateBuildRegionsRequest::~FUpdateBuildRegionsRequest()
{

}

void PlayFab::MultiplayerModels::FUpdateBuildRegionsRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!BuildId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UpdateBuildRegionsRequest::BuildId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("BuildId"));
        writer->WriteValue(BuildId);
    }

    writer->WriteArrayStart(TEXT("BuildRegions"));
    for (const FBuildRegionParams& item : BuildRegions)
        item.writeJSON(writer);
    writer->WriteArrayEnd();


    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUpdateBuildRegionsRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> BuildIdValue = obj->TryGetField(TEXT("BuildId"));
    if (BuildIdValue.IsValid() && !BuildIdValue->IsNull())
    {
        FString TmpValue;
        if (BuildIdValue->TryGetString(TmpValue)) { BuildId = TmpValue; }
    }

    const TArray<TSharedPtr<FJsonValue>>&BuildRegionsArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("BuildRegions"));
    for (int32 Idx = 0; Idx < BuildRegionsArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = BuildRegionsArray[Idx];
        BuildRegions.Add(FBuildRegionParams(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    return HasSucceeded;
}

PlayFab::MultiplayerModels::FUploadCertificateRequest::~FUploadCertificateRequest()
{

}

void PlayFab::MultiplayerModels::FUploadCertificateRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("GameCertificate"));
    GameCertificate.writeJSON(writer);

    writer->WriteObjectEnd();
}

bool PlayFab::MultiplayerModels::FUploadCertificateRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> GameCertificateValue = obj->TryGetField(TEXT("GameCertificate"));
    if (GameCertificateValue.IsValid() && !GameCertificateValue->IsNull())
    {
        GameCertificate = FCertificate(GameCertificateValue->AsObject());
    }

    return HasSucceeded;
}

