//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#include "Core/PlayFabAdminInstanceAPI.h"
#include "Core/PlayFabSettings.h"
#include "Core/PlayFabResultHandler.h"
#include "PlayFab.h"

using namespace PlayFab;
using namespace PlayFab::AdminModels;

UPlayFabAdminInstanceAPI::UPlayFabAdminInstanceAPI()
{
}

UPlayFabAdminInstanceAPI::UPlayFabAdminInstanceAPI(TSharedPtr<UPlayFabAPISettings> apiSettings)
{
    this->settings = MoveTemp(apiSettings);
}

UPlayFabAdminInstanceAPI::UPlayFabAdminInstanceAPI(TSharedPtr<UPlayFabAuthenticationContext> authenticationContext)
{
    this->authContext = MoveTemp(authenticationContext);
}

UPlayFabAdminInstanceAPI::UPlayFabAdminInstanceAPI(TSharedPtr<UPlayFabAPISettings> apiSettings, TSharedPtr<UPlayFabAuthenticationContext> authenticationContext)
{
    this->settings = MoveTemp(apiSettings);
    this->authContext = MoveTemp(authenticationContext);
}

UPlayFabAdminInstanceAPI::~UPlayFabAdminInstanceAPI()
{
}

TSharedPtr<UPlayFabAPISettings> UPlayFabAdminInstanceAPI::GetSettings() const
{
    return this->settings;
}

int UPlayFabAdminInstanceAPI::GetPendingCalls() const
{
    return PlayFabRequestHandler::GetPendingCalls();
}

void UPlayFabAdminInstanceAPI::SetSettings(TSharedPtr<UPlayFabAPISettings> apiSettings)
{
    this->settings = MoveTemp(apiSettings);
}

TSharedPtr<UPlayFabAuthenticationContext> UPlayFabAdminInstanceAPI::GetAuthenticationContext() const
{
    return this->authContext;
}

void UPlayFabAdminInstanceAPI::SetAuthenticationContext(TSharedPtr<UPlayFabAuthenticationContext> authenticationContext)
{
    this->authContext = MoveTemp(authenticationContext);
}

void UPlayFabAdminInstanceAPI::ForgetAllCredentials()
{
    if (!this->authContext.IsValid())
        return;

    this->authContext->ForgetAllCredentials();
}

TSharedPtr<UPlayFabAuthenticationContext> UPlayFabAdminInstanceAPI::GetOrCreateAuthenticationContext()
{
    if (!this->authContext.IsValid())
        this->authContext = MakeSharedUObject<UPlayFabAuthenticationContext>();

    return this->authContext;
}

bool UPlayFabAdminInstanceAPI::AbortTaskInstance(
    AdminModels::FAbortTaskInstanceRequest& request,
    const FAbortTaskInstanceDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AbortTaskInstance"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAbortTaskInstanceResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAbortTaskInstanceResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAbortTaskInstanceDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FEmptyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::AddLocalizedNews(
    AdminModels::FAddLocalizedNewsRequest& request,
    const FAddLocalizedNewsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AddLocalizedNews"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAddLocalizedNewsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAddLocalizedNewsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAddLocalizedNewsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FAddLocalizedNewsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::AddNews(
    AdminModels::FAddNewsRequest& request,
    const FAddNewsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AddNews"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAddNewsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAddNewsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAddNewsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FAddNewsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::AddPlayerTag(
    AdminModels::FAddPlayerTagRequest& request,
    const FAddPlayerTagDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AddPlayerTag"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAddPlayerTagResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAddPlayerTagResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAddPlayerTagDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FAddPlayerTagResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::AddServerBuild(
    AdminModels::FAddServerBuildRequest& request,
    const FAddServerBuildDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AddServerBuild"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAddServerBuildResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAddServerBuildResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAddServerBuildDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FAddServerBuildResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::AddUserVirtualCurrency(
    AdminModels::FAddUserVirtualCurrencyRequest& request,
    const FAddUserVirtualCurrencyDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AddUserVirtualCurrency"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAddUserVirtualCurrencyResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAddUserVirtualCurrencyResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAddUserVirtualCurrencyDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FModifyUserVirtualCurrencyResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::AddVirtualCurrencyTypes(
    AdminModels::FAddVirtualCurrencyTypesRequest& request,
    const FAddVirtualCurrencyTypesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/AddVirtualCurrencyTypes"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnAddVirtualCurrencyTypesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnAddVirtualCurrencyTypesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FAddVirtualCurrencyTypesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FBlankResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::BanUsers(
    AdminModels::FBanUsersRequest& request,
    const FBanUsersDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/BanUsers"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnBanUsersResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnBanUsersResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FBanUsersDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FBanUsersResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CheckLimitedEditionItemAvailability(
    AdminModels::FCheckLimitedEditionItemAvailabilityRequest& request,
    const FCheckLimitedEditionItemAvailabilityDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CheckLimitedEditionItemAvailability"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCheckLimitedEditionItemAvailabilityResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCheckLimitedEditionItemAvailabilityResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCheckLimitedEditionItemAvailabilityDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCheckLimitedEditionItemAvailabilityResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreateActionsOnPlayersInSegmentTask(
    AdminModels::FCreateActionsOnPlayerSegmentTaskRequest& request,
    const FCreateActionsOnPlayersInSegmentTaskDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreateActionsOnPlayersInSegmentTask"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreateActionsOnPlayersInSegmentTaskResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreateActionsOnPlayersInSegmentTaskResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreateActionsOnPlayersInSegmentTaskDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCreateTaskResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreateCloudScriptTask(
    AdminModels::FCreateCloudScriptTaskRequest& request,
    const FCreateCloudScriptTaskDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreateCloudScriptTask"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreateCloudScriptTaskResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreateCloudScriptTaskResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreateCloudScriptTaskDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCreateTaskResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreateInsightsScheduledScalingTask(
    AdminModels::FCreateInsightsScheduledScalingTaskRequest& request,
    const FCreateInsightsScheduledScalingTaskDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreateInsightsScheduledScalingTask"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreateInsightsScheduledScalingTaskResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreateInsightsScheduledScalingTaskResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreateInsightsScheduledScalingTaskDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCreateTaskResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreateOpenIdConnection(
    AdminModels::FCreateOpenIdConnectionRequest& request,
    const FCreateOpenIdConnectionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreateOpenIdConnection"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreateOpenIdConnectionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreateOpenIdConnectionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreateOpenIdConnectionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FEmptyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreatePlayerSharedSecret(
    AdminModels::FCreatePlayerSharedSecretRequest& request,
    const FCreatePlayerSharedSecretDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreatePlayerSharedSecret"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreatePlayerSharedSecretResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreatePlayerSharedSecretResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreatePlayerSharedSecretDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCreatePlayerSharedSecretResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreatePlayerStatisticDefinition(
    AdminModels::FCreatePlayerStatisticDefinitionRequest& request,
    const FCreatePlayerStatisticDefinitionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreatePlayerStatisticDefinition"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreatePlayerStatisticDefinitionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreatePlayerStatisticDefinitionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreatePlayerStatisticDefinitionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCreatePlayerStatisticDefinitionResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::CreateSegment(
    AdminModels::FCreateSegmentRequest& request,
    const FCreateSegmentDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/CreateSegment"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnCreateSegmentResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnCreateSegmentResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FCreateSegmentDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FCreateSegmentResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteContent(
    AdminModels::FDeleteContentRequest& request,
    const FDeleteContentDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteContent"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteContentResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteContentResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteContentDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FBlankResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteMasterPlayerAccount(
    AdminModels::FDeleteMasterPlayerAccountRequest& request,
    const FDeleteMasterPlayerAccountDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteMasterPlayerAccount"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteMasterPlayerAccountResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteMasterPlayerAccountResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteMasterPlayerAccountDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeleteMasterPlayerAccountResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteOpenIdConnection(
    AdminModels::FDeleteOpenIdConnectionRequest& request,
    const FDeleteOpenIdConnectionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteOpenIdConnection"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteOpenIdConnectionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteOpenIdConnectionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteOpenIdConnectionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FEmptyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeletePlayer(
    AdminModels::FDeletePlayerRequest& request,
    const FDeletePlayerDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeletePlayer"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeletePlayerResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeletePlayerResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeletePlayerDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeletePlayerResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeletePlayerSharedSecret(
    AdminModels::FDeletePlayerSharedSecretRequest& request,
    const FDeletePlayerSharedSecretDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeletePlayerSharedSecret"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeletePlayerSharedSecretResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeletePlayerSharedSecretResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeletePlayerSharedSecretDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeletePlayerSharedSecretResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteSegment(
    AdminModels::FDeleteSegmentRequest& request,
    const FDeleteSegmentDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteSegment"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteSegmentResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteSegmentResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteSegmentDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeleteSegmentsResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteStore(
    AdminModels::FDeleteStoreRequest& request,
    const FDeleteStoreDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteStore"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteStoreResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteStoreResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteStoreDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeleteStoreResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteTask(
    AdminModels::FDeleteTaskRequest& request,
    const FDeleteTaskDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteTask"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteTaskResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteTaskResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteTaskDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FEmptyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteTitle(
    const FDeleteTitleDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FDeleteTitleRequest emptyRequest = AdminModels::FDeleteTitleRequest();
    return UPlayFabAdminInstanceAPI::DeleteTitle(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::DeleteTitle(
    AdminModels::FDeleteTitleRequest& request,
    const FDeleteTitleDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteTitle"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteTitleResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteTitleResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteTitleDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeleteTitleResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::DeleteTitleDataOverride(
    AdminModels::FDeleteTitleDataOverrideRequest& request,
    const FDeleteTitleDataOverrideDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/DeleteTitleDataOverride"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnDeleteTitleDataOverrideResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnDeleteTitleDataOverrideResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDeleteTitleDataOverrideDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FDeleteTitleDataOverrideResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ExportMasterPlayerData(
    AdminModels::FExportMasterPlayerDataRequest& request,
    const FExportMasterPlayerDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ExportMasterPlayerData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnExportMasterPlayerDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnExportMasterPlayerDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FExportMasterPlayerDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FExportMasterPlayerDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetActionsOnPlayersInSegmentTaskInstance(
    AdminModels::FGetTaskInstanceRequest& request,
    const FGetActionsOnPlayersInSegmentTaskInstanceDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetActionsOnPlayersInSegmentTaskInstance"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetActionsOnPlayersInSegmentTaskInstanceResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetActionsOnPlayersInSegmentTaskInstanceResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetActionsOnPlayersInSegmentTaskInstanceDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetActionsOnPlayersInSegmentTaskInstanceResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetAllSegments(
    const FGetAllSegmentsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FGetAllSegmentsRequest emptyRequest = AdminModels::FGetAllSegmentsRequest();
    return UPlayFabAdminInstanceAPI::GetAllSegments(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::GetAllSegments(
    AdminModels::FGetAllSegmentsRequest& request,
    const FGetAllSegmentsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetAllSegments"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetAllSegmentsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetAllSegmentsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetAllSegmentsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetAllSegmentsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetCatalogItems(
    AdminModels::FGetCatalogItemsRequest& request,
    const FGetCatalogItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetCatalogItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetCatalogItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetCatalogItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetCatalogItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetCatalogItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetCloudScriptRevision(
    AdminModels::FGetCloudScriptRevisionRequest& request,
    const FGetCloudScriptRevisionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetCloudScriptRevision"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetCloudScriptRevisionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetCloudScriptRevisionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetCloudScriptRevisionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetCloudScriptRevisionResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetCloudScriptTaskInstance(
    AdminModels::FGetTaskInstanceRequest& request,
    const FGetCloudScriptTaskInstanceDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetCloudScriptTaskInstance"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetCloudScriptTaskInstanceResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetCloudScriptTaskInstanceResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetCloudScriptTaskInstanceDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetCloudScriptTaskInstanceResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetCloudScriptVersions(
    const FGetCloudScriptVersionsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FGetCloudScriptVersionsRequest emptyRequest = AdminModels::FGetCloudScriptVersionsRequest();
    return UPlayFabAdminInstanceAPI::GetCloudScriptVersions(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::GetCloudScriptVersions(
    AdminModels::FGetCloudScriptVersionsRequest& request,
    const FGetCloudScriptVersionsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetCloudScriptVersions"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetCloudScriptVersionsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetCloudScriptVersionsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetCloudScriptVersionsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetCloudScriptVersionsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetContentList(
    AdminModels::FGetContentListRequest& request,
    const FGetContentListDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetContentList"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetContentListResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetContentListResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetContentListDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetContentListResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetContentUploadUrl(
    AdminModels::FGetContentUploadUrlRequest& request,
    const FGetContentUploadUrlDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetContentUploadUrl"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetContentUploadUrlResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetContentUploadUrlResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetContentUploadUrlDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetContentUploadUrlResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetDataReport(
    AdminModels::FGetDataReportRequest& request,
    const FGetDataReportDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetDataReport"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetDataReportResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetDataReportResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetDataReportDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetDataReportResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetMatchmakerGameInfo(
    AdminModels::FGetMatchmakerGameInfoRequest& request,
    const FGetMatchmakerGameInfoDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetMatchmakerGameInfo"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetMatchmakerGameInfoResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetMatchmakerGameInfoResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetMatchmakerGameInfoDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetMatchmakerGameInfoResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetMatchmakerGameModes(
    AdminModels::FGetMatchmakerGameModesRequest& request,
    const FGetMatchmakerGameModesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetMatchmakerGameModes"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetMatchmakerGameModesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetMatchmakerGameModesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetMatchmakerGameModesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetMatchmakerGameModesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayedTitleList(
    AdminModels::FGetPlayedTitleListRequest& request,
    const FGetPlayedTitleListDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayedTitleList"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayedTitleListResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayedTitleListResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayedTitleListDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayedTitleListResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerIdFromAuthToken(
    AdminModels::FGetPlayerIdFromAuthTokenRequest& request,
    const FGetPlayerIdFromAuthTokenDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerIdFromAuthToken"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerIdFromAuthTokenResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerIdFromAuthTokenResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerIdFromAuthTokenDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerIdFromAuthTokenResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerProfile(
    AdminModels::FGetPlayerProfileRequest& request,
    const FGetPlayerProfileDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerProfile"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerProfileResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerProfileResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerProfileDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerProfileResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerSegments(
    AdminModels::FGetPlayersSegmentsRequest& request,
    const FGetPlayerSegmentsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerSegments"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerSegmentsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerSegmentsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerSegmentsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerSegmentsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerSharedSecrets(
    const FGetPlayerSharedSecretsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FGetPlayerSharedSecretsRequest emptyRequest = AdminModels::FGetPlayerSharedSecretsRequest();
    return UPlayFabAdminInstanceAPI::GetPlayerSharedSecrets(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::GetPlayerSharedSecrets(
    AdminModels::FGetPlayerSharedSecretsRequest& request,
    const FGetPlayerSharedSecretsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerSharedSecrets"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerSharedSecretsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerSharedSecretsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerSharedSecretsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerSharedSecretsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayersInSegment(
    AdminModels::FGetPlayersInSegmentRequest& request,
    const FGetPlayersInSegmentDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayersInSegment"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayersInSegmentResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayersInSegmentResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayersInSegmentDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayersInSegmentResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerStatisticDefinitions(
    const FGetPlayerStatisticDefinitionsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FGetPlayerStatisticDefinitionsRequest emptyRequest = AdminModels::FGetPlayerStatisticDefinitionsRequest();
    return UPlayFabAdminInstanceAPI::GetPlayerStatisticDefinitions(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::GetPlayerStatisticDefinitions(
    AdminModels::FGetPlayerStatisticDefinitionsRequest& request,
    const FGetPlayerStatisticDefinitionsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerStatisticDefinitions"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerStatisticDefinitionsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerStatisticDefinitionsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerStatisticDefinitionsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerStatisticDefinitionsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerStatisticVersions(
    AdminModels::FGetPlayerStatisticVersionsRequest& request,
    const FGetPlayerStatisticVersionsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerStatisticVersions"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerStatisticVersionsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerStatisticVersionsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerStatisticVersionsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerStatisticVersionsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPlayerTags(
    AdminModels::FGetPlayerTagsRequest& request,
    const FGetPlayerTagsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPlayerTags"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPlayerTagsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPlayerTagsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPlayerTagsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPlayerTagsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPolicy(
    AdminModels::FGetPolicyRequest& request,
    const FGetPolicyDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPolicy"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPolicyResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPolicyResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPolicyDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPolicyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetPublisherData(
    AdminModels::FGetPublisherDataRequest& request,
    const FGetPublisherDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetPublisherData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetPublisherDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetPublisherDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetPublisherDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetPublisherDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetRandomResultTables(
    AdminModels::FGetRandomResultTablesRequest& request,
    const FGetRandomResultTablesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetRandomResultTables"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetRandomResultTablesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetRandomResultTablesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetRandomResultTablesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetRandomResultTablesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetSegments(
    AdminModels::FGetSegmentsRequest& request,
    const FGetSegmentsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetSegments"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetSegmentsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetSegmentsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetSegmentsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetSegmentsResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetServerBuildInfo(
    AdminModels::FGetServerBuildInfoRequest& request,
    const FGetServerBuildInfoDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetServerBuildInfo"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetServerBuildInfoResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetServerBuildInfoResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetServerBuildInfoDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetServerBuildInfoResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetServerBuildUploadUrl(
    AdminModels::FGetServerBuildUploadURLRequest& request,
    const FGetServerBuildUploadUrlDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetServerBuildUploadUrl"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetServerBuildUploadUrlResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetServerBuildUploadUrlResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetServerBuildUploadUrlDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetServerBuildUploadURLResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetStoreItems(
    AdminModels::FGetStoreItemsRequest& request,
    const FGetStoreItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetStoreItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetStoreItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetStoreItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetStoreItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetStoreItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetTaskInstances(
    AdminModels::FGetTaskInstancesRequest& request,
    const FGetTaskInstancesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetTaskInstances"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetTaskInstancesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetTaskInstancesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetTaskInstancesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetTaskInstancesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetTasks(
    AdminModels::FGetTasksRequest& request,
    const FGetTasksDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetTasks"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetTasksResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetTasksResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetTasksDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetTasksResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetTitleData(
    AdminModels::FGetTitleDataRequest& request,
    const FGetTitleDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetTitleData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetTitleDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetTitleDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetTitleDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetTitleDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetTitleInternalData(
    AdminModels::FGetTitleDataRequest& request,
    const FGetTitleInternalDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetTitleInternalData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetTitleInternalDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetTitleInternalDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetTitleInternalDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetTitleDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserAccountInfo(
    AdminModels::FLookupUserAccountInfoRequest& request,
    const FGetUserAccountInfoDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserAccountInfo"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserAccountInfoResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserAccountInfoResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserAccountInfoDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FLookupUserAccountInfoResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserBans(
    AdminModels::FGetUserBansRequest& request,
    const FGetUserBansDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserBans"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserBansResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserBansResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserBansDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserBansResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserData(
    AdminModels::FGetUserDataRequest& request,
    const FGetUserDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserInternalData(
    AdminModels::FGetUserDataRequest& request,
    const FGetUserInternalDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserInternalData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserInternalDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserInternalDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserInternalDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserInventory(
    AdminModels::FGetUserInventoryRequest& request,
    const FGetUserInventoryDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserInventory"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserInventoryResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserInventoryResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserInventoryDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserInventoryResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserPublisherData(
    AdminModels::FGetUserDataRequest& request,
    const FGetUserPublisherDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserPublisherData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserPublisherDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserPublisherDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserPublisherDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserPublisherInternalData(
    AdminModels::FGetUserDataRequest& request,
    const FGetUserPublisherInternalDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserPublisherInternalData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserPublisherInternalDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserPublisherInternalDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserPublisherInternalDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserPublisherReadOnlyData(
    AdminModels::FGetUserDataRequest& request,
    const FGetUserPublisherReadOnlyDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserPublisherReadOnlyData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserPublisherReadOnlyDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserPublisherReadOnlyDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserPublisherReadOnlyDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GetUserReadOnlyData(
    AdminModels::FGetUserDataRequest& request,
    const FGetUserReadOnlyDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GetUserReadOnlyData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGetUserReadOnlyDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGetUserReadOnlyDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGetUserReadOnlyDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGetUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::GrantItemsToUsers(
    AdminModels::FGrantItemsToUsersRequest& request,
    const FGrantItemsToUsersDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/GrantItemsToUsers"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnGrantItemsToUsersResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnGrantItemsToUsersResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FGrantItemsToUsersDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FGrantItemsToUsersResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::IncrementLimitedEditionItemAvailability(
    AdminModels::FIncrementLimitedEditionItemAvailabilityRequest& request,
    const FIncrementLimitedEditionItemAvailabilityDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/IncrementLimitedEditionItemAvailability"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnIncrementLimitedEditionItemAvailabilityResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnIncrementLimitedEditionItemAvailabilityResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIncrementLimitedEditionItemAvailabilityDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FIncrementLimitedEditionItemAvailabilityResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::IncrementPlayerStatisticVersion(
    AdminModels::FIncrementPlayerStatisticVersionRequest& request,
    const FIncrementPlayerStatisticVersionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/IncrementPlayerStatisticVersion"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnIncrementPlayerStatisticVersionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnIncrementPlayerStatisticVersionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FIncrementPlayerStatisticVersionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FIncrementPlayerStatisticVersionResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ListOpenIdConnection(
    const FListOpenIdConnectionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FListOpenIdConnectionRequest emptyRequest = AdminModels::FListOpenIdConnectionRequest();
    return UPlayFabAdminInstanceAPI::ListOpenIdConnection(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::ListOpenIdConnection(
    AdminModels::FListOpenIdConnectionRequest& request,
    const FListOpenIdConnectionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ListOpenIdConnection"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnListOpenIdConnectionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnListOpenIdConnectionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FListOpenIdConnectionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FListOpenIdConnectionResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ListServerBuilds(
    const FListServerBuildsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FListBuildsRequest emptyRequest = AdminModels::FListBuildsRequest();
    return UPlayFabAdminInstanceAPI::ListServerBuilds(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::ListServerBuilds(
    AdminModels::FListBuildsRequest& request,
    const FListServerBuildsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ListServerBuilds"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnListServerBuildsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnListServerBuildsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FListServerBuildsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FListBuildsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ListVirtualCurrencyTypes(
    const FListVirtualCurrencyTypesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{ 
    AdminModels::FListVirtualCurrencyTypesRequest emptyRequest = AdminModels::FListVirtualCurrencyTypesRequest();
    return UPlayFabAdminInstanceAPI::ListVirtualCurrencyTypes(emptyRequest, SuccessDelegate, ErrorDelegate);
}

bool UPlayFabAdminInstanceAPI::ListVirtualCurrencyTypes(
    AdminModels::FListVirtualCurrencyTypesRequest& request,
    const FListVirtualCurrencyTypesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ListVirtualCurrencyTypes"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnListVirtualCurrencyTypesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnListVirtualCurrencyTypesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FListVirtualCurrencyTypesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FListVirtualCurrencyTypesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ModifyMatchmakerGameModes(
    AdminModels::FModifyMatchmakerGameModesRequest& request,
    const FModifyMatchmakerGameModesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ModifyMatchmakerGameModes"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnModifyMatchmakerGameModesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnModifyMatchmakerGameModesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FModifyMatchmakerGameModesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FModifyMatchmakerGameModesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ModifyServerBuild(
    AdminModels::FModifyServerBuildRequest& request,
    const FModifyServerBuildDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ModifyServerBuild"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnModifyServerBuildResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnModifyServerBuildResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FModifyServerBuildDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FModifyServerBuildResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RefundPurchase(
    AdminModels::FRefundPurchaseRequest& request,
    const FRefundPurchaseDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RefundPurchase"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRefundPurchaseResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRefundPurchaseResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRefundPurchaseDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRefundPurchaseResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RemovePlayerTag(
    AdminModels::FRemovePlayerTagRequest& request,
    const FRemovePlayerTagDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RemovePlayerTag"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRemovePlayerTagResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRemovePlayerTagResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRemovePlayerTagDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRemovePlayerTagResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RemoveServerBuild(
    AdminModels::FRemoveServerBuildRequest& request,
    const FRemoveServerBuildDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RemoveServerBuild"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRemoveServerBuildResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRemoveServerBuildResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRemoveServerBuildDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRemoveServerBuildResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RemoveVirtualCurrencyTypes(
    AdminModels::FRemoveVirtualCurrencyTypesRequest& request,
    const FRemoveVirtualCurrencyTypesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RemoveVirtualCurrencyTypes"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRemoveVirtualCurrencyTypesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRemoveVirtualCurrencyTypesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRemoveVirtualCurrencyTypesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FBlankResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ResetCharacterStatistics(
    AdminModels::FResetCharacterStatisticsRequest& request,
    const FResetCharacterStatisticsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ResetCharacterStatistics"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnResetCharacterStatisticsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnResetCharacterStatisticsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FResetCharacterStatisticsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FResetCharacterStatisticsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ResetPassword(
    AdminModels::FResetPasswordRequest& request,
    const FResetPasswordDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ResetPassword"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnResetPasswordResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnResetPasswordResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FResetPasswordDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FResetPasswordResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ResetUserStatistics(
    AdminModels::FResetUserStatisticsRequest& request,
    const FResetUserStatisticsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ResetUserStatistics"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnResetUserStatisticsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnResetUserStatisticsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FResetUserStatisticsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FResetUserStatisticsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::ResolvePurchaseDispute(
    AdminModels::FResolvePurchaseDisputeRequest& request,
    const FResolvePurchaseDisputeDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/ResolvePurchaseDispute"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnResolvePurchaseDisputeResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnResolvePurchaseDisputeResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FResolvePurchaseDisputeDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FResolvePurchaseDisputeResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RevokeAllBansForUser(
    AdminModels::FRevokeAllBansForUserRequest& request,
    const FRevokeAllBansForUserDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RevokeAllBansForUser"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRevokeAllBansForUserResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRevokeAllBansForUserResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRevokeAllBansForUserDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRevokeAllBansForUserResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RevokeBans(
    AdminModels::FRevokeBansRequest& request,
    const FRevokeBansDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RevokeBans"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRevokeBansResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRevokeBansResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRevokeBansDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRevokeBansResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RevokeInventoryItem(
    AdminModels::FRevokeInventoryItemRequest& request,
    const FRevokeInventoryItemDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RevokeInventoryItem"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRevokeInventoryItemResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRevokeInventoryItemResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRevokeInventoryItemDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRevokeInventoryResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RevokeInventoryItems(
    AdminModels::FRevokeInventoryItemsRequest& request,
    const FRevokeInventoryItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RevokeInventoryItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRevokeInventoryItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRevokeInventoryItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRevokeInventoryItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRevokeInventoryItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::RunTask(
    AdminModels::FRunTaskRequest& request,
    const FRunTaskDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/RunTask"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnRunTaskResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnRunTaskResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FRunTaskDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FRunTaskResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SendAccountRecoveryEmail(
    AdminModels::FSendAccountRecoveryEmailRequest& request,
    const FSendAccountRecoveryEmailDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SendAccountRecoveryEmail"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSendAccountRecoveryEmailResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSendAccountRecoveryEmailResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSendAccountRecoveryEmailDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSendAccountRecoveryEmailResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetCatalogItems(
    AdminModels::FUpdateCatalogItemsRequest& request,
    const FSetCatalogItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetCatalogItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetCatalogItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetCatalogItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetCatalogItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateCatalogItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetPlayerSecret(
    AdminModels::FSetPlayerSecretRequest& request,
    const FSetPlayerSecretDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetPlayerSecret"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetPlayerSecretResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetPlayerSecretResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetPlayerSecretDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetPlayerSecretResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetPublishedRevision(
    AdminModels::FSetPublishedRevisionRequest& request,
    const FSetPublishedRevisionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetPublishedRevision"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetPublishedRevisionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetPublishedRevisionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetPublishedRevisionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetPublishedRevisionResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetPublisherData(
    AdminModels::FSetPublisherDataRequest& request,
    const FSetPublisherDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetPublisherData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetPublisherDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetPublisherDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetPublisherDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetPublisherDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetStoreItems(
    AdminModels::FUpdateStoreItemsRequest& request,
    const FSetStoreItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetStoreItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetStoreItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetStoreItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetStoreItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateStoreItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetTitleData(
    AdminModels::FSetTitleDataRequest& request,
    const FSetTitleDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetTitleData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetTitleDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetTitleDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetTitleDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetTitleDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetTitleDataAndOverrides(
    AdminModels::FSetTitleDataAndOverridesRequest& request,
    const FSetTitleDataAndOverridesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetTitleDataAndOverrides"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetTitleDataAndOverridesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetTitleDataAndOverridesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetTitleDataAndOverridesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetTitleDataAndOverridesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetTitleInternalData(
    AdminModels::FSetTitleDataRequest& request,
    const FSetTitleInternalDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetTitleInternalData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetTitleInternalDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetTitleInternalDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetTitleInternalDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetTitleDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SetupPushNotification(
    AdminModels::FSetupPushNotificationRequest& request,
    const FSetupPushNotificationDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SetupPushNotification"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSetupPushNotificationResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSetupPushNotificationResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSetupPushNotificationDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FSetupPushNotificationResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::SubtractUserVirtualCurrency(
    AdminModels::FSubtractUserVirtualCurrencyRequest& request,
    const FSubtractUserVirtualCurrencyDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/SubtractUserVirtualCurrency"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnSubtractUserVirtualCurrencyResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnSubtractUserVirtualCurrencyResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FSubtractUserVirtualCurrencyDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FModifyUserVirtualCurrencyResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateBans(
    AdminModels::FUpdateBansRequest& request,
    const FUpdateBansDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateBans"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateBansResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateBansResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateBansDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateBansResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateCatalogItems(
    AdminModels::FUpdateCatalogItemsRequest& request,
    const FUpdateCatalogItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateCatalogItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateCatalogItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateCatalogItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateCatalogItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateCatalogItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateCloudScript(
    AdminModels::FUpdateCloudScriptRequest& request,
    const FUpdateCloudScriptDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateCloudScript"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateCloudScriptResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateCloudScriptResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateCloudScriptDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateCloudScriptResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateOpenIdConnection(
    AdminModels::FUpdateOpenIdConnectionRequest& request,
    const FUpdateOpenIdConnectionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateOpenIdConnection"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateOpenIdConnectionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateOpenIdConnectionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateOpenIdConnectionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FEmptyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdatePlayerSharedSecret(
    AdminModels::FUpdatePlayerSharedSecretRequest& request,
    const FUpdatePlayerSharedSecretDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdatePlayerSharedSecret"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdatePlayerSharedSecretResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdatePlayerSharedSecretResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdatePlayerSharedSecretDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdatePlayerSharedSecretResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdatePlayerStatisticDefinition(
    AdminModels::FUpdatePlayerStatisticDefinitionRequest& request,
    const FUpdatePlayerStatisticDefinitionDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdatePlayerStatisticDefinition"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdatePlayerStatisticDefinitionResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdatePlayerStatisticDefinitionResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdatePlayerStatisticDefinitionDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdatePlayerStatisticDefinitionResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdatePolicy(
    AdminModels::FUpdatePolicyRequest& request,
    const FUpdatePolicyDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdatePolicy"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdatePolicyResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdatePolicyResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdatePolicyDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdatePolicyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateRandomResultTables(
    AdminModels::FUpdateRandomResultTablesRequest& request,
    const FUpdateRandomResultTablesDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateRandomResultTables"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateRandomResultTablesResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateRandomResultTablesResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateRandomResultTablesDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateRandomResultTablesResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateSegment(
    AdminModels::FUpdateSegmentRequest& request,
    const FUpdateSegmentDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateSegment"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateSegmentResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateSegmentResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateSegmentDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateSegmentResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateStoreItems(
    AdminModels::FUpdateStoreItemsRequest& request,
    const FUpdateStoreItemsDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateStoreItems"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateStoreItemsResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateStoreItemsResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateStoreItemsDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateStoreItemsResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateTask(
    AdminModels::FUpdateTaskRequest& request,
    const FUpdateTaskDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateTask"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateTaskResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateTaskResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateTaskDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FEmptyResponse outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserData(
    AdminModels::FUpdateUserDataRequest& request,
    const FUpdateUserDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserInternalData(
    AdminModels::FUpdateUserInternalDataRequest& request,
    const FUpdateUserInternalDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserInternalData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserInternalDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserInternalDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserInternalDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserPublisherData(
    AdminModels::FUpdateUserDataRequest& request,
    const FUpdateUserPublisherDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserPublisherData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserPublisherDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserPublisherDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserPublisherDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserPublisherInternalData(
    AdminModels::FUpdateUserInternalDataRequest& request,
    const FUpdateUserPublisherInternalDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserPublisherInternalData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserPublisherInternalDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserPublisherInternalDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserPublisherInternalDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserPublisherReadOnlyData(
    AdminModels::FUpdateUserDataRequest& request,
    const FUpdateUserPublisherReadOnlyDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserPublisherReadOnlyData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserPublisherReadOnlyDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserPublisherReadOnlyDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserPublisherReadOnlyDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserReadOnlyData(
    AdminModels::FUpdateUserDataRequest& request,
    const FUpdateUserReadOnlyDataDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserReadOnlyData"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserReadOnlyDataResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserReadOnlyDataResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserReadOnlyDataDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserDataResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}

bool UPlayFabAdminInstanceAPI::UpdateUserTitleDisplayName(
    AdminModels::FUpdateUserTitleDisplayNameRequest& request,
    const FUpdateUserTitleDisplayNameDelegate& SuccessDelegate,
    const FPlayFabErrorDelegate& ErrorDelegate)
{
    TSharedPtr<UPlayFabAuthenticationContext> context = request.AuthenticationContext.IsValid() ? request.AuthenticationContext : GetOrCreateAuthenticationContext();
    if(context->GetDeveloperSecretKey().Len() == 0) {
        UE_LOG(LogPlayFabCpp, Error, TEXT("You must first set your PlayFab developerSecretKey to use this function (Unreal Settings Menu, or in C++ code)"));
    }


    auto HttpRequest = PlayFabRequestHandler::SendRequest(this->settings, TEXT("/Admin/UpdateUserTitleDisplayName"), request.toJSONString(), TEXT("X-SecretKey"), context->GetDeveloperSecretKey());
    HttpRequest->OnProcessRequestComplete().BindRaw(this, &UPlayFabAdminInstanceAPI::OnUpdateUserTitleDisplayNameResult, SuccessDelegate, ErrorDelegate);
    return HttpRequest->ProcessRequest();
}

void UPlayFabAdminInstanceAPI::OnUpdateUserTitleDisplayNameResult(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FUpdateUserTitleDisplayNameDelegate SuccessDelegate, FPlayFabErrorDelegate ErrorDelegate)
{
    AdminModels::FUpdateUserTitleDisplayNameResult outResult;
    FPlayFabCppError errorResult;
    if (PlayFabRequestHandler::DecodeRequest(HttpRequest, HttpResponse, bSucceeded, outResult, errorResult))
    {
        SuccessDelegate.ExecuteIfBound(outResult);
    }
    else
    {
        ErrorDelegate.ExecuteIfBound(errorResult);
    }
}
