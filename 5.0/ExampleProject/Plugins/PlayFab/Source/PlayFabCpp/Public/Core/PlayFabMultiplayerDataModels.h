//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "PlayFabCppBaseModel.h"

namespace PlayFab
{
namespace MultiplayerModels
{

    enum AccessPolicy
    {
        AccessPolicyPublic,
        AccessPolicyFriends,
        AccessPolicyPrivate
    };

    PLAYFABCPP_API void writeAccessPolicyEnumJSON(AccessPolicy enumVal, JsonWriter& writer);
    PLAYFABCPP_API AccessPolicy readAccessPolicyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AccessPolicy readAccessPolicyFromValue(const FString& value);

    struct PLAYFABCPP_API FAssetReference : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The asset's file name. This is a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        // [optional] The asset's mount path.
        FString MountPath;

        FAssetReference() :
            FPlayFabCppBaseModel(),
            FileName(),
            MountPath()
            {}

        FAssetReference(const FAssetReference& src) = default;

        FAssetReference(const TSharedPtr<FJsonObject>& obj) : FAssetReference()
        {
            readFromValue(obj);
        }

        ~FAssetReference();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAssetReferenceParams : public PlayFab::FPlayFabCppBaseModel
    {
        // The asset's file name.
        FString FileName;

        // [optional] The asset's mount path.
        FString MountPath;

        FAssetReferenceParams() :
            FPlayFabCppBaseModel(),
            FileName(),
            MountPath()
            {}

        FAssetReferenceParams(const FAssetReferenceParams& src) = default;

        FAssetReferenceParams(const TSharedPtr<FJsonObject>& obj) : FAssetReferenceParams()
        {
            readFromValue(obj);
        }

        ~FAssetReferenceParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FAssetSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The asset's file name. This is a filename with the .zip, .tar, or .tar.gz extension.
        FString FileName;

        // [optional] The metadata associated with the asset.
        TMap<FString, FString> Metadata;
        FAssetSummary() :
            FPlayFabCppBaseModel(),
            FileName(),
            Metadata()
            {}

        FAssetSummary(const FAssetSummary& src) = default;

        FAssetSummary(const TSharedPtr<FJsonObject>& obj) : FAssetSummary()
        {
            readFromValue(obj);
        }

        ~FAssetSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum AzureRegion
    {
        AzureRegionAustraliaEast,
        AzureRegionAustraliaSoutheast,
        AzureRegionBrazilSouth,
        AzureRegionCentralUs,
        AzureRegionEastAsia,
        AzureRegionEastUs,
        AzureRegionEastUs2,
        AzureRegionJapanEast,
        AzureRegionJapanWest,
        AzureRegionNorthCentralUs,
        AzureRegionNorthEurope,
        AzureRegionSouthCentralUs,
        AzureRegionSoutheastAsia,
        AzureRegionWestEurope,
        AzureRegionWestUs,
        AzureRegionSouthAfricaNorth,
        AzureRegionWestCentralUs,
        AzureRegionKoreaCentral,
        AzureRegionFranceCentral,
        AzureRegionWestUs2,
        AzureRegionCentralIndia,
        AzureRegionUaeNorth,
        AzureRegionUkSouth,
        AzureRegionSwedenCentral
    };

    PLAYFABCPP_API void writeAzureRegionEnumJSON(AzureRegion enumVal, JsonWriter& writer);
    PLAYFABCPP_API AzureRegion readAzureRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AzureRegion readAzureRegionFromValue(const FString& value);

    enum AzureVmFamily
    {
        AzureVmFamilyA,
        AzureVmFamilyAv2,
        AzureVmFamilyDv2,
        AzureVmFamilyDv3,
        AzureVmFamilyF,
        AzureVmFamilyFsv2,
        AzureVmFamilyDasv4,
        AzureVmFamilyDav4,
        AzureVmFamilyDadsv5,
        AzureVmFamilyEav4,
        AzureVmFamilyEasv4,
        AzureVmFamilyEv4,
        AzureVmFamilyEsv4,
        AzureVmFamilyDsv3,
        AzureVmFamilyDsv2,
        AzureVmFamilyNCasT4_v3,
        AzureVmFamilyDdv4,
        AzureVmFamilyDdsv4,
        AzureVmFamilyHBv3
    };

    PLAYFABCPP_API void writeAzureVmFamilyEnumJSON(AzureVmFamily enumVal, JsonWriter& writer);
    PLAYFABCPP_API AzureVmFamily readAzureVmFamilyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AzureVmFamily readAzureVmFamilyFromValue(const FString& value);

    enum AzureVmSize
    {
        AzureVmSizeStandard_A1,
        AzureVmSizeStandard_A2,
        AzureVmSizeStandard_A3,
        AzureVmSizeStandard_A4,
        AzureVmSizeStandard_A1_v2,
        AzureVmSizeStandard_A2_v2,
        AzureVmSizeStandard_A4_v2,
        AzureVmSizeStandard_A8_v2,
        AzureVmSizeStandard_D1_v2,
        AzureVmSizeStandard_D2_v2,
        AzureVmSizeStandard_D3_v2,
        AzureVmSizeStandard_D4_v2,
        AzureVmSizeStandard_D5_v2,
        AzureVmSizeStandard_D2_v3,
        AzureVmSizeStandard_D4_v3,
        AzureVmSizeStandard_D8_v3,
        AzureVmSizeStandard_D16_v3,
        AzureVmSizeStandard_F1,
        AzureVmSizeStandard_F2,
        AzureVmSizeStandard_F4,
        AzureVmSizeStandard_F8,
        AzureVmSizeStandard_F16,
        AzureVmSizeStandard_F2s_v2,
        AzureVmSizeStandard_F4s_v2,
        AzureVmSizeStandard_F8s_v2,
        AzureVmSizeStandard_F16s_v2,
        AzureVmSizeStandard_D2as_v4,
        AzureVmSizeStandard_D4as_v4,
        AzureVmSizeStandard_D8as_v4,
        AzureVmSizeStandard_D16as_v4,
        AzureVmSizeStandard_D2a_v4,
        AzureVmSizeStandard_D4a_v4,
        AzureVmSizeStandard_D8a_v4,
        AzureVmSizeStandard_D16a_v4,
        AzureVmSizeStandard_D2ads_v5,
        AzureVmSizeStandard_D4ads_v5,
        AzureVmSizeStandard_D8ads_v5,
        AzureVmSizeStandard_D16ads_v5,
        AzureVmSizeStandard_E2a_v4,
        AzureVmSizeStandard_E4a_v4,
        AzureVmSizeStandard_E8a_v4,
        AzureVmSizeStandard_E16a_v4,
        AzureVmSizeStandard_E2as_v4,
        AzureVmSizeStandard_E4as_v4,
        AzureVmSizeStandard_E8as_v4,
        AzureVmSizeStandard_E16as_v4,
        AzureVmSizeStandard_D2s_v3,
        AzureVmSizeStandard_D4s_v3,
        AzureVmSizeStandard_D8s_v3,
        AzureVmSizeStandard_D16s_v3,
        AzureVmSizeStandard_DS1_v2,
        AzureVmSizeStandard_DS2_v2,
        AzureVmSizeStandard_DS3_v2,
        AzureVmSizeStandard_DS4_v2,
        AzureVmSizeStandard_DS5_v2,
        AzureVmSizeStandard_NC4as_T4_v3,
        AzureVmSizeStandard_D2d_v4,
        AzureVmSizeStandard_D4d_v4,
        AzureVmSizeStandard_D8d_v4,
        AzureVmSizeStandard_D16d_v4,
        AzureVmSizeStandard_D2ds_v4,
        AzureVmSizeStandard_D4ds_v4,
        AzureVmSizeStandard_D8ds_v4,
        AzureVmSizeStandard_D16ds_v4,
        AzureVmSizeStandard_HB120_16rs_v3,
        AzureVmSizeStandard_HB120_32rs_v3,
        AzureVmSizeStandard_HB120_64rs_v3,
        AzureVmSizeStandard_HB120_96rs_v3,
        AzureVmSizeStandard_HB120rs_v3
    };

    PLAYFABCPP_API void writeAzureVmSizeEnumJSON(AzureVmSize enumVal, JsonWriter& writer);
    PLAYFABCPP_API AzureVmSize readAzureVmSizeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API AzureVmSize readAzureVmSizeFromValue(const FString& value);

    struct PLAYFABCPP_API FBuildSelectionCriterion : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Dictionary of build ids and their respective weights for distribution of allocation requests.
        TMap<FString, uint32> BuildWeightDistribution;
        FBuildSelectionCriterion() :
            FPlayFabCppBaseModel(),
            BuildWeightDistribution()
            {}

        FBuildSelectionCriterion(const FBuildSelectionCriterion& src) = default;

        FBuildSelectionCriterion(const TSharedPtr<FJsonObject>& obj) : FBuildSelectionCriterion()
        {
            readFromValue(obj);
        }

        ~FBuildSelectionCriterion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildAliasDetailsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The guid string alias Id of the alias to be created or updated.
        FString AliasId;

        // [optional] The alias name.
        FString AliasName;

        // [optional] Array of build selection criteria.
        TArray<FBuildSelectionCriterion> BuildSelectionCriteria;
        FBuildAliasDetailsResponse() :
            FPlayFabCppResultCommon(),
            AliasId(),
            AliasName(),
            BuildSelectionCriteria()
            {}

        FBuildAliasDetailsResponse(const FBuildAliasDetailsResponse& src) = default;

        FBuildAliasDetailsResponse(const TSharedPtr<FJsonObject>& obj) : FBuildAliasDetailsResponse()
        {
            readFromValue(obj);
        }

        ~FBuildAliasDetailsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildAliasParams : public PlayFab::FPlayFabCppBaseModel
    {
        // The guid string alias ID to use for the request.
        FString AliasId;

        FBuildAliasParams() :
            FPlayFabCppBaseModel(),
            AliasId()
            {}

        FBuildAliasParams(const FBuildAliasParams& src) = default;

        FBuildAliasParams(const TSharedPtr<FJsonObject>& obj) : FBuildAliasParams()
        {
            readFromValue(obj);
        }

        ~FBuildAliasParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCurrentServerStats : public PlayFab::FPlayFabCppBaseModel
    {
        // The number of active multiplayer servers.
        int32 Active;

        // The number of multiplayer servers still downloading game resources (such as assets).
        int32 Propping;

        // The number of standingby multiplayer servers.
        int32 StandingBy;

        // The total number of multiplayer servers.
        int32 Total;

        FCurrentServerStats() :
            FPlayFabCppBaseModel(),
            Active(0),
            Propping(0),
            StandingBy(0),
            Total(0)
            {}

        FCurrentServerStats(const FCurrentServerStats& src) = default;

        FCurrentServerStats(const TSharedPtr<FJsonObject>& obj) : FCurrentServerStats()
        {
            readFromValue(obj);
        }

        ~FCurrentServerStats();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDynamicStandbyThreshold : public PlayFab::FPlayFabCppBaseModel
    {
        // When the trigger threshold is reached, multiply by this value
        double Multiplier;

        // The multiplier will be applied when the actual standby divided by target standby floor is less than this value
        double TriggerThresholdPercentage;

        FDynamicStandbyThreshold() :
            FPlayFabCppBaseModel(),
            Multiplier(0),
            TriggerThresholdPercentage(0)
            {}

        FDynamicStandbyThreshold(const FDynamicStandbyThreshold& src) = default;

        FDynamicStandbyThreshold(const TSharedPtr<FJsonObject>& obj) : FDynamicStandbyThreshold()
        {
            readFromValue(obj);
        }

        ~FDynamicStandbyThreshold();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDynamicStandbySettings : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] List of auto standing by trigger values and corresponding standing by multiplier. Defaults to 1.5X at 50%, 3X at 25%,
         * and 4X at 5%
         */
        TArray<FDynamicStandbyThreshold> DynamicFloorMultiplierThresholds;
        // When true, dynamic standby will be enabled
        bool IsEnabled;

        // [optional] The time it takes to reduce target standing by to configured floor value after an increase. Defaults to 30 minutes
        Boxed<int32> RampDownSeconds;

        FDynamicStandbySettings() :
            FPlayFabCppBaseModel(),
            DynamicFloorMultiplierThresholds(),
            IsEnabled(false),
            RampDownSeconds()
            {}

        FDynamicStandbySettings(const FDynamicStandbySettings& src) = default;

        FDynamicStandbySettings(const TSharedPtr<FJsonObject>& obj) : FDynamicStandbySettings()
        {
            readFromValue(obj);
        }

        ~FDynamicStandbySettings();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSchedule : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] A short description about this schedule. For example, "Game launch on July 15th".
        FString Description;

        /**
         * The date and time in UTC at which the schedule ends. If IsRecurringWeekly is true, this schedule will keep renewing for
         * future weeks until disabled or removed.
         */
        FDateTime EndTime;

        // Disables the schedule.
        bool IsDisabled;

        // If true, the StartTime and EndTime will get renewed every week.
        bool IsRecurringWeekly;

        // The date and time in UTC at which the schedule starts.
        FDateTime StartTime;

        // The standby target to maintain for the duration of the schedule.
        int32 TargetStandby;

        FSchedule() :
            FPlayFabCppBaseModel(),
            Description(),
            EndTime(0),
            IsDisabled(false),
            IsRecurringWeekly(false),
            StartTime(0),
            TargetStandby(0)
            {}

        FSchedule(const FSchedule& src) = default;

        FSchedule(const TSharedPtr<FJsonObject>& obj) : FSchedule()
        {
            readFromValue(obj);
        }

        ~FSchedule();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FScheduledStandbySettings : public PlayFab::FPlayFabCppBaseModel
    {
        // When true, scheduled standby will be enabled
        bool IsEnabled;

        // [optional] A list of non-overlapping schedules
        TArray<FSchedule> ScheduleList;
        FScheduledStandbySettings() :
            FPlayFabCppBaseModel(),
            IsEnabled(false),
            ScheduleList()
            {}

        FScheduledStandbySettings(const FScheduledStandbySettings& src) = default;

        FScheduledStandbySettings(const TSharedPtr<FJsonObject>& obj) : FScheduledStandbySettings()
        {
            readFromValue(obj);
        }

        ~FScheduledStandbySettings();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildRegion : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The current multiplayer server stats for the region.
        TSharedPtr<FCurrentServerStats> pfCurrentServerStats;

        // [optional] Optional settings to control dynamic adjustment of standby target
        TSharedPtr<FDynamicStandbySettings> pfDynamicStandbySettings;

        // Whether the game assets provided for the build have been replicated to this region.
        bool IsAssetReplicationComplete;

        // The maximum number of multiplayer servers for the region.
        int32 MaxServers;

        // [optional] Regional override for the number of multiplayer servers to host on a single VM of the build.
        Boxed<int32> MultiplayerServerCountPerVm;

        // [optional] The build region.
        FString Region;

        // [optional] Optional settings to set the standby target to specified values during the supplied schedules
        TSharedPtr<FScheduledStandbySettings> pfScheduledStandbySettings;

        // The target number of standby multiplayer servers for the region.
        int32 StandbyServers;

        /**
         * [optional] The status of multiplayer servers in the build region. Valid values are - Unknown, Initialized, Deploying, Deployed,
         * Unhealthy, Deleting, Deleted.
         */
        FString Status;

        // [optional] Regional override for the VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        FBuildRegion() :
            FPlayFabCppBaseModel(),
            pfCurrentServerStats(nullptr),
            pfDynamicStandbySettings(nullptr),
            IsAssetReplicationComplete(false),
            MaxServers(0),
            MultiplayerServerCountPerVm(),
            Region(),
            pfScheduledStandbySettings(nullptr),
            StandbyServers(0),
            Status(),
            VmSize()
            {}

        FBuildRegion(const FBuildRegion& src) = default;

        FBuildRegion(const TSharedPtr<FJsonObject>& obj) : FBuildRegion()
        {
            readFromValue(obj);
        }

        ~FBuildRegion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildRegionParams : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Optional settings to control dynamic adjustment of standby target. If not specified, dynamic standby is disabled
        TSharedPtr<FDynamicStandbySettings> pfDynamicStandbySettings;

        // The maximum number of multiplayer servers for the region.
        int32 MaxServers;

        // [optional] Regional override for the number of multiplayer servers to host on a single VM of the build.
        Boxed<int32> MultiplayerServerCountPerVm;

        // The build region.
        FString Region;

        // [optional] Optional settings to set the standby target to specified values during the supplied schedules
        TSharedPtr<FScheduledStandbySettings> pfScheduledStandbySettings;

        // The number of standby multiplayer servers for the region.
        int32 StandbyServers;

        // [optional] Regional override for the VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        FBuildRegionParams() :
            FPlayFabCppBaseModel(),
            pfDynamicStandbySettings(nullptr),
            MaxServers(0),
            MultiplayerServerCountPerVm(),
            Region(),
            pfScheduledStandbySettings(nullptr),
            StandbyServers(0),
            VmSize()
            {}

        FBuildRegionParams(const FBuildRegionParams& src) = default;

        FBuildRegionParams(const TSharedPtr<FJsonObject>& obj) : FBuildRegionParams()
        {
            readFromValue(obj);
        }

        ~FBuildRegionParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FBuildSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The guid string build ID of the build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // [optional] The configuration and status for each region in the build.
        TArray<FBuildRegion> RegionConfigurations;
        FBuildSummary() :
            FPlayFabCppBaseModel(),
            BuildId(),
            BuildName(),
            CreationTime(),
            Metadata(),
            RegionConfigurations()
            {}

        FBuildSummary(const FBuildSummary& src) = default;

        FBuildSummary(const TSharedPtr<FJsonObject>& obj) : FBuildSummary()
        {
            readFromValue(obj);
        }

        ~FBuildSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FEntityKey : public PlayFab::FPlayFabCppBaseModel
    {
        // Unique ID of the entity.
        FString Id;

        // [optional] Entity type. See https://docs.microsoft.com/gaming/playfab/features/data/entities/available-built-in-entity-types
        FString Type;

        FEntityKey() :
            FPlayFabCppBaseModel(),
            Id(),
            Type()
            {}

        FEntityKey(const FEntityKey& src) = default;

        FEntityKey(const TSharedPtr<FJsonObject>& obj) : FEntityKey()
        {
            readFromValue(obj);
        }

        ~FEntityKey();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelAllMatchmakingTicketsForPlayerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The entity key of the player whose tickets should be canceled.
        TSharedPtr<FEntityKey> Entity;

        // The name of the queue from which a player's tickets should be canceled.
        FString QueueName;

        FCancelAllMatchmakingTicketsForPlayerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Entity(nullptr),
            QueueName()
            {}

        FCancelAllMatchmakingTicketsForPlayerRequest(const FCancelAllMatchmakingTicketsForPlayerRequest& src) = default;

        FCancelAllMatchmakingTicketsForPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FCancelAllMatchmakingTicketsForPlayerRequest()
        {
            readFromValue(obj);
        }

        ~FCancelAllMatchmakingTicketsForPlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelAllMatchmakingTicketsForPlayerResult : public PlayFab::FPlayFabCppResultCommon
    {
        FCancelAllMatchmakingTicketsForPlayerResult() :
            FPlayFabCppResultCommon()
            {}

        FCancelAllMatchmakingTicketsForPlayerResult(const FCancelAllMatchmakingTicketsForPlayerResult& src) = default;

        FCancelAllMatchmakingTicketsForPlayerResult(const TSharedPtr<FJsonObject>& obj) : FCancelAllMatchmakingTicketsForPlayerResult()
        {
            readFromValue(obj);
        }

        ~FCancelAllMatchmakingTicketsForPlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelAllServerBackfillTicketsForPlayerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The entity key of the player whose backfill tickets should be canceled.
        FEntityKey Entity;

        // The name of the queue from which a player's backfill tickets should be canceled.
        FString QueueName;

        FCancelAllServerBackfillTicketsForPlayerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Entity(),
            QueueName()
            {}

        FCancelAllServerBackfillTicketsForPlayerRequest(const FCancelAllServerBackfillTicketsForPlayerRequest& src) = default;

        FCancelAllServerBackfillTicketsForPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FCancelAllServerBackfillTicketsForPlayerRequest()
        {
            readFromValue(obj);
        }

        ~FCancelAllServerBackfillTicketsForPlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelAllServerBackfillTicketsForPlayerResult : public PlayFab::FPlayFabCppResultCommon
    {
        FCancelAllServerBackfillTicketsForPlayerResult() :
            FPlayFabCppResultCommon()
            {}

        FCancelAllServerBackfillTicketsForPlayerResult(const FCancelAllServerBackfillTicketsForPlayerResult& src) = default;

        FCancelAllServerBackfillTicketsForPlayerResult(const TSharedPtr<FJsonObject>& obj) : FCancelAllServerBackfillTicketsForPlayerResult()
        {
            readFromValue(obj);
        }

        ~FCancelAllServerBackfillTicketsForPlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum CancellationReason
    {
        CancellationReasonRequested,
        CancellationReasonInternal,
        CancellationReasonTimeout
    };

    PLAYFABCPP_API void writeCancellationReasonEnumJSON(CancellationReason enumVal, JsonWriter& writer);
    PLAYFABCPP_API CancellationReason readCancellationReasonFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API CancellationReason readCancellationReasonFromValue(const FString& value);

    struct PLAYFABCPP_API FCancelMatchmakingTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The name of the queue the ticket is in.
        FString QueueName;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FCancelMatchmakingTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            QueueName(),
            TicketId()
            {}

        FCancelMatchmakingTicketRequest(const FCancelMatchmakingTicketRequest& src) = default;

        FCancelMatchmakingTicketRequest(const TSharedPtr<FJsonObject>& obj) : FCancelMatchmakingTicketRequest()
        {
            readFromValue(obj);
        }

        ~FCancelMatchmakingTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelMatchmakingTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        FCancelMatchmakingTicketResult() :
            FPlayFabCppResultCommon()
            {}

        FCancelMatchmakingTicketResult(const FCancelMatchmakingTicketResult& src) = default;

        FCancelMatchmakingTicketResult(const TSharedPtr<FJsonObject>& obj) : FCancelMatchmakingTicketResult()
        {
            readFromValue(obj);
        }

        ~FCancelMatchmakingTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelServerBackfillTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The name of the queue the ticket is in.
        FString QueueName;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FCancelServerBackfillTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            QueueName(),
            TicketId()
            {}

        FCancelServerBackfillTicketRequest(const FCancelServerBackfillTicketRequest& src) = default;

        FCancelServerBackfillTicketRequest(const TSharedPtr<FJsonObject>& obj) : FCancelServerBackfillTicketRequest()
        {
            readFromValue(obj);
        }

        ~FCancelServerBackfillTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCancelServerBackfillTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        FCancelServerBackfillTicketResult() :
            FPlayFabCppResultCommon()
            {}

        FCancelServerBackfillTicketResult(const FCancelServerBackfillTicketResult& src) = default;

        FCancelServerBackfillTicketResult(const TSharedPtr<FJsonObject>& obj) : FCancelServerBackfillTicketResult()
        {
            readFromValue(obj);
        }

        ~FCancelServerBackfillTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCertificate : public PlayFab::FPlayFabCppBaseModel
    {
        // Base64 encoded string contents of the certificate.
        FString Base64EncodedValue;

        // A name for the certificate. This is used to reference certificates in build configurations.
        FString Name;

        /**
         * [optional] If required for your PFX certificate, use this field to provide a password that will be used to install the certificate
         * on the container.
         */
        FString Password;

        FCertificate() :
            FPlayFabCppBaseModel(),
            Base64EncodedValue(),
            Name(),
            Password()
            {}

        FCertificate(const FCertificate& src) = default;

        FCertificate(const TSharedPtr<FJsonObject>& obj) : FCertificate()
        {
            readFromValue(obj);
        }

        ~FCertificate();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCertificateSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The name of the certificate.
        FString Name;

        // [optional] The thumbprint for the certificate.
        FString Thumbprint;

        FCertificateSummary() :
            FPlayFabCppBaseModel(),
            Name(),
            Thumbprint()
            {}

        FCertificateSummary(const FCertificateSummary& src) = default;

        FCertificateSummary(const TSharedPtr<FJsonObject>& obj) : FCertificateSummary()
        {
            readFromValue(obj);
        }

        ~FCertificateSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FConnectedPlayer : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The player ID of the player connected to the multiplayer server.
        FString PlayerId;

        FConnectedPlayer() :
            FPlayFabCppBaseModel(),
            PlayerId()
            {}

        FConnectedPlayer(const FConnectedPlayer& src) = default;

        FConnectedPlayer(const TSharedPtr<FJsonObject>& obj) : FConnectedPlayer()
        {
            readFromValue(obj);
        }

        ~FConnectedPlayer();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ContainerFlavor
    {
        ContainerFlavorManagedWindowsServerCore,
        ContainerFlavorCustomLinux,
        ContainerFlavorManagedWindowsServerCorePreview,
        ContainerFlavorInvalid
    };

    PLAYFABCPP_API void writeContainerFlavorEnumJSON(ContainerFlavor enumVal, JsonWriter& writer);
    PLAYFABCPP_API ContainerFlavor readContainerFlavorFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ContainerFlavor readContainerFlavorFromValue(const FString& value);

    struct PLAYFABCPP_API FContainerImageReference : public PlayFab::FPlayFabCppBaseModel
    {
        // The container image name.
        FString ImageName;

        // [optional] The container tag.
        FString Tag;

        FContainerImageReference() :
            FPlayFabCppBaseModel(),
            ImageName(),
            Tag()
            {}

        FContainerImageReference(const FContainerImageReference& src) = default;

        FContainerImageReference(const TSharedPtr<FJsonObject>& obj) : FContainerImageReference()
        {
            readFromValue(obj);
        }

        ~FContainerImageReference();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCoreCapacity : public PlayFab::FPlayFabCppBaseModel
    {
        // The available core capacity for the (Region, VmFamily)
        int32 Available;

        // [optional] The AzureRegion
        FString Region;

        // The total core capacity for the (Region, VmFamily)
        int32 Total;

        // [optional] The AzureVmFamily
        Boxed<AzureVmFamily> VmFamily;

        FCoreCapacity() :
            FPlayFabCppBaseModel(),
            Available(0),
            Region(),
            Total(0),
            VmFamily()
            {}

        FCoreCapacity(const FCoreCapacity& src) = default;

        FCoreCapacity(const TSharedPtr<FJsonObject>& obj) : FCoreCapacity()
        {
            readFromValue(obj);
        }

        ~FCoreCapacity();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCoreCapacityChange : public PlayFab::FPlayFabCppBaseModel
    {
        // New quota core limit for the given vm family/region.
        int32 NewCoreLimit;

        // Region to change.
        FString Region;

        // Virtual machine family to change.
        AzureVmFamily VmFamily;

        FCoreCapacityChange() :
            FPlayFabCppBaseModel(),
            NewCoreLimit(0),
            Region(),
            VmFamily()
            {}

        FCoreCapacityChange(const FCoreCapacityChange& src) = default;

        FCoreCapacityChange(const TSharedPtr<FJsonObject>& obj) : FCoreCapacityChange()
        {
            readFromValue(obj);
        }

        ~FCoreCapacityChange();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildAliasRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The alias name.
        FString AliasName;

        // [optional] Array of build selection criteria.
        TArray<FBuildSelectionCriterion> BuildSelectionCriteria;
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FCreateBuildAliasRequest() :
            FPlayFabCppRequestCommon(),
            AliasName(),
            BuildSelectionCriteria(),
            CustomTags()
            {}

        FCreateBuildAliasRequest(const FCreateBuildAliasRequest& src) = default;

        FCreateBuildAliasRequest(const TSharedPtr<FJsonObject>& obj) : FCreateBuildAliasRequest()
        {
            readFromValue(obj);
        }

        ~FCreateBuildAliasRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGameCertificateReferenceParams : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * An alias for the game certificate. The game server will reference this alias via GSDK config to retrieve the game
         * certificate. This alias is used as an identifier in game server code to allow a new certificate with different Name
         * field to be uploaded without the need to change any game server code to reference the new Name.
         */
        FString GsdkAlias;

        /**
         * The name of the game certificate. This name should match the name of a certificate that was previously uploaded to this
         * title.
         */
        FString Name;

        FGameCertificateReferenceParams() :
            FPlayFabCppBaseModel(),
            GsdkAlias(),
            Name()
            {}

        FGameCertificateReferenceParams(const FGameCertificateReferenceParams& src) = default;

        FGameCertificateReferenceParams(const TSharedPtr<FJsonObject>& obj) : FGameCertificateReferenceParams()
        {
            readFromValue(obj);
        }

        ~FGameCertificateReferenceParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLinuxInstrumentationConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        // Designates whether Linux instrumentation configuration will be enabled for this Build
        bool IsEnabled;

        FLinuxInstrumentationConfiguration() :
            FPlayFabCppBaseModel(),
            IsEnabled(false)
            {}

        FLinuxInstrumentationConfiguration(const FLinuxInstrumentationConfiguration& src) = default;

        FLinuxInstrumentationConfiguration(const TSharedPtr<FJsonObject>& obj) : FLinuxInstrumentationConfiguration()
        {
            readFromValue(obj);
        }

        ~FLinuxInstrumentationConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMonitoringApplicationConfigurationParams : public PlayFab::FPlayFabCppBaseModel
    {
        // Asset which contains the monitoring application files and scripts.
        FAssetReferenceParams AssetReference;

        // Execution script name, this will be the main executable for the monitoring application.
        FString ExecutionScriptName;

        // [optional] Installation script name, this will be run before the ExecutionScript.
        FString InstallationScriptName;

        // [optional] Timespan the monitoring application will be kept alive when running from the start of the VM
        Boxed<double> OnStartRuntimeInMinutes;

        FMonitoringApplicationConfigurationParams() :
            FPlayFabCppBaseModel(),
            AssetReference(),
            ExecutionScriptName(),
            InstallationScriptName(),
            OnStartRuntimeInMinutes()
            {}

        FMonitoringApplicationConfigurationParams(const FMonitoringApplicationConfigurationParams& src) = default;

        FMonitoringApplicationConfigurationParams(const TSharedPtr<FJsonObject>& obj) : FMonitoringApplicationConfigurationParams()
        {
            readFromValue(obj);
        }

        ~FMonitoringApplicationConfigurationParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ProtocolType
    {
        ProtocolTypeTCP,
        ProtocolTypeUDP
    };

    PLAYFABCPP_API void writeProtocolTypeEnumJSON(ProtocolType enumVal, JsonWriter& writer);
    PLAYFABCPP_API ProtocolType readProtocolTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ProtocolType readProtocolTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FPort : public PlayFab::FPlayFabCppBaseModel
    {
        // The name for the port.
        FString Name;

        // The number for the port.
        int32 Num;

        // The protocol for the port.
        ProtocolType Protocol;

        FPort() :
            FPlayFabCppBaseModel(),
            Name(),
            Num(0),
            Protocol()
            {}

        FPort(const FPort& src) = default;

        FPort(const TSharedPtr<FJsonObject>& obj) : FPort()
        {
            readFromValue(obj);
        }

        ~FPort();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FServerResourceConstraintParams : public PlayFab::FPlayFabCppBaseModel
    {
        // The maximum number of cores that each server is allowed to use.
        double CpuLimit;

        /**
         * The maximum number of GiB of memory that each server is allowed to use. WARNING: After exceeding this limit, the server
         * will be killed
         */
        double MemoryLimitGB;

        FServerResourceConstraintParams() :
            FPlayFabCppBaseModel(),
            CpuLimit(0),
            MemoryLimitGB(0)
            {}

        FServerResourceConstraintParams(const FServerResourceConstraintParams& src) = default;

        FServerResourceConstraintParams(const TSharedPtr<FJsonObject>& obj) : FServerResourceConstraintParams()
        {
            readFromValue(obj);
        }

        ~FServerResourceConstraintParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVmStartupScriptPortRequestParams : public PlayFab::FPlayFabCppBaseModel
    {
        // The name for the port.
        FString Name;

        // The protocol for the port.
        ProtocolType Protocol;

        FVmStartupScriptPortRequestParams() :
            FPlayFabCppBaseModel(),
            Name(),
            Protocol()
            {}

        FVmStartupScriptPortRequestParams(const FVmStartupScriptPortRequestParams& src) = default;

        FVmStartupScriptPortRequestParams(const TSharedPtr<FJsonObject>& obj) : FVmStartupScriptPortRequestParams()
        {
            readFromValue(obj);
        }

        ~FVmStartupScriptPortRequestParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVmStartupScriptParams : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Optional port requests (name/protocol) that will be used by the VmStartupScript. Max of 5 requests.
        TArray<FVmStartupScriptPortRequestParams> PortRequests;
        // Asset which contains the VmStartupScript script and any other required files.
        FAssetReferenceParams VmStartupScriptAssetReference;

        FVmStartupScriptParams() :
            FPlayFabCppBaseModel(),
            PortRequests(),
            VmStartupScriptAssetReference()
            {}

        FVmStartupScriptParams(const FVmStartupScriptParams& src) = default;

        FVmStartupScriptParams(const TSharedPtr<FJsonObject>& obj) : FVmStartupScriptParams()
        {
            readFromValue(obj);
        }

        ~FVmStartupScriptParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithCustomContainerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // The build name.
        FString BuildName;

        // [optional] The flavor of container to create a build from.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The container reference, consisting of the image name and tag.
        TSharedPtr<FContainerImageReference> pfContainerImageReference;

        // [optional] The container command to run when the multiplayer server has been allocated, including any arguments.
        FString ContainerRunCommand;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The list of game assets related to the build.
        TArray<FAssetReferenceParams> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReferenceParams> GameCertificateReferences;
        // [optional] The Linux instrumentation configuration for the build.
        TSharedPtr<FLinuxInstrumentationConfiguration> pfLinuxInstrumentationConfiguration;

        /**
         * [optional] Metadata to tag the build. The keys are case insensitive. The build metadata is made available to the server through
         * Game Server SDK (GSDK).Constraints: Maximum number of keys: 30, Maximum key length: 50, Maximum value length: 100
         */
        TMap<FString, FString> Metadata;
        // [optional] The configuration for the monitoring application on the build
        TSharedPtr<FMonitoringApplicationConfigurationParams> MonitoringApplicationConfiguration;

        // The number of multiplayer servers to host on a single VM.
        int32 MultiplayerServerCountPerVm;

        // The ports to map the build on.
        TArray<FPort> Ports;
        // The region configurations for the build.
        TArray<FBuildRegionParams> RegionConfigurations;
        // [optional] The resource constraints to apply to each server on the VM (EXPERIMENTAL API)
        TSharedPtr<FServerResourceConstraintParams> ServerResourceConstraints;

        // [optional] The VM size to create the build on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript for the build
        TSharedPtr<FVmStartupScriptParams> VmStartupScriptConfiguration;

        FCreateBuildWithCustomContainerRequest() :
            FPlayFabCppRequestCommon(),
            AreAssetsReadonly(),
            BuildName(),
            pfContainerFlavor(),
            pfContainerImageReference(nullptr),
            ContainerRunCommand(),
            CustomTags(),
            GameAssetReferences(),
            GameCertificateReferences(),
            pfLinuxInstrumentationConfiguration(nullptr),
            Metadata(),
            MonitoringApplicationConfiguration(nullptr),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            ServerResourceConstraints(nullptr),
            VmSize(),
            VmStartupScriptConfiguration(nullptr)
            {}

        FCreateBuildWithCustomContainerRequest(const FCreateBuildWithCustomContainerRequest& src) = default;

        FCreateBuildWithCustomContainerRequest(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithCustomContainerRequest()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithCustomContainerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGameCertificateReference : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] An alias for the game certificate. The game server will reference this alias via GSDK config to retrieve the game
         * certificate. This alias is used as an identifier in game server code to allow a new certificate with different Name
         * field to be uploaded without the need to change any game server code to reference the new Name.
         */
        FString GsdkAlias;

        /**
         * [optional] The name of the game certificate. This name should match the name of a certificate that was previously uploaded to this
         * title.
         */
        FString Name;

        FGameCertificateReference() :
            FPlayFabCppBaseModel(),
            GsdkAlias(),
            Name()
            {}

        FGameCertificateReference(const FGameCertificateReference& src) = default;

        FGameCertificateReference(const TSharedPtr<FJsonObject>& obj) : FGameCertificateReference()
        {
            readFromValue(obj);
        }

        ~FGameCertificateReference();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMonitoringApplicationConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        // Asset which contains the monitoring application files and scripts.
        FAssetReference pfAssetReference;

        // Execution script name, this will be the main executable for the monitoring application.
        FString ExecutionScriptName;

        // [optional] Installation script name, this will be run before the ExecutionScript.
        FString InstallationScriptName;

        // [optional] Timespan the monitoring application will be kept alive when running from the start of the VM
        Boxed<double> OnStartRuntimeInMinutes;

        FMonitoringApplicationConfiguration() :
            FPlayFabCppBaseModel(),
            pfAssetReference(),
            ExecutionScriptName(),
            InstallationScriptName(),
            OnStartRuntimeInMinutes()
            {}

        FMonitoringApplicationConfiguration(const FMonitoringApplicationConfiguration& src) = default;

        FMonitoringApplicationConfiguration(const TSharedPtr<FJsonObject>& obj) : FMonitoringApplicationConfiguration()
        {
            readFromValue(obj);
        }

        ~FMonitoringApplicationConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVmStartupScriptPortRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // The name for the port.
        FString Name;

        // The protocol for the port.
        ProtocolType Protocol;

        FVmStartupScriptPortRequest() :
            FPlayFabCppBaseModel(),
            Name(),
            Protocol()
            {}

        FVmStartupScriptPortRequest(const FVmStartupScriptPortRequest& src) = default;

        FVmStartupScriptPortRequest(const TSharedPtr<FJsonObject>& obj) : FVmStartupScriptPortRequest()
        {
            readFromValue(obj);
        }

        ~FVmStartupScriptPortRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVmStartupScriptConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Optional port requests (name/protocol) that will be used by the VmStartupScript. Max of 5 requests.
        TArray<FVmStartupScriptPortRequest> PortRequests;
        // Asset which contains the VmStartupScript script and any other required files.
        FAssetReference VmStartupScriptAssetReference;

        FVmStartupScriptConfiguration() :
            FPlayFabCppBaseModel(),
            PortRequests(),
            VmStartupScriptAssetReference()
            {}

        FVmStartupScriptConfiguration(const FVmStartupScriptConfiguration& src) = default;

        FVmStartupScriptConfiguration(const TSharedPtr<FJsonObject>& obj) : FVmStartupScriptConfiguration()
        {
            readFromValue(obj);
        }

        ~FVmStartupScriptConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithCustomContainerResponse : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // [optional] The guid string build ID. Must be unique for every build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The flavor of container of the build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The container command to run when the multiplayer server has been allocated, including any arguments.
        FString ContainerRunCommand;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The custom game container image reference information.
        TSharedPtr<FContainerImageReference> CustomGameContainerImage;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        // [optional] The Linux instrumentation configuration for this build.
        TSharedPtr<FLinuxInstrumentationConfiguration> pfLinuxInstrumentationConfiguration;

        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // [optional] The configuration for the monitoring application for the build
        TSharedPtr<FMonitoringApplicationConfiguration> pfMonitoringApplicationConfiguration;

        // The number of multiplayer servers to host on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The OS platform used for running the game process.
        FString OsPlatform;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        // [optional] The resource constraints to apply to each server on the VM (EXPERIMENTAL API)
        TSharedPtr<FServerResourceConstraintParams> ServerResourceConstraints;

        // [optional] The type of game server being hosted.
        FString ServerType;

        /**
         * [optional] When true, assets will be downloaded and uncompressed in memory, without the compressedversion being written first to
         * disc.
         */
        Boxed<bool> UseStreamingForAssetDownloads;

        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript feature for the build
        TSharedPtr<FVmStartupScriptConfiguration> pfVmStartupScriptConfiguration;

        FCreateBuildWithCustomContainerResponse() :
            FPlayFabCppResultCommon(),
            AreAssetsReadonly(),
            BuildId(),
            BuildName(),
            pfContainerFlavor(),
            ContainerRunCommand(),
            CreationTime(),
            CustomGameContainerImage(nullptr),
            GameAssetReferences(),
            GameCertificateReferences(),
            pfLinuxInstrumentationConfiguration(nullptr),
            Metadata(),
            pfMonitoringApplicationConfiguration(nullptr),
            MultiplayerServerCountPerVm(0),
            OsPlatform(),
            Ports(),
            RegionConfigurations(),
            ServerResourceConstraints(nullptr),
            ServerType(),
            UseStreamingForAssetDownloads(),
            VmSize(),
            pfVmStartupScriptConfiguration(nullptr)
            {}

        FCreateBuildWithCustomContainerResponse(const FCreateBuildWithCustomContainerResponse& src) = default;

        FCreateBuildWithCustomContainerResponse(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithCustomContainerResponse()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithCustomContainerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FInstrumentationConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Designates whether windows instrumentation configuration will be enabled for this Build
        Boxed<bool> IsEnabled;

        /**
         * [optional] This property is deprecated, use IsEnabled. The list of processes to be monitored on a VM for this build. Providing
         * processes will turn on performance metrics collection for this build. Process names should not include extensions. If
         * the game server process is: GameServer.exe; then, ProcessesToMonitor = [ GameServer ]
         */
        TArray<FString> ProcessesToMonitor;
        FInstrumentationConfiguration() :
            FPlayFabCppBaseModel(),
            IsEnabled(),
            ProcessesToMonitor()
            {}

        FInstrumentationConfiguration(const FInstrumentationConfiguration& src) = default;

        FInstrumentationConfiguration(const TSharedPtr<FJsonObject>& obj) : FInstrumentationConfiguration()
        {
            readFromValue(obj);
        }

        ~FInstrumentationConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FWindowsCrashDumpConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] See https://docs.microsoft.com/en-us/windows/win32/wer/collecting-user-mode-dumps for valid values.
        Boxed<int32> CustomDumpFlags;

        // [optional] See https://docs.microsoft.com/en-us/windows/win32/wer/collecting-user-mode-dumps for valid values.
        Boxed<int32> DumpType;

        // Designates whether automatic crash dump capturing will be enabled for this Build.
        bool IsEnabled;

        FWindowsCrashDumpConfiguration() :
            FPlayFabCppBaseModel(),
            CustomDumpFlags(),
            DumpType(),
            IsEnabled(false)
            {}

        FWindowsCrashDumpConfiguration(const FWindowsCrashDumpConfiguration& src) = default;

        FWindowsCrashDumpConfiguration(const TSharedPtr<FJsonObject>& obj) : FWindowsCrashDumpConfiguration()
        {
            readFromValue(obj);
        }

        ~FWindowsCrashDumpConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithManagedContainerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // The build name.
        FString BuildName;

        // [optional] The flavor of container to create a build from.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The list of game assets related to the build.
        TArray<FAssetReferenceParams> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReferenceParams> GameCertificateReferences;
        /**
         * [optional] The directory containing the game executable. This would be the start path of the game assets that contain the main game
         * server executable. If not provided, a best effort will be made to extract it from the start game command.
         */
        FString GameWorkingDirectory;

        // [optional] The instrumentation configuration for the build.
        TSharedPtr<FInstrumentationConfiguration> pfInstrumentationConfiguration;

        /**
         * [optional] Metadata to tag the build. The keys are case insensitive. The build metadata is made available to the server through
         * Game Server SDK (GSDK).Constraints: Maximum number of keys: 30, Maximum key length: 50, Maximum value length: 100
         */
        TMap<FString, FString> Metadata;
        // [optional] The configuration for the monitoring application on the build
        TSharedPtr<FMonitoringApplicationConfigurationParams> MonitoringApplicationConfiguration;

        // The number of multiplayer servers to host on a single VM.
        int32 MultiplayerServerCountPerVm;

        // The ports to map the build on.
        TArray<FPort> Ports;
        // The region configurations for the build.
        TArray<FBuildRegionParams> RegionConfigurations;
        // [optional] The resource constraints to apply to each server on the VM (EXPERIMENTAL API)
        TSharedPtr<FServerResourceConstraintParams> ServerResourceConstraints;

        // The command to run when the multiplayer server is started, including any arguments.
        FString StartMultiplayerServerCommand;

        // [optional] The VM size to create the build on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript for the build
        TSharedPtr<FVmStartupScriptParams> VmStartupScriptConfiguration;

        // [optional] The crash dump configuration for the build.
        TSharedPtr<FWindowsCrashDumpConfiguration> pfWindowsCrashDumpConfiguration;

        FCreateBuildWithManagedContainerRequest() :
            FPlayFabCppRequestCommon(),
            AreAssetsReadonly(),
            BuildName(),
            pfContainerFlavor(),
            CustomTags(),
            GameAssetReferences(),
            GameCertificateReferences(),
            GameWorkingDirectory(),
            pfInstrumentationConfiguration(nullptr),
            Metadata(),
            MonitoringApplicationConfiguration(nullptr),
            MultiplayerServerCountPerVm(0),
            Ports(),
            RegionConfigurations(),
            ServerResourceConstraints(nullptr),
            StartMultiplayerServerCommand(),
            VmSize(),
            VmStartupScriptConfiguration(nullptr),
            pfWindowsCrashDumpConfiguration(nullptr)
            {}

        FCreateBuildWithManagedContainerRequest(const FCreateBuildWithManagedContainerRequest& src) = default;

        FCreateBuildWithManagedContainerRequest(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithManagedContainerRequest()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithManagedContainerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithManagedContainerResponse : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // [optional] The guid string build ID. Must be unique for every build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The flavor of container of the build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        /**
         * [optional] The directory containing the game executable. This would be the start path of the game assets that contain the main game
         * server executable. If not provided, a best effort will be made to extract it from the start game command.
         */
        FString GameWorkingDirectory;

        // [optional] The instrumentation configuration for this build.
        TSharedPtr<FInstrumentationConfiguration> pfInstrumentationConfiguration;

        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // [optional] The configuration for the monitoring application for the build
        TSharedPtr<FMonitoringApplicationConfiguration> pfMonitoringApplicationConfiguration;

        // The number of multiplayer servers to host on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The OS platform used for running the game process.
        FString OsPlatform;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        // [optional] The resource constraints to apply to each server on the VM (EXPERIMENTAL API)
        TSharedPtr<FServerResourceConstraintParams> ServerResourceConstraints;

        // [optional] The type of game server being hosted.
        FString ServerType;

        // [optional] The command to run when the multiplayer server has been allocated, including any arguments.
        FString StartMultiplayerServerCommand;

        /**
         * [optional] When true, assets will be downloaded and uncompressed in memory, without the compressedversion being written first to
         * disc.
         */
        Boxed<bool> UseStreamingForAssetDownloads;

        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript feature for the build
        TSharedPtr<FVmStartupScriptConfiguration> pfVmStartupScriptConfiguration;

        FCreateBuildWithManagedContainerResponse() :
            FPlayFabCppResultCommon(),
            AreAssetsReadonly(),
            BuildId(),
            BuildName(),
            pfContainerFlavor(),
            CreationTime(),
            GameAssetReferences(),
            GameCertificateReferences(),
            GameWorkingDirectory(),
            pfInstrumentationConfiguration(nullptr),
            Metadata(),
            pfMonitoringApplicationConfiguration(nullptr),
            MultiplayerServerCountPerVm(0),
            OsPlatform(),
            Ports(),
            RegionConfigurations(),
            ServerResourceConstraints(nullptr),
            ServerType(),
            StartMultiplayerServerCommand(),
            UseStreamingForAssetDownloads(),
            VmSize(),
            pfVmStartupScriptConfiguration(nullptr)
            {}

        FCreateBuildWithManagedContainerResponse(const FCreateBuildWithManagedContainerResponse& src) = default;

        FCreateBuildWithManagedContainerResponse(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithManagedContainerResponse()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithManagedContainerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithProcessBasedServerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // The build name.
        FString BuildName;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The list of game assets related to the build.
        TArray<FAssetReferenceParams> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReferenceParams> GameCertificateReferences;
        /**
         * [optional] The working directory for the game process. If this is not provided, the working directory will be set based on the
         * mount path of the game server executable.
         */
        FString GameWorkingDirectory;

        // [optional] The instrumentation configuration for the build.
        TSharedPtr<FInstrumentationConfiguration> pfInstrumentationConfiguration;

        /**
         * [optional] Indicates whether this build will be created using the OS Preview versionPreview OS is recommended for dev builds to
         * detect any breaking changes before they are released to retail. Retail builds should set this value to false.
         */
        Boxed<bool> IsOSPreview;

        /**
         * [optional] Metadata to tag the build. The keys are case insensitive. The build metadata is made available to the server through
         * Game Server SDK (GSDK).Constraints: Maximum number of keys: 30, Maximum key length: 50, Maximum value length: 100
         */
        TMap<FString, FString> Metadata;
        // [optional] The configuration for the monitoring application on the build
        TSharedPtr<FMonitoringApplicationConfigurationParams> MonitoringApplicationConfiguration;

        // The number of multiplayer servers to host on a single VM.
        int32 MultiplayerServerCountPerVm;

        // [optional] The OS platform used for running the game process.
        FString OsPlatform;

        // The ports to map the build on.
        TArray<FPort> Ports;
        // The region configurations for the build.
        TArray<FBuildRegionParams> RegionConfigurations;
        /**
         * The command to run when the multiplayer server is started, including any arguments. The path to any executable should be
         * relative to the root asset folder when unzipped.
         */
        FString StartMultiplayerServerCommand;

        // [optional] The VM size to create the build on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript for the build
        TSharedPtr<FVmStartupScriptParams> VmStartupScriptConfiguration;

        FCreateBuildWithProcessBasedServerRequest() :
            FPlayFabCppRequestCommon(),
            AreAssetsReadonly(),
            BuildName(),
            CustomTags(),
            GameAssetReferences(),
            GameCertificateReferences(),
            GameWorkingDirectory(),
            pfInstrumentationConfiguration(nullptr),
            IsOSPreview(),
            Metadata(),
            MonitoringApplicationConfiguration(nullptr),
            MultiplayerServerCountPerVm(0),
            OsPlatform(),
            Ports(),
            RegionConfigurations(),
            StartMultiplayerServerCommand(),
            VmSize(),
            VmStartupScriptConfiguration(nullptr)
            {}

        FCreateBuildWithProcessBasedServerRequest(const FCreateBuildWithProcessBasedServerRequest& src) = default;

        FCreateBuildWithProcessBasedServerRequest(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithProcessBasedServerRequest()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithProcessBasedServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateBuildWithProcessBasedServerResponse : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // [optional] The guid string build ID. Must be unique for every build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The flavor of container of the build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        /**
         * [optional] The working directory for the game process. If this is not provided, the working directory will be set based on the
         * mount path of the game server executable.
         */
        FString GameWorkingDirectory;

        // [optional] The instrumentation configuration for this build.
        TSharedPtr<FInstrumentationConfiguration> pfInstrumentationConfiguration;

        /**
         * [optional] Indicates whether this build will be created using the OS Preview versionPreview OS is recommended for dev builds to
         * detect any breaking changes before they are released to retail. Retail builds should set this value to false.
         */
        Boxed<bool> IsOSPreview;

        // [optional] The metadata of the build.
        TMap<FString, FString> Metadata;
        // [optional] The configuration for the monitoring application for the build
        TSharedPtr<FMonitoringApplicationConfiguration> pfMonitoringApplicationConfiguration;

        // The number of multiplayer servers to host on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The OS platform used for running the game process.
        FString OsPlatform;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        // [optional] The type of game server being hosted.
        FString ServerType;

        /**
         * [optional] The command to run when the multiplayer server is started, including any arguments. The path to any executable is
         * relative to the root asset folder when unzipped.
         */
        FString StartMultiplayerServerCommand;

        /**
         * [optional] When true, assets will be downloaded and uncompressed in memory, without the compressedversion being written first to
         * disc.
         */
        Boxed<bool> UseStreamingForAssetDownloads;

        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript feature for the build
        TSharedPtr<FVmStartupScriptConfiguration> pfVmStartupScriptConfiguration;

        FCreateBuildWithProcessBasedServerResponse() :
            FPlayFabCppResultCommon(),
            AreAssetsReadonly(),
            BuildId(),
            BuildName(),
            pfContainerFlavor(),
            CreationTime(),
            GameAssetReferences(),
            GameCertificateReferences(),
            GameWorkingDirectory(),
            pfInstrumentationConfiguration(nullptr),
            IsOSPreview(),
            Metadata(),
            pfMonitoringApplicationConfiguration(nullptr),
            MultiplayerServerCountPerVm(0),
            OsPlatform(),
            Ports(),
            RegionConfigurations(),
            ServerType(),
            StartMultiplayerServerCommand(),
            UseStreamingForAssetDownloads(),
            VmSize(),
            pfVmStartupScriptConfiguration(nullptr)
            {}

        FCreateBuildWithProcessBasedServerResponse(const FCreateBuildWithProcessBasedServerResponse& src) = default;

        FCreateBuildWithProcessBasedServerResponse(const TSharedPtr<FJsonObject>& obj) : FCreateBuildWithProcessBasedServerResponse()
        {
            readFromValue(obj);
        }

        ~FCreateBuildWithProcessBasedServerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMember : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Key-value pairs specific to member.
        TMap<FString, FString> MemberData;
        // [optional] The member entity key.
        TSharedPtr<FEntityKey> MemberEntity;

        // [optional] Opaque string, stored on a Subscribe call, which indicates the connection an owner or member has with PubSub.
        FString PubSubConnectionHandle;

        FMember() :
            FPlayFabCppBaseModel(),
            MemberData(),
            MemberEntity(nullptr),
            PubSubConnectionHandle()
            {}

        FMember(const FMember& src) = default;

        FMember(const TSharedPtr<FJsonObject>& obj) : FMember()
        {
            readFromValue(obj);
        }

        ~FMember();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum OwnerMigrationPolicy
    {
        OwnerMigrationPolicyNone,
        OwnerMigrationPolicyAutomatic,
        OwnerMigrationPolicyManual,
        OwnerMigrationPolicyServer
    };

    PLAYFABCPP_API void writeOwnerMigrationPolicyEnumJSON(OwnerMigrationPolicy enumVal, JsonWriter& writer);
    PLAYFABCPP_API OwnerMigrationPolicy readOwnerMigrationPolicyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API OwnerMigrationPolicy readOwnerMigrationPolicyFromValue(const FString& value);

    struct PLAYFABCPP_API FCreateLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] The policy indicating who is allowed to join the lobby, and the visibility to queries. May be 'Public', 'Friends' or
         * 'Private'. Public means the lobby is both visible in queries and any player may join, including invited players. Friends
         * means that users who are bidirectional friends of members in the lobby may search to find friend lobbies, to retrieve
         * its connection string. Private means the lobby is not visible in queries, and a player must receive an invitation to
         * join. Defaults to 'Public' on creation. Can only be changed by the lobby owner.
         */
        Boxed<AccessPolicy> pfAccessPolicy;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] The private key-value pairs which are visible to all entities in the lobby. At most 30 key-value pairs may be stored
         * here, keys are limited to 30 characters and values to 1000. The total size of all lobbyData values may not exceed 4096
         * bytes. Keys are case sensitive.
         */
        TMap<FString, FString> LobbyData;
        // The maximum number of players allowed in the lobby. The value must be between 2 and 128.
        uint32 MaxPlayers;

        /**
         * [optional] The member initially added to the lobby. Client must specify exactly one member, which is the creator's entity and
         * member data. Member PubSubConnectionHandle must be null or empty. Game servers must not specify any members.
         */
        TArray<FMember> Members;
        // The lobby owner. Must be the calling entity.
        FEntityKey Owner;

        /**
         * [optional] The policy for how a new owner is chosen. May be 'Automatic', 'Manual' or 'None'. Can only be specified by clients. If
         * client-owned and 'Automatic' - The Lobby service will automatically assign another connected owner when the current
         * owner leaves or disconnects. The useConnections property must be true. If client - owned and 'Manual' - Ownership is
         * protected as long as the current owner is connected. If the current owner leaves or disconnects any member may set
         * themselves as the current owner. The useConnections property must be true. If client-owned and 'None' - Any member can
         * set ownership. The useConnections property can be either true or false.
         */
        Boxed<OwnerMigrationPolicy> pfOwnerMigrationPolicy;

        /**
         * [optional] The public key-value pairs which allow queries to differentiate between lobbies. Queries will refer to these key-value
         * pairs in their filter and order by clauses to retrieve lobbies fitting the specified criteria. At most 30 key-value
         * pairs may be stored here. Keys are of the format string_key1, string_key2 ... string_key30 for string values, or
         * number_key1, number_key2, ... number_key30 for numeric values.Numeric values are floats. Values can be at most 256
         * characters long. The total size of all searchData values may not exceed 1024 bytes.
         */
        TMap<FString, FString> SearchData;
        /**
         * A setting to control whether connections are used. Defaults to true. When true, notifications are sent to subscribed
         * players, disconnect detection removes connectionHandles, only owner migration policies using connections are allowed,
         * and lobbies must have at least one connected member to be searchable or be a server hosted lobby with a connected
         * server. If false, then notifications are not sent, connections are not allowed, and lobbies do not need connections to
         * be searchable.
         */
        bool UseConnections;

        FCreateLobbyRequest() :
            FPlayFabCppRequestCommon(),
            pfAccessPolicy(),
            CustomTags(),
            LobbyData(),
            MaxPlayers(0),
            Members(),
            Owner(),
            pfOwnerMigrationPolicy(),
            SearchData(),
            UseConnections(false)
            {}

        FCreateLobbyRequest(const FCreateLobbyRequest& src) = default;

        FCreateLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FCreateLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FCreateLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateLobbyResult : public PlayFab::FPlayFabCppResultCommon
    {
        // A field which indicates which lobby the user will be joining.
        FString ConnectionString;

        // Id to uniquely identify a lobby.
        FString LobbyId;

        FCreateLobbyResult() :
            FPlayFabCppResultCommon(),
            ConnectionString(),
            LobbyId()
            {}

        FCreateLobbyResult(const FCreateLobbyResult& src) = default;

        FCreateLobbyResult(const TSharedPtr<FJsonObject>& obj) : FCreateLobbyResult()
        {
            readFromValue(obj);
        }

        ~FCreateLobbyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMatchmakingPlayerAttributes : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] A data object representing a user's attributes.
        FJsonKeeper DataObject;

        // [optional] An escaped data object representing a user's attributes.
        FString EscapedDataObject;

        FMatchmakingPlayerAttributes() :
            FPlayFabCppBaseModel(),
            DataObject(),
            EscapedDataObject()
            {}

        FMatchmakingPlayerAttributes(const FMatchmakingPlayerAttributes& src) = default;

        FMatchmakingPlayerAttributes(const TSharedPtr<FJsonObject>& obj) : FMatchmakingPlayerAttributes()
        {
            readFromValue(obj);
        }

        ~FMatchmakingPlayerAttributes();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMatchmakingPlayer : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The user's attributes custom to the title.
        TSharedPtr<FMatchmakingPlayerAttributes> Attributes;

        // The entity key of the matchmaking user.
        FEntityKey Entity;

        FMatchmakingPlayer() :
            FPlayFabCppBaseModel(),
            Attributes(nullptr),
            Entity()
            {}

        FMatchmakingPlayer(const FMatchmakingPlayer& src) = default;

        FMatchmakingPlayer(const TSharedPtr<FJsonObject>& obj) : FMatchmakingPlayer()
        {
            readFromValue(obj);
        }

        ~FMatchmakingPlayer();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateMatchmakingTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The User who created this ticket.
        FMatchmakingPlayer Creator;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // How long to attempt matching this ticket in seconds.
        int32 GiveUpAfterSeconds;

        // [optional] A list of Entity Keys of other users to match with.
        TArray<FEntityKey> MembersToMatchWith;
        // The Id of a match queue.
        FString QueueName;

        FCreateMatchmakingTicketRequest() :
            FPlayFabCppRequestCommon(),
            Creator(),
            CustomTags(),
            GiveUpAfterSeconds(0),
            MembersToMatchWith(),
            QueueName()
            {}

        FCreateMatchmakingTicketRequest(const FCreateMatchmakingTicketRequest& src) = default;

        FCreateMatchmakingTicketRequest(const TSharedPtr<FJsonObject>& obj) : FCreateMatchmakingTicketRequest()
        {
            readFromValue(obj);
        }

        ~FCreateMatchmakingTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateMatchmakingTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        // The Id of the ticket to find a match for.
        FString TicketId;

        FCreateMatchmakingTicketResult() :
            FPlayFabCppResultCommon(),
            TicketId()
            {}

        FCreateMatchmakingTicketResult(const FCreateMatchmakingTicketResult& src) = default;

        FCreateMatchmakingTicketResult(const TSharedPtr<FJsonObject>& obj) : FCreateMatchmakingTicketResult()
        {
            readFromValue(obj);
        }

        ~FCreateMatchmakingTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateRemoteUserRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of to create the remote user for.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The expiration time for the remote user created. Defaults to expiring in one day if not specified.
        Boxed<FDateTime> ExpirationTime;

        // The region of virtual machine to create the remote user for.
        FString Region;

        // The username to create the remote user with.
        FString Username;

        // The virtual machine ID the multiplayer server is located on.
        FString VmId;

        FCreateRemoteUserRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags(),
            ExpirationTime(),
            Region(),
            Username(),
            VmId()
            {}

        FCreateRemoteUserRequest(const FCreateRemoteUserRequest& src) = default;

        FCreateRemoteUserRequest(const TSharedPtr<FJsonObject>& obj) : FCreateRemoteUserRequest()
        {
            readFromValue(obj);
        }

        ~FCreateRemoteUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateRemoteUserResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The expiration time for the remote user created.
        Boxed<FDateTime> ExpirationTime;

        // [optional] The generated password for the remote user that was created.
        FString Password;

        // [optional] The username for the remote user that was created.
        FString Username;

        FCreateRemoteUserResponse() :
            FPlayFabCppResultCommon(),
            ExpirationTime(),
            Password(),
            Username()
            {}

        FCreateRemoteUserResponse(const FCreateRemoteUserResponse& src) = default;

        FCreateRemoteUserResponse(const TSharedPtr<FJsonObject>& obj) : FCreateRemoteUserResponse()
        {
            readFromValue(obj);
        }

        ~FCreateRemoteUserResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMatchmakingPlayerWithTeamAssignment : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] The user's attributes custom to the title. These attributes will be null unless the request has ReturnMemberAttributes
         * flag set to true.
         */
        TSharedPtr<FMatchmakingPlayerAttributes> Attributes;

        // The entity key of the matchmaking user.
        FEntityKey Entity;

        // [optional] The Id of the team the User is assigned to.
        FString TeamId;

        FMatchmakingPlayerWithTeamAssignment() :
            FPlayFabCppBaseModel(),
            Attributes(nullptr),
            Entity(),
            TeamId()
            {}

        FMatchmakingPlayerWithTeamAssignment(const FMatchmakingPlayerWithTeamAssignment& src) = default;

        FMatchmakingPlayerWithTeamAssignment(const TSharedPtr<FJsonObject>& obj) : FMatchmakingPlayerWithTeamAssignment()
        {
            readFromValue(obj);
        }

        ~FMatchmakingPlayerWithTeamAssignment();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FServerDetails : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The fully qualified domain name of the virtual machine that is hosting this multiplayer server.
        FString Fqdn;

        // [optional] The IPv4 address of the virtual machine that is hosting this multiplayer server.
        FString IPV4Address;

        // [optional] The ports the multiplayer server uses.
        TArray<FPort> Ports;
        // [optional] The server's region.
        FString Region;

        FServerDetails() :
            FPlayFabCppBaseModel(),
            Fqdn(),
            IPV4Address(),
            Ports(),
            Region()
            {}

        FServerDetails(const FServerDetails& src) = default;

        FServerDetails(const TSharedPtr<FJsonObject>& obj) : FServerDetails()
        {
            readFromValue(obj);
        }

        ~FServerDetails();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateServerBackfillTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // How long to attempt matching this ticket in seconds.
        int32 GiveUpAfterSeconds;

        // The users who will be part of this ticket, along with their team assignments.
        TArray<FMatchmakingPlayerWithTeamAssignment> Members;
        // The Id of a match queue.
        FString QueueName;

        // [optional] The details of the server the members are connected to.
        TSharedPtr<FServerDetails> pfServerDetails;

        FCreateServerBackfillTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            GiveUpAfterSeconds(0),
            Members(),
            QueueName(),
            pfServerDetails(nullptr)
            {}

        FCreateServerBackfillTicketRequest(const FCreateServerBackfillTicketRequest& src) = default;

        FCreateServerBackfillTicketRequest(const TSharedPtr<FJsonObject>& obj) : FCreateServerBackfillTicketRequest()
        {
            readFromValue(obj);
        }

        ~FCreateServerBackfillTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateServerBackfillTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        // The Id of the ticket to find a match for.
        FString TicketId;

        FCreateServerBackfillTicketResult() :
            FPlayFabCppResultCommon(),
            TicketId()
            {}

        FCreateServerBackfillTicketResult(const FCreateServerBackfillTicketResult& src) = default;

        FCreateServerBackfillTicketResult(const TSharedPtr<FJsonObject>& obj) : FCreateServerBackfillTicketResult()
        {
            readFromValue(obj);
        }

        ~FCreateServerBackfillTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateServerMatchmakingTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // How long to attempt matching this ticket in seconds.
        int32 GiveUpAfterSeconds;

        // The users who will be part of this ticket.
        TArray<FMatchmakingPlayer> Members;
        // The Id of a match queue.
        FString QueueName;

        FCreateServerMatchmakingTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            GiveUpAfterSeconds(0),
            Members(),
            QueueName()
            {}

        FCreateServerMatchmakingTicketRequest(const FCreateServerMatchmakingTicketRequest& src) = default;

        FCreateServerMatchmakingTicketRequest(const TSharedPtr<FJsonObject>& obj) : FCreateServerMatchmakingTicketRequest()
        {
            readFromValue(obj);
        }

        ~FCreateServerMatchmakingTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateTitleMultiplayerServersQuotaChangeRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] A brief description of the requested changes.
        FString ChangeDescription;

        // Changes to make to the titles cores quota.
        TArray<FCoreCapacityChange> Changes;
        // [optional] Email to be contacted by our team about this request. Only required when a request is not approved.
        FString ContactEmail;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Additional information about this request that our team can use to better understand the requirements.
        FString Notes;

        // [optional] When these changes would need to be in effect. Only required when a request is not approved.
        Boxed<FDateTime> StartDate;

        FCreateTitleMultiplayerServersQuotaChangeRequest() :
            FPlayFabCppRequestCommon(),
            ChangeDescription(),
            Changes(),
            ContactEmail(),
            CustomTags(),
            Notes(),
            StartDate()
            {}

        FCreateTitleMultiplayerServersQuotaChangeRequest(const FCreateTitleMultiplayerServersQuotaChangeRequest& src) = default;

        FCreateTitleMultiplayerServersQuotaChangeRequest(const TSharedPtr<FJsonObject>& obj) : FCreateTitleMultiplayerServersQuotaChangeRequest()
        {
            readFromValue(obj);
        }

        ~FCreateTitleMultiplayerServersQuotaChangeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FCreateTitleMultiplayerServersQuotaChangeResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] Id of the change request that was created.
        FString RequestId;

        // Determines if the request was approved or not. When false, our team is reviewing and may respond within 2 business days.
        bool WasApproved;

        FCreateTitleMultiplayerServersQuotaChangeResponse() :
            FPlayFabCppResultCommon(),
            RequestId(),
            WasApproved(false)
            {}

        FCreateTitleMultiplayerServersQuotaChangeResponse(const FCreateTitleMultiplayerServersQuotaChangeResponse& src) = default;

        FCreateTitleMultiplayerServersQuotaChangeResponse(const TSharedPtr<FJsonObject>& obj) : FCreateTitleMultiplayerServersQuotaChangeResponse()
        {
            readFromValue(obj);
        }

        ~FCreateTitleMultiplayerServersQuotaChangeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteAssetRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The filename of the asset to delete.
        FString FileName;

        FDeleteAssetRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            FileName()
            {}

        FDeleteAssetRequest(const FDeleteAssetRequest& src) = default;

        FDeleteAssetRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteAssetRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteAssetRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteBuildAliasRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string alias ID of the alias to perform the action on.
        FString AliasId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FDeleteBuildAliasRequest() :
            FPlayFabCppRequestCommon(),
            AliasId(),
            CustomTags()
            {}

        FDeleteBuildAliasRequest(const FDeleteBuildAliasRequest& src) = default;

        FDeleteBuildAliasRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteBuildAliasRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteBuildAliasRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteBuildRegionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string ID of the build we want to update regions for.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The build region to delete.
        FString Region;

        FDeleteBuildRegionRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags(),
            Region()
            {}

        FDeleteBuildRegionRequest(const FDeleteBuildRegionRequest& src) = default;

        FDeleteBuildRegionRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteBuildRegionRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteBuildRegionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteBuildRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of the build to delete.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FDeleteBuildRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags()
            {}

        FDeleteBuildRequest(const FDeleteBuildRequest& src) = default;

        FDeleteBuildRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteBuildRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteCertificateRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The name of the certificate.
        FString Name;

        FDeleteCertificateRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Name()
            {}

        FDeleteCertificateRequest(const FDeleteCertificateRequest& src) = default;

        FDeleteCertificateRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteCertificateRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteCertificateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteContainerImageRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The container image repository we want to delete.
        FString ImageName;

        FDeleteContainerImageRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            ImageName()
            {}

        FDeleteContainerImageRequest(const FDeleteContainerImageRequest& src) = default;

        FDeleteContainerImageRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteContainerImageRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteContainerImageRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The id of the lobby.
        FString LobbyId;

        FDeleteLobbyRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId()
            {}

        FDeleteLobbyRequest(const FDeleteLobbyRequest& src) = default;

        FDeleteLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FDeleteRemoteUserRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of the multiplayer server where the remote user is to delete.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The region of the multiplayer server where the remote user is to delete.
        FString Region;

        // The username of the remote user to delete.
        FString Username;

        // The virtual machine ID the multiplayer server is located on.
        FString VmId;

        FDeleteRemoteUserRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags(),
            Region(),
            Username(),
            VmId()
            {}

        FDeleteRemoteUserRequest(const FDeleteRemoteUserRequest& src) = default;

        FDeleteRemoteUserRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteRemoteUserRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteRemoteUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum DirectPeerConnectivityOptions
    {
        DirectPeerConnectivityOptionsNone,
        DirectPeerConnectivityOptionsSamePlatformType,
        DirectPeerConnectivityOptionsDifferentPlatformType,
        DirectPeerConnectivityOptionsAnyPlatformType,
        DirectPeerConnectivityOptionsSameEntityLoginProvider,
        DirectPeerConnectivityOptionsDifferentEntityLoginProvider,
        DirectPeerConnectivityOptionsAnyEntityLoginProvider,
        DirectPeerConnectivityOptionsAnyPlatformTypeAndEntityLoginProvider
    };

    PLAYFABCPP_API void writeDirectPeerConnectivityOptionsEnumJSON(DirectPeerConnectivityOptions enumVal, JsonWriter& writer);
    PLAYFABCPP_API DirectPeerConnectivityOptions readDirectPeerConnectivityOptionsFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API DirectPeerConnectivityOptions readDirectPeerConnectivityOptionsFromValue(const FString& value);

    struct PLAYFABCPP_API FEmptyResponse : public PlayFab::FPlayFabCppResultCommon
    {
        FEmptyResponse() :
            FPlayFabCppResultCommon()
            {}

        FEmptyResponse(const FEmptyResponse& src) = default;

        FEmptyResponse(const TSharedPtr<FJsonObject>& obj) : FEmptyResponse()
        {
            readFromValue(obj);
        }

        ~FEmptyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FEnableMultiplayerServersForTitleRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FEnableMultiplayerServersForTitleRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FEnableMultiplayerServersForTitleRequest(const FEnableMultiplayerServersForTitleRequest& src) = default;

        FEnableMultiplayerServersForTitleRequest(const TSharedPtr<FJsonObject>& obj) : FEnableMultiplayerServersForTitleRequest()
        {
            readFromValue(obj);
        }

        ~FEnableMultiplayerServersForTitleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TitleMultiplayerServerEnabledStatus
    {
        TitleMultiplayerServerEnabledStatusInitializing,
        TitleMultiplayerServerEnabledStatusEnabled,
        TitleMultiplayerServerEnabledStatusDisabled
    };

    PLAYFABCPP_API void writeTitleMultiplayerServerEnabledStatusEnumJSON(TitleMultiplayerServerEnabledStatus enumVal, JsonWriter& writer);
    PLAYFABCPP_API TitleMultiplayerServerEnabledStatus readTitleMultiplayerServerEnabledStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API TitleMultiplayerServerEnabledStatus readTitleMultiplayerServerEnabledStatusFromValue(const FString& value);

    struct PLAYFABCPP_API FEnableMultiplayerServersForTitleResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The enabled status for the multiplayer server features for the title.
        Boxed<TitleMultiplayerServerEnabledStatus> Status;

        FEnableMultiplayerServersForTitleResponse() :
            FPlayFabCppResultCommon(),
            Status()
            {}

        FEnableMultiplayerServersForTitleResponse(const FEnableMultiplayerServersForTitleResponse& src) = default;

        FEnableMultiplayerServersForTitleResponse(const TSharedPtr<FJsonObject>& obj) : FEnableMultiplayerServersForTitleResponse()
        {
            readFromValue(obj);
        }

        ~FEnableMultiplayerServersForTitleResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ExternalFriendSources
    {
        ExternalFriendSourcesNone,
        ExternalFriendSourcesSteam,
        ExternalFriendSourcesFacebook,
        ExternalFriendSourcesXbox,
        ExternalFriendSourcesPsn,
        ExternalFriendSourcesAll
    };

    PLAYFABCPP_API void writeExternalFriendSourcesEnumJSON(ExternalFriendSources enumVal, JsonWriter& writer);
    PLAYFABCPP_API ExternalFriendSources readExternalFriendSourcesFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ExternalFriendSources readExternalFriendSourcesFromValue(const FString& value);

    struct PLAYFABCPP_API FPaginationRequest : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Continuation token returned as a result in a previous FindLobbies call. Cannot be specified by clients.
        FString ContinuationToken;

        // [optional] The number of lobbies that should be retrieved. Cannot be specified by servers, clients may specify any value up to 50
        Boxed<uint32> PageSizeRequested;

        FPaginationRequest() :
            FPlayFabCppBaseModel(),
            ContinuationToken(),
            PageSizeRequested()
            {}

        FPaginationRequest(const FPaginationRequest& src) = default;

        FPaginationRequest(const TSharedPtr<FJsonObject>& obj) : FPaginationRequest()
        {
            readFromValue(obj);
        }

        ~FPaginationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FFindFriendLobbiesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Indicates which other platforms' friends this query should link to.
        Boxed<ExternalFriendSources> ExternalPlatformFriends;

        /**
         * [optional] OData style string that contains one or more filters. Only the following operators are supported: "and" (logical and),
         * "eq" (equal), "ne" (not equals), "ge" (greater than or equal), "gt" (greater than), "le" (less than or equal), and "lt"
         * (less than). The left-hand side of each OData logical expression should be either a search property key (e.g.
         * string_key1, number_key3, etc) or one of the pre-defined search keys all of which must be prefixed by "lobby/":
         * lobby/memberCount (number of players in a lobby), lobby/maxMemberCount (maximum number of players allowed in a lobby),
         * lobby/memberCountRemaining (remaining number of players who can be allowed in a lobby), lobby/membershipLock (must equal
         * 'Unlocked' or 'Locked'), lobby/amOwner (required to equal "true"), lobby/amMember (required to equal "true").
         */
        FString Filter;

        /**
         * [optional] OData style string that contains sorting for this query in either ascending ("asc") or descending ("desc") order.
         * OrderBy clauses are of the form "number_key1 asc" or the pre-defined search key "lobby/memberCount asc",
         * "lobby/memberCountRemaining desc" and "lobby/maxMemberCount desc". To sort by closest, a moniker `distance{number_key1 =
         * 5}` can be used to sort by distance from the given number. This field only supports either one sort clause or one
         * distance clause.
         */
        FString OrderBy;

        // [optional] Request pagination information.
        TSharedPtr<FPaginationRequest> Pagination;

        // [optional] Xbox token if Xbox friends should be included. Requires Xbox be configured on PlayFab.
        FString XboxToken;

        FFindFriendLobbiesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            ExternalPlatformFriends(),
            Filter(),
            OrderBy(),
            Pagination(nullptr),
            XboxToken()
            {}

        FFindFriendLobbiesRequest(const FFindFriendLobbiesRequest& src) = default;

        FFindFriendLobbiesRequest(const TSharedPtr<FJsonObject>& obj) : FFindFriendLobbiesRequest()
        {
            readFromValue(obj);
        }

        ~FFindFriendLobbiesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum MembershipLock
    {
        MembershipLockUnlocked,
        MembershipLockLocked
    };

    PLAYFABCPP_API void writeMembershipLockEnumJSON(MembershipLock enumVal, JsonWriter& writer);
    PLAYFABCPP_API MembershipLock readMembershipLockFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API MembershipLock readMembershipLockFromValue(const FString& value);

    struct PLAYFABCPP_API FFriendLobbySummary : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * A string used to join the lobby.This field is populated by the Lobby service.Invites are performed by communicating this
         * connectionString to other players.
         */
        FString ConnectionString;

        // The current number of players in the lobby.
        uint32 CurrentPlayers;

        // [optional] Friends in Lobby.
        TArray<FEntityKey> Friends;
        // Id to uniquely identify a lobby.
        FString LobbyId;

        // The maximum number of players allowed in the lobby.
        uint32 MaxPlayers;

        // [optional] A setting indicating whether members are allowed to join this lobby. When Locked new members are prevented from joining.
        Boxed<MembershipLock> pfMembershipLock;

        // The client or server entity which owns this lobby.
        FEntityKey Owner;

        // [optional] Search data.
        TMap<FString, FString> SearchData;
        FFriendLobbySummary() :
            FPlayFabCppBaseModel(),
            ConnectionString(),
            CurrentPlayers(0),
            Friends(),
            LobbyId(),
            MaxPlayers(0),
            pfMembershipLock(),
            Owner(),
            SearchData()
            {}

        FFriendLobbySummary(const FFriendLobbySummary& src) = default;

        FFriendLobbySummary(const TSharedPtr<FJsonObject>& obj) : FFriendLobbySummary()
        {
            readFromValue(obj);
        }

        ~FFriendLobbySummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPaginationResponse : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Continuation token returned by server call. Not returned for clients
        FString ContinuationToken;

        // [optional] The number of lobbies that matched the search request.
        Boxed<uint32> TotalMatchedLobbyCount;

        FPaginationResponse() :
            FPlayFabCppBaseModel(),
            ContinuationToken(),
            TotalMatchedLobbyCount()
            {}

        FPaginationResponse(const FPaginationResponse& src) = default;

        FPaginationResponse(const TSharedPtr<FJsonObject>& obj) : FPaginationResponse()
        {
            readFromValue(obj);
        }

        ~FPaginationResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FFindFriendLobbiesResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Array of lobbies found that matched FindFriendLobbies request.
        TArray<FFriendLobbySummary> Lobbies;
        // Pagination response for FindFriendLobbies request.
        FPaginationResponse Pagination;

        FFindFriendLobbiesResult() :
            FPlayFabCppResultCommon(),
            Lobbies(),
            Pagination()
            {}

        FFindFriendLobbiesResult(const FFindFriendLobbiesResult& src) = default;

        FFindFriendLobbiesResult(const TSharedPtr<FJsonObject>& obj) : FFindFriendLobbiesResult()
        {
            readFromValue(obj);
        }

        ~FFindFriendLobbiesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FFindLobbiesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] OData style string that contains one or more filters. Only the following operators are supported: "and" (logical and),
         * "eq" (equal), "ne" (not equals), "ge" (greater than or equal), "gt" (greater than), "le" (less than or equal), and "lt"
         * (less than). The left-hand side of each OData logical expression should be either a search property key (e.g.
         * string_key1, number_key3, etc) or one of the pre-defined search keys all of which must be prefixed by "lobby/":
         * lobby/memberCount (number of players in a lobby), lobby/maxMemberCount (maximum number of players allowed in a lobby),
         * lobby/memberCountRemaining (remaining number of players who can be allowed in a lobby), lobby/membershipLock (must equal
         * 'Unlocked' or 'Locked'), lobby/amOwner (required to equal "true"), lobby/amMember (required to equal "true").
         */
        FString Filter;

        /**
         * [optional] OData style string that contains sorting for this query in either ascending ("asc") or descending ("desc") order.
         * OrderBy clauses are of the form "number_key1 asc" or the pre-defined search key "lobby/memberCount asc",
         * "lobby/memberCountRemaining desc" and "lobby/maxMemberCount desc". To sort by closest, a moniker `distance{number_key1 =
         * 5}` can be used to sort by distance from the given number. This field only supports either one sort clause or one
         * distance clause.
         */
        FString OrderBy;

        // [optional] Request pagination information.
        TSharedPtr<FPaginationRequest> Pagination;

        FFindLobbiesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Filter(),
            OrderBy(),
            Pagination(nullptr)
            {}

        FFindLobbiesRequest(const FFindLobbiesRequest& src) = default;

        FFindLobbiesRequest(const TSharedPtr<FJsonObject>& obj) : FFindLobbiesRequest()
        {
            readFromValue(obj);
        }

        ~FFindLobbiesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLobbySummary : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * A string used to join the lobby.This field is populated by the Lobby service.Invites are performed by communicating this
         * connectionString to other players.
         */
        FString ConnectionString;

        // The current number of players in the lobby.
        uint32 CurrentPlayers;

        // Id to uniquely identify a lobby.
        FString LobbyId;

        // The maximum number of players allowed in the lobby.
        uint32 MaxPlayers;

        // [optional] A setting indicating whether members are allowed to join this lobby. When Locked new members are prevented from joining.
        Boxed<MembershipLock> pfMembershipLock;

        // The client or server entity which owns this lobby.
        FEntityKey Owner;

        // [optional] Search data.
        TMap<FString, FString> SearchData;
        FLobbySummary() :
            FPlayFabCppBaseModel(),
            ConnectionString(),
            CurrentPlayers(0),
            LobbyId(),
            MaxPlayers(0),
            pfMembershipLock(),
            Owner(),
            SearchData()
            {}

        FLobbySummary(const FLobbySummary& src) = default;

        FLobbySummary(const TSharedPtr<FJsonObject>& obj) : FLobbySummary()
        {
            readFromValue(obj);
        }

        ~FLobbySummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FFindLobbiesResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Array of lobbies found that matched FindLobbies request.
        TArray<FLobbySummary> Lobbies;
        // Pagination response for FindLobbies request.
        FPaginationResponse Pagination;

        FFindLobbiesResult() :
            FPlayFabCppResultCommon(),
            Lobbies(),
            Pagination()
            {}

        FFindLobbiesResult(const FFindLobbiesResult& src) = default;

        FFindLobbiesResult(const TSharedPtr<FJsonObject>& obj) : FFindLobbiesResult()
        {
            readFromValue(obj);
        }

        ~FFindLobbiesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAssetDownloadUrlRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The asset's file name to get the download URL for.
        FString FileName;

        FGetAssetDownloadUrlRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            FileName()
            {}

        FGetAssetDownloadUrlRequest(const FGetAssetDownloadUrlRequest& src) = default;

        FGetAssetDownloadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetAssetDownloadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetAssetDownloadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAssetDownloadUrlResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The asset's download URL.
        FString AssetDownloadUrl;

        // [optional] The asset's file name to get the download URL for.
        FString FileName;

        FGetAssetDownloadUrlResponse() :
            FPlayFabCppResultCommon(),
            AssetDownloadUrl(),
            FileName()
            {}

        FGetAssetDownloadUrlResponse(const FGetAssetDownloadUrlResponse& src) = default;

        FGetAssetDownloadUrlResponse(const TSharedPtr<FJsonObject>& obj) : FGetAssetDownloadUrlResponse()
        {
            readFromValue(obj);
        }

        ~FGetAssetDownloadUrlResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAssetUploadUrlRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The asset's file name to get the upload URL for.
        FString FileName;

        FGetAssetUploadUrlRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            FileName()
            {}

        FGetAssetUploadUrlRequest(const FGetAssetUploadUrlRequest& src) = default;

        FGetAssetUploadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetAssetUploadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetAssetUploadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetAssetUploadUrlResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The asset's upload URL.
        FString AssetUploadUrl;

        // [optional] The asset's file name to get the upload URL for.
        FString FileName;

        FGetAssetUploadUrlResponse() :
            FPlayFabCppResultCommon(),
            AssetUploadUrl(),
            FileName()
            {}

        FGetAssetUploadUrlResponse(const FGetAssetUploadUrlResponse& src) = default;

        FGetAssetUploadUrlResponse(const TSharedPtr<FJsonObject>& obj) : FGetAssetUploadUrlResponse()
        {
            readFromValue(obj);
        }

        ~FGetAssetUploadUrlResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetBuildAliasRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string alias ID of the alias to perform the action on.
        FString AliasId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FGetBuildAliasRequest() :
            FPlayFabCppRequestCommon(),
            AliasId(),
            CustomTags()
            {}

        FGetBuildAliasRequest(const FGetBuildAliasRequest& src) = default;

        FGetBuildAliasRequest(const TSharedPtr<FJsonObject>& obj) : FGetBuildAliasRequest()
        {
            readFromValue(obj);
        }

        ~FGetBuildAliasRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetBuildRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of the build to get.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FGetBuildRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags()
            {}

        FGetBuildRequest(const FGetBuildRequest& src) = default;

        FGetBuildRequest(const TSharedPtr<FJsonObject>& obj) : FGetBuildRequest()
        {
            readFromValue(obj);
        }

        ~FGetBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetBuildResponse : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] When true, assets will not be copied for each server inside the VM. All serverswill run from the same set of assets, or
         * will have the same assets mounted in the container.
         */
        Boxed<bool> AreAssetsReadonly;

        // [optional] The guid string build ID of the build.
        FString BuildId;

        // [optional] The build name.
        FString BuildName;

        // [optional] The current build status. Valid values are - Deploying, Deployed, DeletingRegion, Unhealthy.
        FString BuildStatus;

        // [optional] The flavor of container of he build.
        Boxed<ContainerFlavor> pfContainerFlavor;

        /**
         * [optional] The container command to run when the multiplayer server has been allocated, including any arguments. This only applies
         * to custom builds. If the build is a managed build, this field will be null.
         */
        FString ContainerRunCommand;

        // [optional] The time the build was created in UTC.
        Boxed<FDateTime> CreationTime;

        // [optional] The custom game container image for a custom build.
        TSharedPtr<FContainerImageReference> CustomGameContainerImage;

        // [optional] The game assets for the build.
        TArray<FAssetReference> GameAssetReferences;
        // [optional] The game certificates for the build.
        TArray<FGameCertificateReference> GameCertificateReferences;
        // [optional] The instrumentation configuration of the build.
        TSharedPtr<FInstrumentationConfiguration> pfInstrumentationConfiguration;

        /**
         * [optional] Metadata of the build. The keys are case insensitive. The build metadata is made available to the server through Game
         * Server SDK (GSDK).
         */
        TMap<FString, FString> Metadata;
        // The number of multiplayer servers to hosted on a single VM of the build.
        int32 MultiplayerServerCountPerVm;

        // [optional] The OS platform used for running the game process.
        FString OsPlatform;

        // [optional] The ports the build is mapped on.
        TArray<FPort> Ports;
        // [optional] The region configuration for the build.
        TArray<FBuildRegion> RegionConfigurations;
        // [optional] The resource constraints to apply to each server on the VM.
        TSharedPtr<FServerResourceConstraintParams> ServerResourceConstraints;

        // [optional] The type of game server being hosted.
        FString ServerType;

        /**
         * [optional] The command to run when the multiplayer server has been allocated, including any arguments. This only applies to managed
         * builds. If the build is a custom build, this field will be null.
         */
        FString StartMultiplayerServerCommand;

        // [optional] The VM size the build was created on.
        Boxed<AzureVmSize> VmSize;

        // [optional] The configuration for the VmStartupScript feature for the build
        TSharedPtr<FVmStartupScriptConfiguration> pfVmStartupScriptConfiguration;

        FGetBuildResponse() :
            FPlayFabCppResultCommon(),
            AreAssetsReadonly(),
            BuildId(),
            BuildName(),
            BuildStatus(),
            pfContainerFlavor(),
            ContainerRunCommand(),
            CreationTime(),
            CustomGameContainerImage(nullptr),
            GameAssetReferences(),
            GameCertificateReferences(),
            pfInstrumentationConfiguration(nullptr),
            Metadata(),
            MultiplayerServerCountPerVm(0),
            OsPlatform(),
            Ports(),
            RegionConfigurations(),
            ServerResourceConstraints(nullptr),
            ServerType(),
            StartMultiplayerServerCommand(),
            VmSize(),
            pfVmStartupScriptConfiguration(nullptr)
            {}

        FGetBuildResponse(const FGetBuildResponse& src) = default;

        FGetBuildResponse(const TSharedPtr<FJsonObject>& obj) : FGetBuildResponse()
        {
            readFromValue(obj);
        }

        ~FGetBuildResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContainerRegistryCredentialsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FGetContainerRegistryCredentialsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FGetContainerRegistryCredentialsRequest(const FGetContainerRegistryCredentialsRequest& src) = default;

        FGetContainerRegistryCredentialsRequest(const TSharedPtr<FJsonObject>& obj) : FGetContainerRegistryCredentialsRequest()
        {
            readFromValue(obj);
        }

        ~FGetContainerRegistryCredentialsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetContainerRegistryCredentialsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The url of the container registry.
        FString DnsName;

        // [optional] The password for accessing the container registry.
        FString Password;

        // [optional] The username for accessing the container registry.
        FString Username;

        FGetContainerRegistryCredentialsResponse() :
            FPlayFabCppResultCommon(),
            DnsName(),
            Password(),
            Username()
            {}

        FGetContainerRegistryCredentialsResponse(const FGetContainerRegistryCredentialsResponse& src) = default;

        FGetContainerRegistryCredentialsResponse(const TSharedPtr<FJsonObject>& obj) : FGetContainerRegistryCredentialsResponse()
        {
            readFromValue(obj);
        }

        ~FGetContainerRegistryCredentialsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The id of the lobby.
        FString LobbyId;

        FGetLobbyRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId()
            {}

        FGetLobbyRequest(const FGetLobbyRequest& src) = default;

        FGetLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FGetLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FGetLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLobbyServer : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Opaque string, stored on a Subscribe call, which indicates the connection a joined server has with PubSub.
        FString PubSubConnectionHandle;

        // [optional] Key-value pairs specific to the joined server.
        TMap<FString, FString> ServerData;
        // [optional] The server entity key.
        TSharedPtr<FEntityKey> ServerEntity;

        FLobbyServer() :
            FPlayFabCppBaseModel(),
            PubSubConnectionHandle(),
            ServerData(),
            ServerEntity(nullptr)
            {}

        FLobbyServer(const FLobbyServer& src) = default;

        FLobbyServer(const TSharedPtr<FJsonObject>& obj) : FLobbyServer()
        {
            readFromValue(obj);
        }

        ~FLobbyServer();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLobby : public PlayFab::FPlayFabCppBaseModel
    {
        // A setting indicating who is allowed to join this lobby, as well as see it in queries.
        AccessPolicy pfAccessPolicy;

        // A number that increments once for each request that modifies the lobby.
        uint32 ChangeNumber;

        /**
         * A string used to join the lobby. This field is populated by the Lobby service. Invites are performed by communicating
         * this connectionString to other players.
         */
        FString ConnectionString;

        // [optional] Lobby data.
        TMap<FString, FString> LobbyData;
        // Id to uniquely identify a lobby.
        FString LobbyId;

        // The maximum number of players allowed in the lobby.
        uint32 MaxPlayers;

        // [optional] Array of all lobby members.
        TArray<FMember> Members;
        // A setting indicating whether members are allowed to join this lobby. When Locked new members are prevented from joining.
        MembershipLock pfMembershipLock;

        // [optional] The client or server entity which owns this lobby.
        TSharedPtr<FEntityKey> Owner;

        // [optional] A setting indicating the owner migration policy. If server owned, this field is not present.
        Boxed<OwnerMigrationPolicy> pfOwnerMigrationPolicy;

        /**
         * [optional] An opaque string stored on a SubscribeToLobbyResource call, which indicates the connection an owner or member has with
         * PubSub.
         */
        FString PubSubConnectionHandle;

        // [optional] Search data.
        TMap<FString, FString> SearchData;
        // [optional] Preview: Lobby joined server. This is not the server owner, rather the server that has joined a client owned lobby.
        TSharedPtr<FLobbyServer> Server;

        // A flag which determines if connections are used. Defaults to true. Only set on create.
        bool UseConnections;

        FLobby() :
            FPlayFabCppBaseModel(),
            pfAccessPolicy(),
            ChangeNumber(0),
            ConnectionString(),
            LobbyData(),
            LobbyId(),
            MaxPlayers(0),
            Members(),
            pfMembershipLock(),
            Owner(nullptr),
            pfOwnerMigrationPolicy(),
            PubSubConnectionHandle(),
            SearchData(),
            Server(nullptr),
            UseConnections(false)
            {}

        FLobby(const FLobby& src) = default;

        FLobby(const TSharedPtr<FJsonObject>& obj) : FLobby()
        {
            readFromValue(obj);
        }

        ~FLobby();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetLobbyResult : public PlayFab::FPlayFabCppResultCommon
    {
        // The information pertaining to the requested lobby.
        FLobby pfLobby;

        FGetLobbyResult() :
            FPlayFabCppResultCommon(),
            pfLobby()
            {}

        FGetLobbyResult(const FGetLobbyResult& src) = default;

        FGetLobbyResult(const TSharedPtr<FJsonObject>& obj) : FGetLobbyResult()
        {
            readFromValue(obj);
        }

        ~FGetLobbyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchmakingTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * Determines whether the matchmaking attributes will be returned as an escaped JSON string or as an un-escaped JSON
         * object.
         */
        bool EscapeObject;

        // The name of the queue to find a match for.
        FString QueueName;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FGetMatchmakingTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            EscapeObject(false),
            QueueName(),
            TicketId()
            {}

        FGetMatchmakingTicketRequest(const FGetMatchmakingTicketRequest& src) = default;

        FGetMatchmakingTicketRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakingTicketRequest()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakingTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchmakingTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] The reason why the current ticket was canceled. This field is only set if the ticket is in canceled state. Please retry
         * if CancellationReason is RetryRequired.
         */
        FString CancellationReasonString;

        // [optional] Change number used for differentiating older matchmaking status updates from newer ones.
        Boxed<uint32> ChangeNumber;

        // The server date and time at which ticket was created.
        FDateTime Created;

        // The Creator's entity key.
        FEntityKey Creator;

        // How long to attempt matching this ticket in seconds.
        int32 GiveUpAfterSeconds;

        // [optional] The Id of a match.
        FString MatchId;

        // A list of Users that have joined this ticket.
        TArray<FMatchmakingPlayer> Members;
        // [optional] A list of PlayFab Ids of Users to match with.
        TArray<FEntityKey> MembersToMatchWith;
        // The Id of a match queue.
        FString QueueName;

        /**
         * The current ticket status. Possible values are: WaitingForPlayers, WaitingForMatch, WaitingForServer, Canceled and
         * Matched.
         */
        FString Status;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FGetMatchmakingTicketResult() :
            FPlayFabCppResultCommon(),
            CancellationReasonString(),
            ChangeNumber(),
            Created(0),
            Creator(),
            GiveUpAfterSeconds(0),
            MatchId(),
            Members(),
            MembersToMatchWith(),
            QueueName(),
            Status(),
            TicketId()
            {}

        FGetMatchmakingTicketResult(const FGetMatchmakingTicketResult& src) = default;

        FGetMatchmakingTicketResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakingTicketResult()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakingTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * Determines whether the matchmaking attributes will be returned as an escaped JSON string or as an un-escaped JSON
         * object.
         */
        bool EscapeObject;

        // The Id of a match.
        FString MatchId;

        // The name of the queue to join.
        FString QueueName;

        // Determines whether the matchmaking attributes for each user should be returned in the response for match request.
        bool ReturnMemberAttributes;

        FGetMatchRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            EscapeObject(false),
            MatchId(),
            QueueName(),
            ReturnMemberAttributes(false)
            {}

        FGetMatchRequest(const FGetMatchRequest& src) = default;

        FGetMatchRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchRequest()
        {
            readFromValue(obj);
        }

        ~FGetMatchRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMatchResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] A string that is used by players that are matched together to join an arranged lobby.
        FString ArrangementString;

        // The Id of a match.
        FString MatchId;

        // A list of Users that are matched together, along with their team assignments.
        TArray<FMatchmakingPlayerWithTeamAssignment> Members;
        /**
         * [optional] A list of regions that the match could be played in sorted by preference. This value is only set if the queue has a
         * region selection rule.
         */
        TArray<FString> RegionPreferences;
        // [optional] The details of the server that the match has been allocated to.
        TSharedPtr<FServerDetails> pfServerDetails;

        FGetMatchResult() :
            FPlayFabCppResultCommon(),
            ArrangementString(),
            MatchId(),
            Members(),
            RegionPreferences(),
            pfServerDetails(nullptr)
            {}

        FGetMatchResult(const FGetMatchResult& src) = default;

        FGetMatchResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchResult()
        {
            readFromValue(obj);
        }

        ~FGetMatchResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerServerDetailsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * The title generated guid string session ID of the multiplayer server to get details for. This is to keep track of
         * multiplayer server sessions.
         */
        FString SessionId;

        FGetMultiplayerServerDetailsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            SessionId()
            {}

        FGetMultiplayerServerDetailsRequest(const FGetMultiplayerServerDetailsRequest& src) = default;

        FGetMultiplayerServerDetailsRequest(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerServerDetailsRequest()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerServerDetailsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FPublicIpAddress : public PlayFab::FPlayFabCppBaseModel
    {
        // FQDN of the public IP
        FString FQDN;

        // Server IP Address
        FString IpAddress;

        // Routing Type of the public IP.
        FString RoutingType;

        FPublicIpAddress() :
            FPlayFabCppBaseModel(),
            FQDN(),
            IpAddress(),
            RoutingType()
            {}

        FPublicIpAddress(const FPublicIpAddress& src) = default;

        FPublicIpAddress(const TSharedPtr<FJsonObject>& obj) : FPublicIpAddress()
        {
            readFromValue(obj);
        }

        ~FPublicIpAddress();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerServerDetailsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The identity of the build in which the server was allocated.
        FString BuildId;

        // [optional] The connected players in the multiplayer server.
        TArray<FConnectedPlayer> ConnectedPlayers;
        // [optional] The fully qualified domain name of the virtual machine that is hosting this multiplayer server.
        FString FQDN;

        // [optional] The public IPv4 address of the virtual machine that is hosting this multiplayer server.
        FString IPV4Address;

        // [optional] The time (UTC) at which a change in the multiplayer server state was observed.
        Boxed<FDateTime> LastStateTransitionTime;

        // [optional] The ports the multiplayer server uses.
        TArray<FPort> Ports;
        // [optional] The list of public Ipv4 addresses associated with the server.
        TArray<FPublicIpAddress> PublicIPV4Addresses;
        // [optional] The region the multiplayer server is located in.
        FString Region;

        // [optional] The string server ID of the multiplayer server generated by PlayFab.
        FString ServerId;

        // [optional] The guid string session ID of the multiplayer server.
        FString SessionId;

        // [optional] The state of the multiplayer server.
        FString State;

        // [optional] The virtual machine ID that the multiplayer server is located on.
        FString VmId;

        FGetMultiplayerServerDetailsResponse() :
            FPlayFabCppResultCommon(),
            BuildId(),
            ConnectedPlayers(),
            FQDN(),
            IPV4Address(),
            LastStateTransitionTime(),
            Ports(),
            PublicIPV4Addresses(),
            Region(),
            ServerId(),
            SessionId(),
            State(),
            VmId()
            {}

        FGetMultiplayerServerDetailsResponse(const FGetMultiplayerServerDetailsResponse& src) = default;

        FGetMultiplayerServerDetailsResponse(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerServerDetailsResponse()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerServerDetailsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerServerLogsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The server ID of multiplayer server to get logs for.
        FString ServerId;

        FGetMultiplayerServerLogsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            ServerId()
            {}

        FGetMultiplayerServerLogsRequest(const FGetMultiplayerServerLogsRequest& src) = default;

        FGetMultiplayerServerLogsRequest(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerServerLogsRequest()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerServerLogsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerServerLogsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] URL for logs download.
        FString LogDownloadUrl;

        FGetMultiplayerServerLogsResponse() :
            FPlayFabCppResultCommon(),
            LogDownloadUrl()
            {}

        FGetMultiplayerServerLogsResponse(const FGetMultiplayerServerLogsResponse& src) = default;

        FGetMultiplayerServerLogsResponse(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerServerLogsResponse()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerServerLogsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetMultiplayerSessionLogsBySessionIdRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The server ID of multiplayer server to get logs for.
        FString SessionId;

        FGetMultiplayerSessionLogsBySessionIdRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            SessionId()
            {}

        FGetMultiplayerSessionLogsBySessionIdRequest(const FGetMultiplayerSessionLogsBySessionIdRequest& src) = default;

        FGetMultiplayerSessionLogsBySessionIdRequest(const TSharedPtr<FJsonObject>& obj) : FGetMultiplayerSessionLogsBySessionIdRequest()
        {
            readFromValue(obj);
        }

        ~FGetMultiplayerSessionLogsBySessionIdRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetQueueStatisticsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The name of the queue.
        FString QueueName;

        FGetQueueStatisticsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            QueueName()
            {}

        FGetQueueStatisticsRequest(const FGetQueueStatisticsRequest& src) = default;

        FGetQueueStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetQueueStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FGetQueueStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FStatistics : public PlayFab::FPlayFabCppBaseModel
    {
        // The average.
        double Average;

        // The 50th percentile.
        double Percentile50;

        // The 90th percentile.
        double Percentile90;

        // The 99th percentile.
        double Percentile99;

        FStatistics() :
            FPlayFabCppBaseModel(),
            Average(0),
            Percentile50(0),
            Percentile90(0),
            Percentile99(0)
            {}

        FStatistics(const FStatistics& src) = default;

        FStatistics(const TSharedPtr<FJsonObject>& obj) : FStatistics()
        {
            readFromValue(obj);
        }

        ~FStatistics();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetQueueStatisticsResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The current number of players in the matchmaking queue, who are waiting to be matched.
        Boxed<uint32> NumberOfPlayersMatching;

        // [optional] Statistics representing the time (in seconds) it takes for tickets to find a match.
        TSharedPtr<FStatistics> TimeToMatchStatisticsInSeconds;

        FGetQueueStatisticsResult() :
            FPlayFabCppResultCommon(),
            NumberOfPlayersMatching(),
            TimeToMatchStatisticsInSeconds(nullptr)
            {}

        FGetQueueStatisticsResult(const FGetQueueStatisticsResult& src) = default;

        FGetQueueStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetQueueStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FGetQueueStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetRemoteLoginEndpointRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of the multiplayer server to get remote login information for.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The region of the multiplayer server to get remote login information for.
        FString Region;

        // The virtual machine ID the multiplayer server is located on.
        FString VmId;

        FGetRemoteLoginEndpointRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags(),
            Region(),
            VmId()
            {}

        FGetRemoteLoginEndpointRequest(const FGetRemoteLoginEndpointRequest& src) = default;

        FGetRemoteLoginEndpointRequest(const TSharedPtr<FJsonObject>& obj) : FGetRemoteLoginEndpointRequest()
        {
            readFromValue(obj);
        }

        ~FGetRemoteLoginEndpointRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetRemoteLoginEndpointResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The remote login IPV4 address of multiplayer server.
        FString IPV4Address;

        // The remote login port of multiplayer server.
        int32 Port;

        FGetRemoteLoginEndpointResponse() :
            FPlayFabCppResultCommon(),
            IPV4Address(),
            Port(0)
            {}

        FGetRemoteLoginEndpointResponse(const FGetRemoteLoginEndpointResponse& src) = default;

        FGetRemoteLoginEndpointResponse(const TSharedPtr<FJsonObject>& obj) : FGetRemoteLoginEndpointResponse()
        {
            readFromValue(obj);
        }

        ~FGetRemoteLoginEndpointResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetServerBackfillTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * Determines whether the matchmaking attributes will be returned as an escaped JSON string or as an un-escaped JSON
         * object.
         */
        bool EscapeObject;

        // The name of the queue to find a match for.
        FString QueueName;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FGetServerBackfillTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            EscapeObject(false),
            QueueName(),
            TicketId()
            {}

        FGetServerBackfillTicketRequest(const FGetServerBackfillTicketRequest& src) = default;

        FGetServerBackfillTicketRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBackfillTicketRequest()
        {
            readFromValue(obj);
        }

        ~FGetServerBackfillTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetServerBackfillTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The reason why the current ticket was canceled. This field is only set if the ticket is in canceled state.
        FString CancellationReasonString;

        // The server date and time at which ticket was created.
        FDateTime Created;

        // How long to attempt matching this ticket in seconds.
        int32 GiveUpAfterSeconds;

        // [optional] The Id of a match.
        FString MatchId;

        // A list of Users that are part of this ticket, along with their team assignments.
        TArray<FMatchmakingPlayerWithTeamAssignment> Members;
        // The Id of a match queue.
        FString QueueName;

        // The details of the server the members are connected to.
        FServerDetails pfServerDetails;

        // The current ticket status. Possible values are: WaitingForMatch, Canceled and Matched.
        FString Status;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FGetServerBackfillTicketResult() :
            FPlayFabCppResultCommon(),
            CancellationReasonString(),
            Created(0),
            GiveUpAfterSeconds(0),
            MatchId(),
            Members(),
            QueueName(),
            pfServerDetails(),
            Status(),
            TicketId()
            {}

        FGetServerBackfillTicketResult(const FGetServerBackfillTicketResult& src) = default;

        FGetServerBackfillTicketResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBackfillTicketResult()
        {
            readFromValue(obj);
        }

        ~FGetServerBackfillTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleEnabledForMultiplayerServersStatusRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FGetTitleEnabledForMultiplayerServersStatusRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FGetTitleEnabledForMultiplayerServersStatusRequest(const FGetTitleEnabledForMultiplayerServersStatusRequest& src) = default;

        FGetTitleEnabledForMultiplayerServersStatusRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleEnabledForMultiplayerServersStatusRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleEnabledForMultiplayerServersStatusRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleEnabledForMultiplayerServersStatusResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The enabled status for the multiplayer server features for the title.
        Boxed<TitleMultiplayerServerEnabledStatus> Status;

        FGetTitleEnabledForMultiplayerServersStatusResponse() :
            FPlayFabCppResultCommon(),
            Status()
            {}

        FGetTitleEnabledForMultiplayerServersStatusResponse(const FGetTitleEnabledForMultiplayerServersStatusResponse& src) = default;

        FGetTitleEnabledForMultiplayerServersStatusResponse(const TSharedPtr<FJsonObject>& obj) : FGetTitleEnabledForMultiplayerServersStatusResponse()
        {
            readFromValue(obj);
        }

        ~FGetTitleEnabledForMultiplayerServersStatusResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleMultiplayerServersQuotaChangeRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // Id of the change request to get.
        FString RequestId;

        FGetTitleMultiplayerServersQuotaChangeRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            RequestId()
            {}

        FGetTitleMultiplayerServersQuotaChangeRequest(const FGetTitleMultiplayerServersQuotaChangeRequest& src) = default;

        FGetTitleMultiplayerServersQuotaChangeRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleMultiplayerServersQuotaChangeRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleMultiplayerServersQuotaChangeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FQuotaChange : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] A brief description of the requested changes.
        FString ChangeDescription;

        // [optional] Requested changes to make to the titles cores quota.
        TArray<FCoreCapacityChange> Changes;
        // Whether or not this request is pending a review.
        bool IsPendingReview;

        // [optional] Additional information about this request that our team can use to better understand the requirements.
        FString Notes;

        // [optional] Id of the change request.
        FString RequestId;

        // [optional] Comments by our team when a request is reviewed.
        FString ReviewComments;

        // Whether or not this request was approved.
        bool WasApproved;

        FQuotaChange() :
            FPlayFabCppBaseModel(),
            ChangeDescription(),
            Changes(),
            IsPendingReview(false),
            Notes(),
            RequestId(),
            ReviewComments(),
            WasApproved(false)
            {}

        FQuotaChange(const FQuotaChange& src) = default;

        FQuotaChange(const TSharedPtr<FJsonObject>& obj) : FQuotaChange()
        {
            readFromValue(obj);
        }

        ~FQuotaChange();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleMultiplayerServersQuotaChangeResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The change request for this title.
        TSharedPtr<FQuotaChange> Change;

        FGetTitleMultiplayerServersQuotaChangeResponse() :
            FPlayFabCppResultCommon(),
            Change(nullptr)
            {}

        FGetTitleMultiplayerServersQuotaChangeResponse(const FGetTitleMultiplayerServersQuotaChangeResponse& src) = default;

        FGetTitleMultiplayerServersQuotaChangeResponse(const TSharedPtr<FJsonObject>& obj) : FGetTitleMultiplayerServersQuotaChangeResponse()
        {
            readFromValue(obj);
        }

        ~FGetTitleMultiplayerServersQuotaChangeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleMultiplayerServersQuotasRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FGetTitleMultiplayerServersQuotasRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FGetTitleMultiplayerServersQuotasRequest(const FGetTitleMultiplayerServersQuotasRequest& src) = default;

        FGetTitleMultiplayerServersQuotasRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleMultiplayerServersQuotasRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleMultiplayerServersQuotasRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FTitleMultiplayerServersQuotas : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The core capacity for the various regions and VM Family
        TArray<FCoreCapacity> CoreCapacities;
        FTitleMultiplayerServersQuotas() :
            FPlayFabCppBaseModel(),
            CoreCapacities()
            {}

        FTitleMultiplayerServersQuotas(const FTitleMultiplayerServersQuotas& src) = default;

        FTitleMultiplayerServersQuotas(const TSharedPtr<FJsonObject>& obj) : FTitleMultiplayerServersQuotas()
        {
            readFromValue(obj);
        }

        ~FTitleMultiplayerServersQuotas();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FGetTitleMultiplayerServersQuotasResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The various quotas for multiplayer servers for the title.
        TSharedPtr<FTitleMultiplayerServersQuotas> Quotas;

        FGetTitleMultiplayerServersQuotasResponse() :
            FPlayFabCppResultCommon(),
            Quotas(nullptr)
            {}

        FGetTitleMultiplayerServersQuotasResponse(const FGetTitleMultiplayerServersQuotasResponse& src) = default;

        FGetTitleMultiplayerServersQuotasResponse(const TSharedPtr<FJsonObject>& obj) : FGetTitleMultiplayerServersQuotasResponse()
        {
            readFromValue(obj);
        }

        ~FGetTitleMultiplayerServersQuotasResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FInviteToLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The entity invited to the lobby.
        TSharedPtr<FEntityKey> InviteeEntity;

        // [optional] The id of the lobby.
        FString LobbyId;

        // [optional] The member entity sending the invite. Must be a member of the lobby.
        TSharedPtr<FEntityKey> MemberEntity;

        FInviteToLobbyRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            InviteeEntity(nullptr),
            LobbyId(),
            MemberEntity(nullptr)
            {}

        FInviteToLobbyRequest(const FInviteToLobbyRequest& src) = default;

        FInviteToLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FInviteToLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FInviteToLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinArrangedLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] The policy indicating who is allowed to join the lobby, and the visibility to queries. May be 'Public', 'Friends' or
         * 'Private'. Public means the lobby is both visible in queries and any player may join, including invited players. Friends
         * means that users who are bidirectional friends of members in the lobby may search to find friend lobbies, to retrieve
         * its connection string. Private means the lobby is not visible in queries, and a player must receive an invitation to
         * join. Defaults to 'Public' on creation. Can only be changed by the lobby owner.
         */
        Boxed<AccessPolicy> pfAccessPolicy;

        /**
         * A field which indicates which lobby the user will be joining. This field is opaque to everyone except the Lobby service
         * and the creator of the arrangementString (Matchmaking). This string defines a unique identifier for the arranged lobby
         * as well as the title and member the string is valid for. Arrangement strings have an expiration.
         */
        FString ArrangementString;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The maximum number of players allowed in the lobby. The value must be between 2 and 128.
        uint32 MaxPlayers;

        /**
         * [optional] The private key-value pairs used by the member to communicate information to other members and the owner. Visible to all
         * entities in the lobby. At most 30 key-value pairs may be stored here, keys are limited to 30 characters and values to
         * 1000. The total size of all memberData values may not exceed 4096 bytes. Keys are case sensitive.
         */
        TMap<FString, FString> MemberData;
        // The member entity who is joining the lobby. The first member to join will be the lobby owner.
        FEntityKey MemberEntity;

        /**
         * [optional] The policy for how a new owner is chosen. May be 'Automatic', 'Manual' or 'None'. Can only be specified by clients. If
         * client-owned and 'Automatic' - The Lobby service will automatically assign another connected owner when the current
         * owner leaves or disconnects. The useConnections property must be true. If client - owned and 'Manual' - Ownership is
         * protected as long as the current owner is connected. If the current owner leaves or disconnects any member may set
         * themselves as the current owner. The useConnections property must be true. If client-owned and 'None' - Any member can
         * set ownership. The useConnections property can be either true or false.
         */
        Boxed<OwnerMigrationPolicy> pfOwnerMigrationPolicy;

        /**
         * A setting to control whether connections are used. Defaults to true. When true, notifications are sent to subscribed
         * players, disconnect detection removes connectionHandles, only owner migration policies using connections are allowed,
         * and lobbies must have at least one connected member to be searchable or be a server hosted lobby with a connected
         * server. If false, then notifications are not sent, connections are not allowed, and lobbies do not need connections to
         * be searchable.
         */
        bool UseConnections;

        FJoinArrangedLobbyRequest() :
            FPlayFabCppRequestCommon(),
            pfAccessPolicy(),
            ArrangementString(),
            CustomTags(),
            MaxPlayers(0),
            MemberData(),
            MemberEntity(),
            pfOwnerMigrationPolicy(),
            UseConnections(false)
            {}

        FJoinArrangedLobbyRequest(const FJoinArrangedLobbyRequest& src) = default;

        FJoinArrangedLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FJoinArrangedLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FJoinArrangedLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinLobbyAsServerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * A field which indicates which lobby the game_server will be joining. This field is opaque to everyone except the Lobby
         * service.
         */
        FString ConnectionString;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] The private key-value pairs which are visible to all entities in the lobby but can only be modified by the joined
         * server.At most 30 key - value pairs may be stored here, keys are limited to 30 characters and values to 1000.The total
         * size of all serverData values may not exceed 4096 bytes.
         */
        TMap<FString, FString> ServerData;
        /**
         * The game_server entity which is joining the Lobby. If a different game_server entity has already joined the request will
         * fail unless the joined entity is disconnected, in which case the incoming game_server entity will replace the
         * disconnected entity.
         */
        FEntityKey ServerEntity;

        FJoinLobbyAsServerRequest() :
            FPlayFabCppRequestCommon(),
            ConnectionString(),
            CustomTags(),
            ServerData(),
            ServerEntity()
            {}

        FJoinLobbyAsServerRequest(const FJoinLobbyAsServerRequest& src) = default;

        FJoinLobbyAsServerRequest(const TSharedPtr<FJsonObject>& obj) : FJoinLobbyAsServerRequest()
        {
            readFromValue(obj);
        }

        ~FJoinLobbyAsServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinLobbyAsServerResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Successfully joined lobby's id.
        FString LobbyId;

        FJoinLobbyAsServerResult() :
            FPlayFabCppResultCommon(),
            LobbyId()
            {}

        FJoinLobbyAsServerResult(const FJoinLobbyAsServerResult& src) = default;

        FJoinLobbyAsServerResult(const TSharedPtr<FJsonObject>& obj) : FJoinLobbyAsServerResult()
        {
            readFromValue(obj);
        }

        ~FJoinLobbyAsServerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] A field which indicates which lobby the user will be joining. This field is opaque to everyone except the Lobby service.
        FString ConnectionString;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] The private key-value pairs used by the member to communicate information to other members and the owner. Visible to all
         * entities in the lobby. At most 30 key-value pairs may be stored here, keys are limited to 30 characters and values to
         * 1000. The total size of all memberData values may not exceed 4096 bytes.Keys are case sensitive.
         */
        TMap<FString, FString> MemberData;
        // [optional] The member entity who is joining the lobby.
        TSharedPtr<FEntityKey> MemberEntity;

        FJoinLobbyRequest() :
            FPlayFabCppRequestCommon(),
            ConnectionString(),
            CustomTags(),
            MemberData(),
            MemberEntity(nullptr)
            {}

        FJoinLobbyRequest(const FJoinLobbyRequest& src) = default;

        FJoinLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FJoinLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FJoinLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinLobbyResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Successfully joined lobby's id.
        FString LobbyId;

        FJoinLobbyResult() :
            FPlayFabCppResultCommon(),
            LobbyId()
            {}

        FJoinLobbyResult(const FJoinLobbyResult& src) = default;

        FJoinLobbyResult(const TSharedPtr<FJsonObject>& obj) : FJoinLobbyResult()
        {
            readFromValue(obj);
        }

        ~FJoinLobbyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinMatchmakingTicketRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The User who wants to join the ticket. Their Id must be listed in PlayFabIdsToMatchWith.
        FMatchmakingPlayer Member;

        // The name of the queue to join.
        FString QueueName;

        // The Id of the ticket to find a match for.
        FString TicketId;

        FJoinMatchmakingTicketRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Member(),
            QueueName(),
            TicketId()
            {}

        FJoinMatchmakingTicketRequest(const FJoinMatchmakingTicketRequest& src) = default;

        FJoinMatchmakingTicketRequest(const TSharedPtr<FJsonObject>& obj) : FJoinMatchmakingTicketRequest()
        {
            readFromValue(obj);
        }

        ~FJoinMatchmakingTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FJoinMatchmakingTicketResult : public PlayFab::FPlayFabCppResultCommon
    {
        FJoinMatchmakingTicketResult() :
            FPlayFabCppResultCommon()
            {}

        FJoinMatchmakingTicketResult(const FJoinMatchmakingTicketResult& src) = default;

        FJoinMatchmakingTicketResult(const TSharedPtr<FJsonObject>& obj) : FJoinMatchmakingTicketResult()
        {
            readFromValue(obj);
        }

        ~FJoinMatchmakingTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLeaveLobbyAsServerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The id of the lobby.
        FString LobbyId;

        /**
         * The game_server entity leaving the lobby. If the game_server was subscribed to notifications, it will be unsubscribed.
         * If a the given game_server entity is not in the lobby, it will fail.
         */
        FEntityKey ServerEntity;

        FLeaveLobbyAsServerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId(),
            ServerEntity()
            {}

        FLeaveLobbyAsServerRequest(const FLeaveLobbyAsServerRequest& src) = default;

        FLeaveLobbyAsServerRequest(const TSharedPtr<FJsonObject>& obj) : FLeaveLobbyAsServerRequest()
        {
            readFromValue(obj);
        }

        ~FLeaveLobbyAsServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLeaveLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The id of the lobby.
        FString LobbyId;

        // [optional] The member entity leaving the lobby.
        TSharedPtr<FEntityKey> MemberEntity;

        FLeaveLobbyRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId(),
            MemberEntity(nullptr)
            {}

        FLeaveLobbyRequest(const FLeaveLobbyRequest& src) = default;

        FLeaveLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FLeaveLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FLeaveLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListAssetSummariesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListAssetSummariesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PageSize(),
            SkipToken()
            {}

        FListAssetSummariesRequest(const FListAssetSummariesRequest& src) = default;

        FListAssetSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListAssetSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListAssetSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListAssetSummariesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of asset summaries.
        TArray<FAssetSummary> AssetSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListAssetSummariesResponse() :
            FPlayFabCppResultCommon(),
            AssetSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListAssetSummariesResponse(const FListAssetSummariesResponse& src) = default;

        FListAssetSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListAssetSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListAssetSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildAliasesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListBuildAliasesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PageSize(),
            SkipToken()
            {}

        FListBuildAliasesRequest(const FListBuildAliasesRequest& src) = default;

        FListBuildAliasesRequest(const TSharedPtr<FJsonObject>& obj) : FListBuildAliasesRequest()
        {
            readFromValue(obj);
        }

        ~FListBuildAliasesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildAliasesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of build aliases for the title
        TArray<FBuildAliasDetailsResponse> BuildAliases;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListBuildAliasesResponse() :
            FPlayFabCppResultCommon(),
            BuildAliases(),
            PageSize(0),
            SkipToken()
            {}

        FListBuildAliasesResponse(const FListBuildAliasesResponse& src) = default;

        FListBuildAliasesResponse(const TSharedPtr<FJsonObject>& obj) : FListBuildAliasesResponse()
        {
            readFromValue(obj);
        }

        ~FListBuildAliasesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildSummariesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListBuildSummariesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PageSize(),
            SkipToken()
            {}

        FListBuildSummariesRequest(const FListBuildSummariesRequest& src) = default;

        FListBuildSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListBuildSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListBuildSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListBuildSummariesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of build summaries for a title.
        TArray<FBuildSummary> BuildSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListBuildSummariesResponse() :
            FPlayFabCppResultCommon(),
            BuildSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListBuildSummariesResponse(const FListBuildSummariesResponse& src) = default;

        FListBuildSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListBuildSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListBuildSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListCertificateSummariesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListCertificateSummariesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PageSize(),
            SkipToken()
            {}

        FListCertificateSummariesRequest(const FListCertificateSummariesRequest& src) = default;

        FListCertificateSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListCertificateSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListCertificateSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListCertificateSummariesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of game certificates.
        TArray<FCertificateSummary> CertificateSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListCertificateSummariesResponse() :
            FPlayFabCppResultCommon(),
            CertificateSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListCertificateSummariesResponse(const FListCertificateSummariesResponse& src) = default;

        FListCertificateSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListCertificateSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListCertificateSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImagesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListContainerImagesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            PageSize(),
            SkipToken()
            {}

        FListContainerImagesRequest(const FListContainerImagesRequest& src) = default;

        FListContainerImagesRequest(const TSharedPtr<FJsonObject>& obj) : FListContainerImagesRequest()
        {
            readFromValue(obj);
        }

        ~FListContainerImagesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImagesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of container images.
        TArray<FString> Images;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListContainerImagesResponse() :
            FPlayFabCppResultCommon(),
            Images(),
            PageSize(0),
            SkipToken()
            {}

        FListContainerImagesResponse(const FListContainerImagesResponse& src) = default;

        FListContainerImagesResponse(const TSharedPtr<FJsonObject>& obj) : FListContainerImagesResponse()
        {
            readFromValue(obj);
        }

        ~FListContainerImagesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImageTagsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The container images we want to list tags for.
        FString ImageName;

        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListContainerImageTagsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            ImageName(),
            PageSize(),
            SkipToken()
            {}

        FListContainerImageTagsRequest(const FListContainerImageTagsRequest& src) = default;

        FListContainerImageTagsRequest(const TSharedPtr<FJsonObject>& obj) : FListContainerImageTagsRequest()
        {
            readFromValue(obj);
        }

        ~FListContainerImageTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListContainerImageTagsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        // [optional] The list of tags for a particular container image.
        TArray<FString> Tags;
        FListContainerImageTagsResponse() :
            FPlayFabCppResultCommon(),
            PageSize(0),
            SkipToken(),
            Tags()
            {}

        FListContainerImageTagsResponse(const FListContainerImageTagsResponse& src) = default;

        FListContainerImageTagsResponse(const TSharedPtr<FJsonObject>& obj) : FListContainerImageTagsResponse()
        {
            readFromValue(obj);
        }

        ~FListContainerImageTagsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListMatchmakingTicketsForPlayerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The entity key for which to find the ticket Ids.
        TSharedPtr<FEntityKey> Entity;

        // The name of the queue to find a match for.
        FString QueueName;

        FListMatchmakingTicketsForPlayerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Entity(nullptr),
            QueueName()
            {}

        FListMatchmakingTicketsForPlayerRequest(const FListMatchmakingTicketsForPlayerRequest& src) = default;

        FListMatchmakingTicketsForPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FListMatchmakingTicketsForPlayerRequest()
        {
            readFromValue(obj);
        }

        ~FListMatchmakingTicketsForPlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListMatchmakingTicketsForPlayerResult : public PlayFab::FPlayFabCppResultCommon
    {
        // The list of ticket Ids the user is a member of.
        TArray<FString> TicketIds;
        FListMatchmakingTicketsForPlayerResult() :
            FPlayFabCppResultCommon(),
            TicketIds()
            {}

        FListMatchmakingTicketsForPlayerResult(const FListMatchmakingTicketsForPlayerResult& src) = default;

        FListMatchmakingTicketsForPlayerResult(const TSharedPtr<FJsonObject>& obj) : FListMatchmakingTicketsForPlayerResult()
        {
            readFromValue(obj);
        }

        ~FListMatchmakingTicketsForPlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListMultiplayerServersRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of the multiplayer servers to list.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // The region the multiplayer servers to list.
        FString Region;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListMultiplayerServersRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags(),
            PageSize(),
            Region(),
            SkipToken()
            {}

        FListMultiplayerServersRequest(const FListMultiplayerServersRequest& src) = default;

        FListMultiplayerServersRequest(const TSharedPtr<FJsonObject>& obj) : FListMultiplayerServersRequest()
        {
            readFromValue(obj);
        }

        ~FListMultiplayerServersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FMultiplayerServerSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The connected players in the multiplayer server.
        TArray<FConnectedPlayer> ConnectedPlayers;
        // [optional] The time (UTC) at which a change in the multiplayer server state was observed.
        Boxed<FDateTime> LastStateTransitionTime;

        // [optional] The region the multiplayer server is located in.
        FString Region;

        // [optional] The string server ID of the multiplayer server generated by PlayFab.
        FString ServerId;

        // [optional] The title generated guid string session ID of the multiplayer server.
        FString SessionId;

        // [optional] The state of the multiplayer server.
        FString State;

        // [optional] The virtual machine ID that the multiplayer server is located on.
        FString VmId;

        FMultiplayerServerSummary() :
            FPlayFabCppBaseModel(),
            ConnectedPlayers(),
            LastStateTransitionTime(),
            Region(),
            ServerId(),
            SessionId(),
            State(),
            VmId()
            {}

        FMultiplayerServerSummary(const FMultiplayerServerSummary& src) = default;

        FMultiplayerServerSummary(const TSharedPtr<FJsonObject>& obj) : FMultiplayerServerSummary()
        {
            readFromValue(obj);
        }

        ~FMultiplayerServerSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListMultiplayerServersResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The list of multiplayer server summary details.
        TArray<FMultiplayerServerSummary> MultiplayerServerSummaries;
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListMultiplayerServersResponse() :
            FPlayFabCppResultCommon(),
            MultiplayerServerSummaries(),
            PageSize(0),
            SkipToken()
            {}

        FListMultiplayerServersResponse(const FListMultiplayerServersResponse& src) = default;

        FListMultiplayerServersResponse(const TSharedPtr<FJsonObject>& obj) : FListMultiplayerServersResponse()
        {
            readFromValue(obj);
        }

        ~FListMultiplayerServersResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListPartyQosServersRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FListPartyQosServersRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FListPartyQosServersRequest(const FListPartyQosServersRequest& src) = default;

        FListPartyQosServersRequest(const TSharedPtr<FJsonObject>& obj) : FListPartyQosServersRequest()
        {
            readFromValue(obj);
        }

        ~FListPartyQosServersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FQosServer : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The region the QoS server is located in.
        FString Region;

        // [optional] The QoS server URL.
        FString ServerUrl;

        FQosServer() :
            FPlayFabCppBaseModel(),
            Region(),
            ServerUrl()
            {}

        FQosServer(const FQosServer& src) = default;

        FQosServer(const TSharedPtr<FJsonObject>& obj) : FQosServer()
        {
            readFromValue(obj);
        }

        ~FQosServer();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListPartyQosServersResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // The page size on the response.
        int32 PageSize;

        // [optional] The list of QoS servers.
        TArray<FQosServer> QosServers;
        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListPartyQosServersResponse() :
            FPlayFabCppResultCommon(),
            PageSize(0),
            QosServers(),
            SkipToken()
            {}

        FListPartyQosServersResponse(const FListPartyQosServersResponse& src) = default;

        FListPartyQosServersResponse(const TSharedPtr<FJsonObject>& obj) : FListPartyQosServersResponse()
        {
            readFromValue(obj);
        }

        ~FListPartyQosServersResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListQosServersForTitleRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] Indicates that the response should contain Qos servers for all regions, including those where there are no builds
         * deployed for the title.
         */
        Boxed<bool> IncludeAllRegions;

        // [optional] Indicates the Routing Preference used by the Qos servers. The default Routing Preference is Microsoft
        FString RoutingPreference;

        FListQosServersForTitleRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            IncludeAllRegions(),
            RoutingPreference()
            {}

        FListQosServersForTitleRequest(const FListQosServersForTitleRequest& src) = default;

        FListQosServersForTitleRequest(const TSharedPtr<FJsonObject>& obj) : FListQosServersForTitleRequest()
        {
            readFromValue(obj);
        }

        ~FListQosServersForTitleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListQosServersForTitleResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // The page size on the response.
        int32 PageSize;

        // [optional] The list of QoS servers.
        TArray<FQosServer> QosServers;
        // [optional] The skip token for the paged response.
        FString SkipToken;

        FListQosServersForTitleResponse() :
            FPlayFabCppResultCommon(),
            PageSize(0),
            QosServers(),
            SkipToken()
            {}

        FListQosServersForTitleResponse(const FListQosServersForTitleResponse& src) = default;

        FListQosServersForTitleResponse(const TSharedPtr<FJsonObject>& obj) : FListQosServersForTitleResponse()
        {
            readFromValue(obj);
        }

        ~FListQosServersForTitleResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListServerBackfillTicketsForPlayerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The entity key for which to find the ticket Ids.
        FEntityKey Entity;

        // The name of the queue the tickets are in.
        FString QueueName;

        FListServerBackfillTicketsForPlayerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            Entity(),
            QueueName()
            {}

        FListServerBackfillTicketsForPlayerRequest(const FListServerBackfillTicketsForPlayerRequest& src) = default;

        FListServerBackfillTicketsForPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FListServerBackfillTicketsForPlayerRequest()
        {
            readFromValue(obj);
        }

        ~FListServerBackfillTicketsForPlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListServerBackfillTicketsForPlayerResult : public PlayFab::FPlayFabCppResultCommon
    {
        // The list of backfill ticket Ids the user is a member of.
        TArray<FString> TicketIds;
        FListServerBackfillTicketsForPlayerResult() :
            FPlayFabCppResultCommon(),
            TicketIds()
            {}

        FListServerBackfillTicketsForPlayerResult(const FListServerBackfillTicketsForPlayerResult& src) = default;

        FListServerBackfillTicketsForPlayerResult(const TSharedPtr<FJsonObject>& obj) : FListServerBackfillTicketsForPlayerResult()
        {
            readFromValue(obj);
        }

        ~FListServerBackfillTicketsForPlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListTitleMultiplayerServersQuotaChangesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FListTitleMultiplayerServersQuotaChangesRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FListTitleMultiplayerServersQuotaChangesRequest(const FListTitleMultiplayerServersQuotaChangesRequest& src) = default;

        FListTitleMultiplayerServersQuotaChangesRequest(const TSharedPtr<FJsonObject>& obj) : FListTitleMultiplayerServersQuotaChangesRequest()
        {
            readFromValue(obj);
        }

        ~FListTitleMultiplayerServersQuotaChangesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListTitleMultiplayerServersQuotaChangesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] All change requests for this title.
        TArray<FQuotaChange> Changes;
        FListTitleMultiplayerServersQuotaChangesResponse() :
            FPlayFabCppResultCommon(),
            Changes()
            {}

        FListTitleMultiplayerServersQuotaChangesResponse(const FListTitleMultiplayerServersQuotaChangesResponse& src) = default;

        FListTitleMultiplayerServersQuotaChangesResponse(const TSharedPtr<FJsonObject>& obj) : FListTitleMultiplayerServersQuotaChangesResponse()
        {
            readFromValue(obj);
        }

        ~FListTitleMultiplayerServersQuotaChangesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListVirtualMachineSummariesRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string build ID of the virtual machines to list.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The page size for the request.
        Boxed<int32> PageSize;

        // The region of the virtual machines to list.
        FString Region;

        // [optional] The skip token for the paged request.
        FString SkipToken;

        FListVirtualMachineSummariesRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            CustomTags(),
            PageSize(),
            Region(),
            SkipToken()
            {}

        FListVirtualMachineSummariesRequest(const FListVirtualMachineSummariesRequest& src) = default;

        FListVirtualMachineSummariesRequest(const TSharedPtr<FJsonObject>& obj) : FListVirtualMachineSummariesRequest()
        {
            readFromValue(obj);
        }

        ~FListVirtualMachineSummariesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FVirtualMachineSummary : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] The virtual machine health status.
        FString HealthStatus;

        // [optional] The virtual machine state.
        FString State;

        // [optional] The virtual machine ID.
        FString VmId;

        FVirtualMachineSummary() :
            FPlayFabCppBaseModel(),
            HealthStatus(),
            State(),
            VmId()
            {}

        FVirtualMachineSummary(const FVirtualMachineSummary& src) = default;

        FVirtualMachineSummary(const TSharedPtr<FJsonObject>& obj) : FVirtualMachineSummary()
        {
            readFromValue(obj);
        }

        ~FVirtualMachineSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FListVirtualMachineSummariesResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // The page size on the response.
        int32 PageSize;

        // [optional] The skip token for the paged response.
        FString SkipToken;

        // [optional] The list of virtual machine summaries.
        TArray<FVirtualMachineSummary> VirtualMachines;
        FListVirtualMachineSummariesResponse() :
            FPlayFabCppResultCommon(),
            PageSize(0),
            SkipToken(),
            VirtualMachines()
            {}

        FListVirtualMachineSummariesResponse(const FListVirtualMachineSummariesResponse& src) = default;

        FListVirtualMachineSummariesResponse(const TSharedPtr<FJsonObject>& obj) : FListVirtualMachineSummariesResponse()
        {
            readFromValue(obj);
        }

        ~FListVirtualMachineSummariesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FLobbyEmptyResult : public PlayFab::FPlayFabCppResultCommon
    {
        FLobbyEmptyResult() :
            FPlayFabCppResultCommon()
            {}

        FLobbyEmptyResult(const FLobbyEmptyResult& src) = default;

        FLobbyEmptyResult(const TSharedPtr<FJsonObject>& obj) : FLobbyEmptyResult()
        {
            readFromValue(obj);
        }

        ~FLobbyEmptyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum OsPlatform
    {
        OsPlatformWindows,
        OsPlatformLinux
    };

    PLAYFABCPP_API void writeOsPlatformEnumJSON(OsPlatform enumVal, JsonWriter& writer);
    PLAYFABCPP_API OsPlatform readOsPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API OsPlatform readOsPlatformFromValue(const FString& value);

    struct PLAYFABCPP_API FPartyInvitationConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        /**
         * [optional] The list of PlayFab EntityKeys that the invitation allows to authenticate into the network. If this list is empty, all
         * users are allowed to authenticate using the invitation's identifier. This list may contain no more than 1024 items.
         */
        TArray<FEntityKey> EntityKeys;
        // [optional] The invite identifier for this party. If this value is specified, it must be no longer than 127 characters.
        FString Identifier;

        // [optional] Controls which participants can revoke this invite.
        FString Revocability;

        FPartyInvitationConfiguration() :
            FPlayFabCppBaseModel(),
            EntityKeys(),
            Identifier(),
            Revocability()
            {}

        FPartyInvitationConfiguration(const FPartyInvitationConfiguration& src) = default;

        FPartyInvitationConfiguration(const TSharedPtr<FJsonObject>& obj) : FPartyInvitationConfiguration()
        {
            readFromValue(obj);
        }

        ~FPartyInvitationConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PartyInvitationRevocability
    {
        PartyInvitationRevocabilityCreator,
        PartyInvitationRevocabilityAnyone
    };

    PLAYFABCPP_API void writePartyInvitationRevocabilityEnumJSON(PartyInvitationRevocability enumVal, JsonWriter& writer);
    PLAYFABCPP_API PartyInvitationRevocability readPartyInvitationRevocabilityFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API PartyInvitationRevocability readPartyInvitationRevocabilityFromValue(const FString& value);

    struct PLAYFABCPP_API FPartyNetworkConfiguration : public PlayFab::FPlayFabCppBaseModel
    {
        // [optional] Controls whether and how to support direct peer-to-peer connection attempts among devices in the network.
        FString DirectPeerConnectivityOptions;

        // The maximum number of devices allowed to connect to the network. Must be between 1 and 32, inclusive.
        uint32 MaxDevices;

        // The maximum number of devices allowed per user. Must be greater than 0.
        uint32 MaxDevicesPerUser;

        // The maximum number of endpoints allowed per device. Must be between 0 and 32, inclusive.
        uint32 MaxEndpointsPerDevice;

        // The maximum number of unique users allowed in the network. Must be greater than 0.
        uint32 MaxUsers;

        // The maximum number of users allowed per device. Must be between 1 and 8, inclusive.
        uint32 MaxUsersPerDevice;

        /**
         * [optional] An optionally-specified configuration for the initial invitation for this party. If not provided, default configuration
         * values will be used: a title-unique invitation identifier will be generated, the revocability will be Anyone, and the
         * EntityID list will be empty.
         */
        TSharedPtr<FPartyInvitationConfiguration> pfPartyInvitationConfiguration;

        FPartyNetworkConfiguration() :
            FPlayFabCppBaseModel(),
            DirectPeerConnectivityOptions(),
            MaxDevices(0),
            MaxDevicesPerUser(0),
            MaxEndpointsPerDevice(0),
            MaxUsers(0),
            MaxUsersPerDevice(0),
            pfPartyInvitationConfiguration(nullptr)
            {}

        FPartyNetworkConfiguration(const FPartyNetworkConfiguration& src) = default;

        FPartyNetworkConfiguration(const TSharedPtr<FJsonObject>& obj) : FPartyNetworkConfiguration()
        {
            readFromValue(obj);
        }

        ~FPartyNetworkConfiguration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRemoveMemberFromLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The id of the lobby.
        FString LobbyId;

        // [optional] The member entity to be removed from the lobby.
        TSharedPtr<FEntityKey> MemberEntity;

        // If true, removed member can never rejoin this lobby.
        bool PreventRejoin;

        FRemoveMemberFromLobbyRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId(),
            MemberEntity(nullptr),
            PreventRejoin(false)
            {}

        FRemoveMemberFromLobbyRequest(const FRemoveMemberFromLobbyRequest& src) = default;

        FRemoveMemberFromLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveMemberFromLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveMemberFromLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRequestMultiplayerServerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The identifiers of the build alias to use for the request.
        TSharedPtr<FBuildAliasParams> pfBuildAliasParams;

        // [optional] The guid string build ID of the multiplayer server to request.
        FString BuildId;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] Initial list of players (potentially matchmade) allowed to connect to the game. This list is passed to the game server
         * when requested (via GSDK) and can be used to validate players connecting to it.
         */
        TArray<FString> InitialPlayers;
        /**
         * The preferred regions to request a multiplayer server from. The Multiplayer Service will iterate through the regions in
         * the specified order and allocate a server from the first one that has servers available.
         */
        TArray<FString> PreferredRegions;
        /**
         * [optional] Data encoded as a string that is passed to the game server when requested. This can be used to to communicate
         * information such as game mode or map through the request flow.
         */
        FString SessionCookie;

        // A guid string session ID created track the multiplayer server session over its life.
        FString SessionId;

        FRequestMultiplayerServerRequest() :
            FPlayFabCppRequestCommon(),
            pfBuildAliasParams(nullptr),
            BuildId(),
            CustomTags(),
            InitialPlayers(),
            PreferredRegions(),
            SessionCookie(),
            SessionId()
            {}

        FRequestMultiplayerServerRequest(const FRequestMultiplayerServerRequest& src) = default;

        FRequestMultiplayerServerRequest(const TSharedPtr<FJsonObject>& obj) : FRequestMultiplayerServerRequest()
        {
            readFromValue(obj);
        }

        ~FRequestMultiplayerServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRequestMultiplayerServerResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The identity of the build in which the server was allocated.
        FString BuildId;

        // [optional] The connected players in the multiplayer server.
        TArray<FConnectedPlayer> ConnectedPlayers;
        // [optional] The fully qualified domain name of the virtual machine that is hosting this multiplayer server.
        FString FQDN;

        // [optional] The public IPv4 address of the virtual machine that is hosting this multiplayer server.
        FString IPV4Address;

        // [optional] The time (UTC) at which a change in the multiplayer server state was observed.
        Boxed<FDateTime> LastStateTransitionTime;

        // [optional] The ports the multiplayer server uses.
        TArray<FPort> Ports;
        // [optional] The list of public Ipv4 addresses associated with the server.
        TArray<FPublicIpAddress> PublicIPV4Addresses;
        // [optional] The region the multiplayer server is located in.
        FString Region;

        // [optional] The string server ID of the multiplayer server generated by PlayFab.
        FString ServerId;

        // [optional] The guid string session ID of the multiplayer server.
        FString SessionId;

        // [optional] The state of the multiplayer server.
        FString State;

        // [optional] The virtual machine ID that the multiplayer server is located on.
        FString VmId;

        FRequestMultiplayerServerResponse() :
            FPlayFabCppResultCommon(),
            BuildId(),
            ConnectedPlayers(),
            FQDN(),
            IPV4Address(),
            LastStateTransitionTime(),
            Ports(),
            PublicIPV4Addresses(),
            Region(),
            ServerId(),
            SessionId(),
            State(),
            VmId()
            {}

        FRequestMultiplayerServerResponse(const FRequestMultiplayerServerResponse& src) = default;

        FRequestMultiplayerServerResponse(const TSharedPtr<FJsonObject>& obj) : FRequestMultiplayerServerResponse()
        {
            readFromValue(obj);
        }

        ~FRequestMultiplayerServerResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRequestPartyServiceRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The network configuration for this request.
        FPartyNetworkConfiguration NetworkConfiguration;

        // [optional] A guid string party ID created track the party session over its life.
        FString PartyId;

        /**
         * The preferred regions to request a party session from. The party service will iterate through the regions in the
         * specified order and allocate a party session from the first one that is available.
         */
        TArray<FString> PreferredRegions;
        FRequestPartyServiceRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            NetworkConfiguration(),
            PartyId(),
            PreferredRegions()
            {}

        FRequestPartyServiceRequest(const FRequestPartyServiceRequest& src) = default;

        FRequestPartyServiceRequest(const TSharedPtr<FJsonObject>& obj) : FRequestPartyServiceRequest()
        {
            readFromValue(obj);
        }

        ~FRequestPartyServiceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRequestPartyServiceResponse : public PlayFab::FPlayFabCppResultCommon
    {
        /**
         * [optional] The invitation identifier supplied in the PartyInvitationConfiguration, or the PlayFab-generated guid if none was
         * supplied.
         */
        FString InvitationId;

        // [optional] The guid string party ID of the party session.
        FString PartyId;

        // [optional] A base-64 encoded string containing the serialized network descriptor for this party.
        FString SerializedNetworkDescriptor;

        FRequestPartyServiceResponse() :
            FPlayFabCppResultCommon(),
            InvitationId(),
            PartyId(),
            SerializedNetworkDescriptor()
            {}

        FRequestPartyServiceResponse(const FRequestPartyServiceResponse& src) = default;

        FRequestPartyServiceResponse(const TSharedPtr<FJsonObject>& obj) : FRequestPartyServiceResponse()
        {
            readFromValue(obj);
        }

        ~FRequestPartyServiceResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRolloverContainerRegistryCredentialsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FRolloverContainerRegistryCredentialsRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags()
            {}

        FRolloverContainerRegistryCredentialsRequest(const FRolloverContainerRegistryCredentialsRequest& src) = default;

        FRolloverContainerRegistryCredentialsRequest(const TSharedPtr<FJsonObject>& obj) : FRolloverContainerRegistryCredentialsRequest()
        {
            readFromValue(obj);
        }

        ~FRolloverContainerRegistryCredentialsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FRolloverContainerRegistryCredentialsResponse : public PlayFab::FPlayFabCppResultCommon
    {
        // [optional] The url of the container registry.
        FString DnsName;

        // [optional] The password for accessing the container registry.
        FString Password;

        // [optional] The username for accessing the container registry.
        FString Username;

        FRolloverContainerRegistryCredentialsResponse() :
            FPlayFabCppResultCommon(),
            DnsName(),
            Password(),
            Username()
            {}

        FRolloverContainerRegistryCredentialsResponse(const FRolloverContainerRegistryCredentialsResponse& src) = default;

        FRolloverContainerRegistryCredentialsResponse(const TSharedPtr<FJsonObject>& obj) : FRolloverContainerRegistryCredentialsResponse()
        {
            readFromValue(obj);
        }

        ~FRolloverContainerRegistryCredentialsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum RoutingType
    {
        RoutingTypeMicrosoft,
        RoutingTypeInternet
    };

    PLAYFABCPP_API void writeRoutingTypeEnumJSON(RoutingType enumVal, JsonWriter& writer);
    PLAYFABCPP_API RoutingType readRoutingTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API RoutingType readRoutingTypeFromValue(const FString& value);

    enum ServerType
    {
        ServerTypeContainer,
        ServerTypeProcess
    };

    PLAYFABCPP_API void writeServerTypeEnumJSON(ServerType enumVal, JsonWriter& writer);
    PLAYFABCPP_API ServerType readServerTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API ServerType readServerTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FShutdownMultiplayerServerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // A guid string session ID of the multiplayer server to shut down.
        FString SessionId;

        FShutdownMultiplayerServerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            SessionId()
            {}

        FShutdownMultiplayerServerRequest(const FShutdownMultiplayerServerRequest& src) = default;

        FShutdownMultiplayerServerRequest(const TSharedPtr<FJsonObject>& obj) : FShutdownMultiplayerServerRequest()
        {
            readFromValue(obj);
        }

        ~FShutdownMultiplayerServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SubscriptionType
    {
        SubscriptionTypeLobbyChange,
        SubscriptionTypeLobbyInvite
    };

    PLAYFABCPP_API void writeSubscriptionTypeEnumJSON(SubscriptionType enumVal, JsonWriter& writer);
    PLAYFABCPP_API SubscriptionType readSubscriptionTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFABCPP_API SubscriptionType readSubscriptionTypeFromValue(const FString& value);

    struct PLAYFABCPP_API FSubscribeToLobbyResourceRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The entity performing the subscription.
        FEntityKey pfEntityKey;

        // Opaque string, given to a client upon creating a connection with PubSub.
        FString PubSubConnectionHandle;

        // The name of the resource to subscribe to.
        FString ResourceId;

        // Version number for the subscription of this resource.
        uint32 SubscriptionVersion;

        // Subscription type.
        SubscriptionType Type;

        FSubscribeToLobbyResourceRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            pfEntityKey(),
            PubSubConnectionHandle(),
            ResourceId(),
            SubscriptionVersion(0),
            Type()
            {}

        FSubscribeToLobbyResourceRequest(const FSubscribeToLobbyResourceRequest& src) = default;

        FSubscribeToLobbyResourceRequest(const TSharedPtr<FJsonObject>& obj) : FSubscribeToLobbyResourceRequest()
        {
            readFromValue(obj);
        }

        ~FSubscribeToLobbyResourceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FSubscribeToLobbyResourceResult : public PlayFab::FPlayFabCppResultCommon
    {
        // Topic will be returned in all notifications that are the result of this subscription.
        FString Topic;

        FSubscribeToLobbyResourceResult() :
            FPlayFabCppResultCommon(),
            Topic()
            {}

        FSubscribeToLobbyResourceResult(const FSubscribeToLobbyResourceResult& src) = default;

        FSubscribeToLobbyResourceResult(const TSharedPtr<FJsonObject>& obj) : FSubscribeToLobbyResourceResult()
        {
            readFromValue(obj);
        }

        ~FSubscribeToLobbyResourceResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUnsubscribeFromLobbyResourceRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The entity which performed the subscription.
        FEntityKey pfEntityKey;

        // Opaque string, given to a client upon creating a connection with PubSub.
        FString PubSubConnectionHandle;

        // The name of the resource to unsubscribe from.
        FString ResourceId;

        // Version number passed for the subscription of this resource.
        uint32 SubscriptionVersion;

        // Subscription type.
        SubscriptionType Type;

        FUnsubscribeFromLobbyResourceRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            pfEntityKey(),
            PubSubConnectionHandle(),
            ResourceId(),
            SubscriptionVersion(0),
            Type()
            {}

        FUnsubscribeFromLobbyResourceRequest(const FUnsubscribeFromLobbyResourceRequest& src) = default;

        FUnsubscribeFromLobbyResourceRequest(const TSharedPtr<FJsonObject>& obj) : FUnsubscribeFromLobbyResourceRequest()
        {
            readFromValue(obj);
        }

        ~FUnsubscribeFromLobbyResourceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUntagContainerImageRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] The container image which tag we want to remove.
        FString ImageName;

        // [optional] The tag we want to remove.
        FString Tag;

        FUntagContainerImageRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            ImageName(),
            Tag()
            {}

        FUntagContainerImageRequest(const FUntagContainerImageRequest& src) = default;

        FUntagContainerImageRequest(const TSharedPtr<FJsonObject>& obj) : FUntagContainerImageRequest()
        {
            readFromValue(obj);
        }

        ~FUntagContainerImageRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBuildAliasRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string alias Id of the alias to be updated.
        FString AliasId;

        // [optional] The alias name.
        FString AliasName;

        // [optional] Array of build selection criteria.
        TArray<FBuildSelectionCriterion> BuildSelectionCriteria;
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FUpdateBuildAliasRequest() :
            FPlayFabCppRequestCommon(),
            AliasId(),
            AliasName(),
            BuildSelectionCriteria(),
            CustomTags()
            {}

        FUpdateBuildAliasRequest(const FUpdateBuildAliasRequest& src) = default;

        FUpdateBuildAliasRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBuildAliasRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBuildAliasRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBuildNameRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string ID of the build we want to update the name of.
        FString BuildId;

        // The build name.
        FString BuildName;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FUpdateBuildNameRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            BuildName(),
            CustomTags()
            {}

        FUpdateBuildNameRequest(const FUpdateBuildNameRequest& src) = default;

        FUpdateBuildNameRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBuildNameRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBuildNameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBuildRegionRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string ID of the build we want to update regions for.
        FString BuildId;

        // The updated region configuration that should be applied to the specified build.
        FBuildRegionParams BuildRegion;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FUpdateBuildRegionRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            BuildRegion(),
            CustomTags()
            {}

        FUpdateBuildRegionRequest(const FUpdateBuildRegionRequest& src) = default;

        FUpdateBuildRegionRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBuildRegionRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBuildRegionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateBuildRegionsRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // The guid string ID of the build we want to update regions for.
        FString BuildId;

        // The updated region configuration that should be applied to the specified build.
        TArray<FBuildRegionParams> BuildRegions;
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        FUpdateBuildRegionsRequest() :
            FPlayFabCppRequestCommon(),
            BuildId(),
            BuildRegions(),
            CustomTags()
            {}

        FUpdateBuildRegionsRequest(const FUpdateBuildRegionsRequest& src) = default;

        FUpdateBuildRegionsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBuildRegionsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBuildRegionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateLobbyAsServerRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // The id of the lobby.
        FString LobbyId;

        /**
         * [optional] The private key-value pairs which are visible to all entities in the lobby and modifiable by the joined server.
         * Optional. Sets or updates key-value pairs on the lobby. Only the current lobby lobby server can set serverData. Keys may
         * be an arbitrary string of at most 30 characters. The total size of all serverData values may not exceed 4096 bytes.
         * Values are not individually limited. There can be up to 30 key-value pairs stored here. Keys are case sensitive.
         */
        TMap<FString, FString> ServerData;
        /**
         * [optional] The keys to delete from the lobby serverData. Optional. Optional. Deletes key-value pairs on the lobby. Only the current
         * joined lobby server can delete serverData. All the specified keys will be removed from the serverData. Keys that do not
         * exist in the lobby are a no-op. If the key to delete exists in the serverData (same request) it will result in a bad
         * request.
         */
        TArray<FString> ServerDataToDelete;
        /**
         * [optional] The lobby server. Optional. Set a different server as the joined server of the lobby (there can only be 1 joined
         * server). When changing the server the previous server will automatically be unsubscribed.
         */
        TSharedPtr<FEntityKey> ServerEntity;

        FUpdateLobbyAsServerRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            LobbyId(),
            ServerData(),
            ServerDataToDelete(),
            ServerEntity(nullptr)
            {}

        FUpdateLobbyAsServerRequest(const FUpdateLobbyAsServerRequest& src) = default;

        FUpdateLobbyAsServerRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateLobbyAsServerRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateLobbyAsServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUpdateLobbyRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        /**
         * [optional] The policy indicating who is allowed to join the lobby, and the visibility to queries. May be 'Public', 'Friends' or
         * 'Private'. Public means the lobby is both visible in queries and any player may join, including invited players. Friends
         * means that users who are bidirectional friends of members in the lobby may search to find friend lobbies, to retrieve
         * its connection string. Private means the lobby is not visible in queries, and a player must receive an invitation to
         * join. Defaults to 'Public' on creation. Can only be changed by the lobby owner.
         */
        Boxed<AccessPolicy> pfAccessPolicy;

        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        /**
         * [optional] The private key-value pairs which are visible to all entities in the lobby. Optional. Sets or updates key-value pairs on
         * the lobby. Only the current lobby owner can set lobby data. Keys may be an arbitrary string of at most 30 characters.
         * The total size of all lobbyData values may not exceed 4096 bytes. Values are not individually limited. There can be up
         * to 30 key-value pairs stored here. Keys are case sensitive.
         */
        TMap<FString, FString> LobbyData;
        // [optional] The keys to delete from the lobby LobbyData. Optional. Behaves similar to searchDataToDelete, but applies to lobbyData.
        TArray<FString> LobbyDataToDelete;
        // [optional] The id of the lobby.
        FString LobbyId;

        /**
         * [optional] The maximum number of players allowed in the lobby. Updates the maximum allowed number of players in the lobby. Only the
         * current lobby owner can set this. If set, the value must be greater than or equal to the number of members currently in
         * the lobby.
         */
        Boxed<uint32> MaxPlayers;

        /**
         * [optional] The private key-value pairs used by the member to communicate information to other members and the owner. Optional. Sets
         * or updates new key-value pairs on the caller's member data. New keys will be added with their values and existing keys
         * will be updated with the new values. Visible to all entities in the lobby. At most 30 key-value pairs may be stored
         * here, keys are limited to 30 characters and values to 1000. The total size of all memberData values may not exceed 4096
         * bytes. Keys are case sensitive. Servers cannot specifiy this.
         */
        TMap<FString, FString> MemberData;
        /**
         * [optional] The keys to delete from the lobby MemberData. Optional. Deletes key-value pairs on the caller's member data. All the
         * specified keys will be removed from the caller's member data. Keys that do not exist are a no-op. If the key to delete
         * exists in the memberData (same request) it will result in a bad request. Servers cannot specifiy this.
         */
        TArray<FString> MemberDataToDelete;
        // [optional] The member entity whose data is being modified. Servers cannot specify this.
        TSharedPtr<FEntityKey> MemberEntity;

        /**
         * [optional] A setting indicating whether the lobby is locked. May be 'Unlocked' or 'Locked'. When Locked new members are not allowed
         * to join. Defaults to 'Unlocked' on creation. Can only be changed by the lobby owner.
         */
        Boxed<MembershipLock> pfMembershipLock;

        /**
         * [optional] The lobby owner. Optional. Set to transfer ownership of the lobby. If client - owned and 'Automatic' - The Lobby service
         * will automatically assign another connected owner when the current owner leaves or disconnects. useConnections must be
         * true. If client - owned and 'Manual' - Ownership is protected as long as the current owner is connected. If the current
         * owner leaves or disconnects any member may set themselves as the current owner. The useConnections property must be
         * true. If client-owned and 'None' - Any member can set ownership. The useConnections property can be either true or
         * false. For all client-owned lobbies when the owner leaves and a new owner can not be automatically selected - The owner
         * field is set to null. For all client-owned lobbies when the owner disconnects and a new owner can not be automatically
         * selected - The owner field remains unchanged and the current owner retains all owner abilities for the lobby. If
         * server-owned (must be 'Server') - Any server can set ownership. The useConnections property must be true.
         */
        TSharedPtr<FEntityKey> Owner;

        /**
         * [optional] The public key-value pairs which allow queries to differentiate between lobbies. Optional. Sets or updates key-value
         * pairs on the lobby for use with queries. Only the current lobby owner can set search data. New keys will be added with
         * their values and existing keys will be updated with the new values. There can be up to 30 key-value pairs stored here.
         * Keys are of the format string_key1, string_key2... string_key30 for string values, or number_key1, number_key2, ...
         * number_key30 for numeric values. Numeric values are floats. Values can be at most 256 characters long. The total size of
         * all searchData values may not exceed 1024 bytes.Keys are case sensitive.
         */
        TMap<FString, FString> SearchData;
        /**
         * [optional] The keys to delete from the lobby SearchData. Optional. Deletes key-value pairs on the lobby. Only the current lobby
         * owner can delete search data. All the specified keys will be removed from the search data. Keys that do not exist in the
         * lobby are a no-op.If the key to delete exists in the searchData (same request) it will result in a bad request.
         */
        TArray<FString> SearchDataToDelete;
        FUpdateLobbyRequest() :
            FPlayFabCppRequestCommon(),
            pfAccessPolicy(),
            CustomTags(),
            LobbyData(),
            LobbyDataToDelete(),
            LobbyId(),
            MaxPlayers(),
            MemberData(),
            MemberDataToDelete(),
            MemberEntity(nullptr),
            pfMembershipLock(),
            Owner(nullptr),
            SearchData(),
            SearchDataToDelete()
            {}

        FUpdateLobbyRequest(const FUpdateLobbyRequest& src) = default;

        FUpdateLobbyRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateLobbyRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateLobbyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFABCPP_API FUploadCertificateRequest : public PlayFab::FPlayFabCppRequestCommon
    {
        // [optional] The optional custom tags associated with the request (e.g. build number, external trace identifiers, etc.).
        TMap<FString, FString> CustomTags;
        // [optional] Forces the certificate renewal if the certificate already exists. Default is false
        Boxed<bool> ForceUpdate;

        // The game certificate to upload.
        FCertificate GameCertificate;

        FUploadCertificateRequest() :
            FPlayFabCppRequestCommon(),
            CustomTags(),
            ForceUpdate(),
            GameCertificate()
            {}

        FUploadCertificateRequest(const FUploadCertificateRequest& src) = default;

        FUploadCertificateRequest(const TSharedPtr<FJsonObject>& obj) : FUploadCertificateRequest()
        {
            readFromValue(obj);
        }

        ~FUploadCertificateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
