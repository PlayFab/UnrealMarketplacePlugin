//////////////////////////////////////////////////////
// Copyright (C) Microsoft. 2018. All rights reserved.
//////////////////////////////////////////////////////


// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!

#include "Core/PlayFabMatchmakerDataModels.h"
#include "Core/PlayFabJsonHelpers.h"

using namespace PlayFab;
using namespace PlayFab::MatchmakerModels;

PlayFab::MatchmakerModels::FAuthUserRequest::~FAuthUserRequest()
{

}

void PlayFab::MatchmakerModels::FAuthUserRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (!AuthorizationTicket.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: AuthUserRequest::AuthorizationTicket, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("AuthorizationTicket"));
        writer->WriteValue(AuthorizationTicket);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FAuthUserRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AuthorizationTicketValue = obj->TryGetField(TEXT("AuthorizationTicket"));
    if (AuthorizationTicketValue.IsValid() && !AuthorizationTicketValue->IsNull())
    {
        FString TmpValue;
        if (AuthorizationTicketValue->TryGetString(TmpValue)) { AuthorizationTicket = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FAuthUserResponse::~FAuthUserResponse()
{

}

void PlayFab::MatchmakerModels::FAuthUserResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("Authorized"));
    writer->WriteValue(Authorized);

    if (PlayFabId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("PlayFabId"));
        writer->WriteValue(PlayFabId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FAuthUserResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AuthorizedValue = obj->TryGetField(TEXT("Authorized"));
    if (AuthorizedValue.IsValid() && !AuthorizedValue->IsNull())
    {
        bool TmpValue;
        if (AuthorizedValue->TryGetBool(TmpValue)) { Authorized = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PlayFabIdValue = obj->TryGetField(TEXT("PlayFabId"));
    if (PlayFabIdValue.IsValid() && !PlayFabIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayFabIdValue->TryGetString(TmpValue)) { PlayFabId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FItemInstance::~FItemInstance()
{

}

void PlayFab::MatchmakerModels::FItemInstance::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Annotation.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Annotation"));
        writer->WriteValue(Annotation);
    }

    if (BundleContents.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("BundleContents"));
        for (const FString& item : BundleContents)
            writer->WriteValue(item);
        writer->WriteArrayEnd();
    }


    if (BundleParent.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("BundleParent"));
        writer->WriteValue(BundleParent);
    }

    if (CatalogVersion.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("CatalogVersion"));
        writer->WriteValue(CatalogVersion);
    }

    if (CustomData.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomData"));
        for (TMap<FString, FString>::TConstIterator It(CustomData); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (DisplayName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("DisplayName"));
        writer->WriteValue(DisplayName);
    }

    if (Expiration.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("Expiration"));
        writeDatetime(Expiration, writer);
    }

    if (ItemClass.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ItemClass"));
        writer->WriteValue(ItemClass);
    }

    if (ItemId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ItemId"));
        writer->WriteValue(ItemId);
    }

    if (ItemInstanceId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("ItemInstanceId"));
        writer->WriteValue(ItemInstanceId);
    }

    if (PurchaseDate.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("PurchaseDate"));
        writeDatetime(PurchaseDate, writer);
    }

    if (RemainingUses.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("RemainingUses"));
        writer->WriteValue(RemainingUses);
    }

    if (UnitCurrency.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("UnitCurrency"));
        writer->WriteValue(UnitCurrency);
    }

    writer->WriteIdentifierPrefix(TEXT("UnitPrice"));
    writer->WriteValue(static_cast<int64>(UnitPrice));

    if (UsesIncrementedBy.notNull())
    {
        writer->WriteIdentifierPrefix(TEXT("UsesIncrementedBy"));
        writer->WriteValue(UsesIncrementedBy);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FItemInstance::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> AnnotationValue = obj->TryGetField(TEXT("Annotation"));
    if (AnnotationValue.IsValid() && !AnnotationValue->IsNull())
    {
        FString TmpValue;
        if (AnnotationValue->TryGetString(TmpValue)) { Annotation = TmpValue; }
    }

    obj->TryGetStringArrayField(TEXT("BundleContents"), BundleContents);

    const TSharedPtr<FJsonValue> BundleParentValue = obj->TryGetField(TEXT("BundleParent"));
    if (BundleParentValue.IsValid() && !BundleParentValue->IsNull())
    {
        FString TmpValue;
        if (BundleParentValue->TryGetString(TmpValue)) { BundleParent = TmpValue; }
    }

    const TSharedPtr<FJsonValue> CatalogVersionValue = obj->TryGetField(TEXT("CatalogVersion"));
    if (CatalogVersionValue.IsValid() && !CatalogVersionValue->IsNull())
    {
        FString TmpValue;
        if (CatalogVersionValue->TryGetString(TmpValue)) { CatalogVersion = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* CustomDataObject;
    if (obj->TryGetObjectField(TEXT("CustomData"), CustomDataObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomDataObject)->Values); It; ++It)
        {
            CustomData.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> DisplayNameValue = obj->TryGetField(TEXT("DisplayName"));
    if (DisplayNameValue.IsValid() && !DisplayNameValue->IsNull())
    {
        FString TmpValue;
        if (DisplayNameValue->TryGetString(TmpValue)) { DisplayName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ExpirationValue = obj->TryGetField(TEXT("Expiration"));
    if (ExpirationValue.IsValid())
        Expiration = readDatetime(ExpirationValue);


    const TSharedPtr<FJsonValue> ItemClassValue = obj->TryGetField(TEXT("ItemClass"));
    if (ItemClassValue.IsValid() && !ItemClassValue->IsNull())
    {
        FString TmpValue;
        if (ItemClassValue->TryGetString(TmpValue)) { ItemClass = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ItemIdValue = obj->TryGetField(TEXT("ItemId"));
    if (ItemIdValue.IsValid() && !ItemIdValue->IsNull())
    {
        FString TmpValue;
        if (ItemIdValue->TryGetString(TmpValue)) { ItemId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> ItemInstanceIdValue = obj->TryGetField(TEXT("ItemInstanceId"));
    if (ItemInstanceIdValue.IsValid() && !ItemInstanceIdValue->IsNull())
    {
        FString TmpValue;
        if (ItemInstanceIdValue->TryGetString(TmpValue)) { ItemInstanceId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PurchaseDateValue = obj->TryGetField(TEXT("PurchaseDate"));
    if (PurchaseDateValue.IsValid())
        PurchaseDate = readDatetime(PurchaseDateValue);


    const TSharedPtr<FJsonValue> RemainingUsesValue = obj->TryGetField(TEXT("RemainingUses"));
    if (RemainingUsesValue.IsValid() && !RemainingUsesValue->IsNull())
    {
        int32 TmpValue;
        if (RemainingUsesValue->TryGetNumber(TmpValue)) { RemainingUses = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UnitCurrencyValue = obj->TryGetField(TEXT("UnitCurrency"));
    if (UnitCurrencyValue.IsValid() && !UnitCurrencyValue->IsNull())
    {
        FString TmpValue;
        if (UnitCurrencyValue->TryGetString(TmpValue)) { UnitCurrency = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UnitPriceValue = obj->TryGetField(TEXT("UnitPrice"));
    if (UnitPriceValue.IsValid() && !UnitPriceValue->IsNull())
    {
        uint32 TmpValue;
        if (UnitPriceValue->TryGetNumber(TmpValue)) { UnitPrice = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsesIncrementedByValue = obj->TryGetField(TEXT("UsesIncrementedBy"));
    if (UsesIncrementedByValue.IsValid() && !UsesIncrementedByValue->IsNull())
    {
        int32 TmpValue;
        if (UsesIncrementedByValue->TryGetNumber(TmpValue)) { UsesIncrementedBy = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FPlayerJoinedRequest::~FPlayerJoinedRequest()
{

}

void PlayFab::MatchmakerModels::FPlayerJoinedRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!LobbyId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: PlayerJoinedRequest::LobbyId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LobbyId"));
        writer->WriteValue(LobbyId);
    }

    if (!PlayFabId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: PlayerJoinedRequest::PlayFabId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("PlayFabId"));
        writer->WriteValue(PlayFabId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FPlayerJoinedRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> LobbyIdValue = obj->TryGetField(TEXT("LobbyId"));
    if (LobbyIdValue.IsValid() && !LobbyIdValue->IsNull())
    {
        FString TmpValue;
        if (LobbyIdValue->TryGetString(TmpValue)) { LobbyId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PlayFabIdValue = obj->TryGetField(TEXT("PlayFabId"));
    if (PlayFabIdValue.IsValid() && !PlayFabIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayFabIdValue->TryGetString(TmpValue)) { PlayFabId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FPlayerJoinedResponse::~FPlayerJoinedResponse()
{

}

void PlayFab::MatchmakerModels::FPlayerJoinedResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FPlayerJoinedResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FPlayerLeftRequest::~FPlayerLeftRequest()
{

}

void PlayFab::MatchmakerModels::FPlayerLeftRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (!LobbyId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: PlayerLeftRequest::LobbyId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("LobbyId"));
        writer->WriteValue(LobbyId);
    }

    if (!PlayFabId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: PlayerLeftRequest::PlayFabId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("PlayFabId"));
        writer->WriteValue(PlayFabId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FPlayerLeftRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> LobbyIdValue = obj->TryGetField(TEXT("LobbyId"));
    if (LobbyIdValue.IsValid() && !LobbyIdValue->IsNull())
    {
        FString TmpValue;
        if (LobbyIdValue->TryGetString(TmpValue)) { LobbyId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PlayFabIdValue = obj->TryGetField(TEXT("PlayFabId"));
    if (PlayFabIdValue.IsValid() && !PlayFabIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayFabIdValue->TryGetString(TmpValue)) { PlayFabId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FPlayerLeftResponse::~FPlayerLeftResponse()
{

}

void PlayFab::MatchmakerModels::FPlayerLeftResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FPlayerLeftResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FUserInfoRequest::~FUserInfoRequest()
{

}

void PlayFab::MatchmakerModels::FUserInfoRequest::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (CustomTags.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("CustomTags"));
        for (TMap<FString, FString>::TConstIterator It(CustomTags); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteIdentifierPrefix(TEXT("MinCatalogVersion"));
    writer->WriteValue(MinCatalogVersion);

    if (!PlayFabId.IsEmpty() == false)
    {
        UE_LOG(LogTemp, Error, TEXT("This field is required: UserInfoRequest::PlayFabId, PlayFab calls may not work if it remains empty."));
    }
    else
    {
        writer->WriteIdentifierPrefix(TEXT("PlayFabId"));
        writer->WriteValue(PlayFabId);
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FUserInfoRequest::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonObject>* CustomTagsObject;
    if (obj->TryGetObjectField(TEXT("CustomTags"), CustomTagsObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*CustomTagsObject)->Values); It; ++It)
        {
            CustomTags.Add(It.Key(), It.Value()->AsString());
        }
    }

    const TSharedPtr<FJsonValue> MinCatalogVersionValue = obj->TryGetField(TEXT("MinCatalogVersion"));
    if (MinCatalogVersionValue.IsValid() && !MinCatalogVersionValue->IsNull())
    {
        int32 TmpValue;
        if (MinCatalogVersionValue->TryGetNumber(TmpValue)) { MinCatalogVersion = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PlayFabIdValue = obj->TryGetField(TEXT("PlayFabId"));
    if (PlayFabIdValue.IsValid() && !PlayFabIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayFabIdValue->TryGetString(TmpValue)) { PlayFabId = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FVirtualCurrencyRechargeTime::~FVirtualCurrencyRechargeTime()
{

}

void PlayFab::MatchmakerModels::FVirtualCurrencyRechargeTime::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    writer->WriteIdentifierPrefix(TEXT("RechargeMax"));
    writer->WriteValue(RechargeMax);

    writer->WriteIdentifierPrefix(TEXT("RechargeTime"));
    writeDatetime(RechargeTime, writer);

    writer->WriteIdentifierPrefix(TEXT("SecondsToRecharge"));
    writer->WriteValue(SecondsToRecharge);

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FVirtualCurrencyRechargeTime::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TSharedPtr<FJsonValue> RechargeMaxValue = obj->TryGetField(TEXT("RechargeMax"));
    if (RechargeMaxValue.IsValid() && !RechargeMaxValue->IsNull())
    {
        int32 TmpValue;
        if (RechargeMaxValue->TryGetNumber(TmpValue)) { RechargeMax = TmpValue; }
    }

    const TSharedPtr<FJsonValue> RechargeTimeValue = obj->TryGetField(TEXT("RechargeTime"));
    if (RechargeTimeValue.IsValid())
        RechargeTime = readDatetime(RechargeTimeValue);


    const TSharedPtr<FJsonValue> SecondsToRechargeValue = obj->TryGetField(TEXT("SecondsToRecharge"));
    if (SecondsToRechargeValue.IsValid() && !SecondsToRechargeValue->IsNull())
    {
        int32 TmpValue;
        if (SecondsToRechargeValue->TryGetNumber(TmpValue)) { SecondsToRecharge = TmpValue; }
    }

    return HasSucceeded;
}

PlayFab::MatchmakerModels::FUserInfoResponse::~FUserInfoResponse()
{

}

void PlayFab::MatchmakerModels::FUserInfoResponse::writeJSON(JsonWriter& writer) const
{
    writer->WriteObjectStart();

    if (Inventory.Num() != 0)
    {
        writer->WriteArrayStart(TEXT("Inventory"));
        for (const FItemInstance& item : Inventory)
            item.writeJSON(writer);
        writer->WriteArrayEnd();
    }


    writer->WriteIdentifierPrefix(TEXT("IsDeveloper"));
    writer->WriteValue(IsDeveloper);

    if (PlayFabId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("PlayFabId"));
        writer->WriteValue(PlayFabId);
    }

    if (SteamId.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("SteamId"));
        writer->WriteValue(SteamId);
    }

    if (TitleDisplayName.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("TitleDisplayName"));
        writer->WriteValue(TitleDisplayName);
    }

    if (Username.IsEmpty() == false)
    {
        writer->WriteIdentifierPrefix(TEXT("Username"));
        writer->WriteValue(Username);
    }

    if (VirtualCurrency.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("VirtualCurrency"));
        for (TMap<FString, int32>::TConstIterator It(VirtualCurrency); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            writer->WriteValue((*It).Value);
        }
        writer->WriteObjectEnd();
    }

    if (VirtualCurrencyRechargeTimes.Num() != 0)
    {
        writer->WriteObjectStart(TEXT("VirtualCurrencyRechargeTimes"));
        for (TMap<FString, FVirtualCurrencyRechargeTime>::TConstIterator It(VirtualCurrencyRechargeTimes); It; ++It)
        {
            writer->WriteIdentifierPrefix((*It).Key);
            (*It).Value.writeJSON(writer);
        }
        writer->WriteObjectEnd();
    }

    writer->WriteObjectEnd();
}

bool PlayFab::MatchmakerModels::FUserInfoResponse::readFromValue(const TSharedPtr<FJsonObject>& obj)
{
    bool HasSucceeded = true;

    const TArray<TSharedPtr<FJsonValue>>&InventoryArray = FPlayFabJsonHelpers::ReadArray(obj, TEXT("Inventory"));
    for (int32 Idx = 0; Idx < InventoryArray.Num(); Idx++)
    {
        TSharedPtr<FJsonValue> CurrentItem = InventoryArray[Idx];
        Inventory.Add(FItemInstance(CurrentItem->AsObject()));
    }


    const TSharedPtr<FJsonValue> IsDeveloperValue = obj->TryGetField(TEXT("IsDeveloper"));
    if (IsDeveloperValue.IsValid() && !IsDeveloperValue->IsNull())
    {
        bool TmpValue;
        if (IsDeveloperValue->TryGetBool(TmpValue)) { IsDeveloper = TmpValue; }
    }

    const TSharedPtr<FJsonValue> PlayFabIdValue = obj->TryGetField(TEXT("PlayFabId"));
    if (PlayFabIdValue.IsValid() && !PlayFabIdValue->IsNull())
    {
        FString TmpValue;
        if (PlayFabIdValue->TryGetString(TmpValue)) { PlayFabId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> SteamIdValue = obj->TryGetField(TEXT("SteamId"));
    if (SteamIdValue.IsValid() && !SteamIdValue->IsNull())
    {
        FString TmpValue;
        if (SteamIdValue->TryGetString(TmpValue)) { SteamId = TmpValue; }
    }

    const TSharedPtr<FJsonValue> TitleDisplayNameValue = obj->TryGetField(TEXT("TitleDisplayName"));
    if (TitleDisplayNameValue.IsValid() && !TitleDisplayNameValue->IsNull())
    {
        FString TmpValue;
        if (TitleDisplayNameValue->TryGetString(TmpValue)) { TitleDisplayName = TmpValue; }
    }

    const TSharedPtr<FJsonValue> UsernameValue = obj->TryGetField(TEXT("Username"));
    if (UsernameValue.IsValid() && !UsernameValue->IsNull())
    {
        FString TmpValue;
        if (UsernameValue->TryGetString(TmpValue)) { Username = TmpValue; }
    }

    const TSharedPtr<FJsonObject>* VirtualCurrencyObject;
    if (obj->TryGetObjectField(TEXT("VirtualCurrency"), VirtualCurrencyObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*VirtualCurrencyObject)->Values); It; ++It)
        {
            int32 TmpValue; It.Value()->TryGetNumber(TmpValue);
            VirtualCurrency.Add(It.Key(), TmpValue);
        }
    }

    const TSharedPtr<FJsonObject>* VirtualCurrencyRechargeTimesObject;
    if (obj->TryGetObjectField(TEXT("VirtualCurrencyRechargeTimes"), VirtualCurrencyRechargeTimesObject))
    {
        for (TMap<FString, TSharedPtr<FJsonValue>>::TConstIterator It((*VirtualCurrencyRechargeTimesObject)->Values); It; ++It)
        {
            VirtualCurrencyRechargeTimes.Add(It.Key(), FVirtualCurrencyRechargeTime(It.Value()->AsObject()));
        }
    }

    return HasSucceeded;
}

